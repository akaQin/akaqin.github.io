<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akaQin&#39;s Blog</title>
  
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-23T09:04:12.923Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Arron Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <link href="http://yoursite.com/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/"/>
    <id>http://yoursite.com/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</id>
    <published>2020-02-23T09:03:12.000Z</published>
    <updated>2020-02-23T09:04:12.923Z</updated>
    
    <content type="html"><![CDATA[<ol><li>malloc和calloc分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用mmap或sbrk系统调用</li><li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此mmap（）保证返回的新内存始终为零</li><li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li><li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从mmap（）返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;malloc和calloc分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用mmap或sbrk系统调用&lt;/li&gt;
&lt;li&gt;内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C语言编程心得</title>
    <link href="http://yoursite.com/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</id>
    <published>2020-02-23T09:01:38.000Z</published>
    <updated>2020-02-23T09:04:45.491Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p></li><li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p></li><li><p>声明变量后一定要记得赋初识值，尤其是数组</p></li><li><p>变量就近声明</p></li><li><p>文件内使用的函数要习惯声明static</p></li><li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第七章——进程环境</title>
    <link href="http://yoursite.com/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</id>
    <published>2020-02-23T08:03:39.000Z</published>
    <updated>2020-02-23T08:55:45.282Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>进程开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure><p>以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p></li><li><p>进程终止<br>有8种终止方式，前5种为正常终止：</p><ol><li>从main返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit<br>异常终止有3种：</li><li>调用abort</li><li>遇到一个信号</li><li>最后一个线程对取消请求做出响应</li></ol></li><li><p><code>atexit</code>函数</p><p>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br>调用顺序与登记顺序相反，登记多次也会调用多次。<br>如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</p></li><li><p><code>exit</code>函数7-2.png<br><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</p></li><li><p>内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。<br><img src="7-2.png" alt=""></p></li><li><p>环境表<br><img src="7-5.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程开始&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>first post</title>
    <link href="http://yoursite.com/2020/02/23/first-post/"/>
    <id>http://yoursite.com/2020/02/23/first-post/</id>
    <published>2020-02-23T07:26:11.000Z</published>
    <updated>2020-02-23T07:26:29.021Z</updated>
    
    <content type="html"><![CDATA[<p>I love you, Joyce!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I love you, Joyce!&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
