<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akaQin&#39;s Blog</title>
  
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://akaqin.github.io/"/>
  <updated>2020-04-15T10:54:43.109Z</updated>
  <id>https://akaqin.github.io/</id>
  
  <author>
    <name>Aaron Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>register、volatile、restrict和extern</title>
    <link href="https://akaqin.github.io/2020/04/15/register%E3%80%81volatile%E3%80%81restrict%E5%92%8Cextern/"/>
    <id>https://akaqin.github.io/2020/04/15/register%E3%80%81volatile%E3%80%81restrict%E5%92%8Cextern/</id>
    <published>2020-04-15T10:19:52.000Z</published>
    <updated>2020-04-15T10:54:43.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><h3 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h3><p>这个关键字暗示编译器相应的变量将被频繁地使用，如果可能的话尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>首先，register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。</p><a id="more"></a><p>其次，因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。</p><p>由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。</p><p>在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。</p><p>早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时register修饰符是C语言的一种很有价值的补充。然而，随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>volatile提醒编译器，它后面所定义的变量的值随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。</p><p>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>中断服务程序中修改的供其它程序检测的变量需要加volatile；</p></li><li><p>多任务环境下各任务间共享的标志应该加volatile；</p></li><li><p>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</p></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化，volatile的字面含义是易变的，它有下面的作用</p><ul><li><p>不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。</p></li><li><p>不做常量合并、常量传播等优化</p></li><li><p>对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作</p></li></ul><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict是c99标准引入的，它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.</p><p>考虑下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *a = <span class="number">1</span>;</span><br><span class="line">  *b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> *a + *b; <span class="comment">//并不一定等于3！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 和 b可能指向同一个数据，所以编译器在计算<em>a + *b时需要重新读取</em>a的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">restrict</span> a, <span class="keyword">int</span> *<span class="keyword">restrict</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *a = <span class="number">1</span>;</span><br><span class="line">  *b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可以根据修饰符做出优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rfoo:</span><br><span class="line">    movl    $3, %eax # 在编译期已计算出3</span><br><span class="line">    movl    $1, %rdi # 存储1至*a</span><br><span class="line">    movl    $2, %rsi # 存储2至*b</span><br></pre></td></tr></table></figure><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p><p>此外extern也可用来进行链接指定</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;register&quot;&gt;&lt;a href=&quot;#register&quot; class=&quot;headerlink&quot; title=&quot;register&quot;&gt;&lt;/a&gt;register&lt;/h2&gt;&lt;h3 id=&quot;含义：&quot;&gt;&lt;a href=&quot;#含义：&quot; class=&quot;headerlink&quot; title=&quot;含义：&quot;&gt;&lt;/a&gt;含义：&lt;/h3&gt;&lt;p&gt;这个关键字暗示编译器相应的变量将被频繁地使用，如果可能的话尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。&lt;/p&gt;
&lt;h3 id=&quot;补充：&quot;&gt;&lt;a href=&quot;#补充：&quot; class=&quot;headerlink&quot; title=&quot;补充：&quot;&gt;&lt;/a&gt;补充：&lt;/h3&gt;&lt;p&gt;首先，register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第5章——标准I/O库</title>
    <link href="https://akaqin.github.io/2020/04/15/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E6%A0%87%E5%87%86I-O%E5%BA%93/"/>
    <id>https://akaqin.github.io/2020/04/15/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E6%A0%87%E5%87%86I-O%E5%BA%93/</id>
    <published>2020-04-15T01:35:30.000Z</published>
    <updated>2020-04-15T03:49:56.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和<code>FILE</code>对象</h2><p>所有不带缓冲的I/O函数都是围绕文件描述符进行的。而对于标准I/O库，它们的操作是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。<br>对于ASCII字符集，一个字符用一个字节表示，对于国际字符集，一个字符用多个字节表示。标准I/O文件流可用于单字节或多字节字符集，由流的定向决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置流的定向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>对一个进程预定义了3个流，这3个流可以自动地被进程使用:</p><ul><li>文件指针<code>stdin</code>对应文件描述符<code>STDIN_FILENO</code></li><li>文件指针<code>stdout</code>对应文件描述符<code>STDOUT_FILENO</code></li><li>文件指针<code>stderr</code>对应文件描述符<code>STDERR_FILENO</code></li></ul><a id="more"></a><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲以尽可能减少read和write调用的次数，它也对每个I/O流自动的进行缓冲管理。</p><ul><li>全缓冲<br>这种情况下，在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。</li><li>行缓冲<br>这种情况下，在输入和输出中遇到换行符时，标准I/O库执行I/O操作。通常用在终端上。</li><li>不带缓冲<br>标准I/O库不对字符进行缓冲，通常用在标准错误上。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开或关闭缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="comment">//更改缓冲类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//冲洗一个流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *FP)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="打开-关闭流"><a href="#打开-关闭流" class="headerlink" title="打开/关闭流"></a>打开/关闭流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开指定文件</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="comment">//重新打开（关闭再打开）文件，用于打开预定义的流（标准输入/输出/错误）</span></span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="comment">//根据描述符打开文件，常用在由管道和网络通信通道函数返回的描述符</span></span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>打开方式：<br><img src="5-2.png" alt=""><br><strong>函数返回前记得关闭流以释放缓冲区</strong></p><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><h3 id="每次一个字符"><a href="#每次一个字符" class="headerlink" title="每次一个字符"></a>每次一个字符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//压回流中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>getchar 等同于 getc(stdin)。前两者的区别是getc可以被实现为宏，这意味着：</p><ul><li>getc的参数不应当是具有副作用的表达式，因为可能会被计算多次</li><li>fgetc一定是个函数，所以可以得到其地址，允许当参数传递</li><li>fgetc的调用时长可能要比getc长。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否出错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//判断是否到达文件尾端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//清除错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="每次一行"><a href="#每次一行" class="headerlink" title="每次一行"></a>每次一行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>不推荐使用gets和puts。因为不能指定缓冲区长度，可能造成缓冲区溢出</strong></p><h3 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h3><p>SUSv4中支持了内存流。这就是标准I/O流，虽然仍使用FILE指针进行访问，但并没有底层文件。所有的I/O都是通过在缓冲区与主存之间来回传送字节完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内存流</span></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>因为避免了缓冲区溢出，内存流非常适用于创建字符串。因为内存流只访问主存，不访问磁盘上的文件，所以对于把标准I/O流作为参数用于临时文件的函数来说，会有很大的性能提升。</p><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="标准I-O的优却点及效率"><a href="#标准I-O的优却点及效率" class="headerlink" title="标准I/O的优却点及效率"></a>标准I/O的优却点及效率</h2><p>使用标准I/O优点是无需考虑缓冲及最佳I/O长度的选择。不足之处是效率不高，这与它需要复制的数据量有关。当使用每次一行的fgets和fputs时，需要复制两次数据：依次是在内核和标准I/O缓冲区之间（当调用read和write时），第二次是在标准I/O缓冲区和用户程序中的行缓冲区之间。<br>标准I/O库与直接调用read和write相比并不慢很多。对于大多数复杂的应用程序，最主要的用户CPU时间是由应用本身的各种处理消耗的，而不是由标准I/O例程消耗的。</p><h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><p>格式化输出：</p><ul><li>printf 将格式化数据写到标准输出</li><li>fprintf 写到指定的流</li><li>dprintf 写到指定的文件描述符</li><li>sprintf 写到给定的缓冲区中。结尾自动加NULL，但该字符不计算在返回值中</li><li>snprintf 同上。但sprintf可能会造成缓冲区溢出，所以推荐使用snprintf显式指定缓冲区长度</li></ul><p>格式化输入：</p><ul><li>scanf 从标准输入中分析字符串</li><li>fscanf 从流中分析</li><li>sscanf 从给定缓冲区中分析</li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>UNIX中，标准I/O库最终都要调用第3章中说明的不带缓冲的I/O例程。每个I/O流都有一个与其相关的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>; <span class="comment">//获取流对应的描述符</span></span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>; <span class="comment">//产生一个与现有文件名不同的一个有效路径名字符串</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建一个临时二进制文件（类型wb+），在关闭该文件或程序结束时自动删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>; <span class="comment">//创建一个目录，该目录有一个唯一的名字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>; <span class="comment">//创建一个文件，该文件有一个唯一的名字</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和&lt;code&gt;FILE&lt;/code&gt;对象&lt;/h2&gt;&lt;p&gt;所有不带缓冲的I/O函数都是围绕文件描述符进行的。而对于标准I/O库，它们的操作是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。&lt;br&gt;对于ASCII字符集，一个字符用一个字节表示，对于国际字符集，一个字符用多个字节表示。标准I/O文件流可用于单字节或多字节字符集，由流的定向决定。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置流的定向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fwide&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FILE *fp, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;标准输入、标准输出和标准错误&quot;&gt;&lt;a href=&quot;#标准输入、标准输出和标准错误&quot; class=&quot;headerlink&quot; title=&quot;标准输入、标准输出和标准错误&quot;&gt;&lt;/a&gt;标准输入、标准输出和标准错误&lt;/h3&gt;&lt;p&gt;对一个进程预定义了3个流，这3个流可以自动地被进程使用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件指针&lt;code&gt;stdin&lt;/code&gt;对应文件描述符&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件指针&lt;code&gt;stdout&lt;/code&gt;对应文件描述符&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件指针&lt;code&gt;stderr&lt;/code&gt;对应文件描述符&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="I/O" scheme="https://akaqin.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>理解inode</title>
    <link href="https://akaqin.github.io/2020/04/14/%E7%90%86%E8%A7%A3inode/"/>
    <id>https://akaqin.github.io/2020/04/14/%E7%90%86%E8%A7%A3inode/</id>
    <published>2020-04-14T05:46:05.000Z</published>
    <updated>2020-04-14T06:17:11.197Z</updated>
    
    <content type="html"><![CDATA[<p>作者：阮一峰<br>转自：<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></p><p>inode是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p>下面就是我的inode学习笔记，尽量保持简单。</p><a id="more"></a><p>===================================</p><h3 id="一、inode是什么？"><a href="#一、inode是什么？" class="headerlink" title="一、inode是什么？"></a>一、inode是什么？</h3><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h3 id="二、inode的内容"><a href="#二、inode的内容" class="headerlink" title="二、inode的内容"></a>二、inode的内容</h3><p>inode包含文件的元信息，具体来说有以下内容：</p><p>　　* 文件的字节数</p><p>　　* 文件拥有者的User ID</p><p>　　* 文件的Group ID</p><p>　　* 文件的读、写、执行权限</p><p>　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p><p>　　* 链接数，即有多少文件名指向这个inode</p><p>　　* 文件数据block的位置</p><p>可以用stat命令，查看某个文件的inode信息：</p><p>　　stat example.txt</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120402.png" alt=""></p><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h3 id="三、inode的大小"><a href="#三、inode的大小" class="headerlink" title="三、inode的大小"></a>三、inode的大小</h3><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　df -i</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120403.png" alt=""></p><p>查看每个inode节点的大小，可以用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　sudo dumpe2fs -h &#x2F;dev&#x2F;hda | grep &quot;Inode size&quot;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120404.png" alt=""></p><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h3 id="四、inode号码"><a href="#四、inode号码" class="headerlink" title="四、inode号码"></a>四、inode号码</h3><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ls -i example.txt</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120405.png" alt=""></p><h3 id="五、目录文件"><a href="#五、目录文件" class="headerlink" title="五、目录文件"></a>五、目录文件</h3><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>ls命令只列出目录文件中的所有文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ls &#x2F;etc</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120406.png" alt=""></p><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ls -i &#x2F;etc</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120407.png" alt=""></p><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ls -l &#x2F;etc</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120408.png" alt=""></p><p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p><h3 id="六、硬链接"><a href="#六、硬链接" class="headerlink" title="六、硬链接"></a>六、硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p><p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p>ln命令可以创建硬链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ln 源文件 目标文件</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120409.png" alt=""></p><p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p><p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p><h3 id="七、软链接"><a href="#七、软链接" class="headerlink" title="七、软链接"></a>七、软链接</h3><p>除了硬链接以外，还有一种特殊情况。</p><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p><p>ln -s命令可以创建软链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ln -s 源文文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/201112/bg2011120410.png" alt=""></p><h3 id="八、inode的特殊作用"><a href="#八、inode的特殊作用" class="headerlink" title="八、inode的特殊作用"></a>八、inode的特殊作用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p><p>　　1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p><p>　　2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</p><p>　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</p><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：阮一峰&lt;br&gt;转自：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/inode.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2011/12/inode.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;inode是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。&lt;/p&gt;
&lt;p&gt;我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。&lt;/p&gt;
&lt;p&gt;下面就是我的inode学习笔记，尽量保持简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="https://akaqin.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="inode" scheme="https://akaqin.github.io/tags/inode/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第4章——文件和目录</title>
    <link href="https://akaqin.github.io/2020/04/14/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>https://akaqin.github.io/2020/04/14/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</id>
    <published>2020-04-14T01:54:37.000Z</published>
    <updated>2020-04-15T01:25:31.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="文件结构-stat"><a href="#文件结构-stat" class="headerlink" title="文件结构 stat"></a>文件结构 stat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="keyword">mode_t</span>            st_mode;    <span class="comment">// file type &amp; mode (permisssions)</span></span><br><span class="line">  <span class="keyword">ino_t</span>             st_ino;     <span class="comment">// i-node number (serial number)</span></span><br><span class="line">  <span class="keyword">dev_t</span>             st_dev;     <span class="comment">// device number (file system)</span></span><br><span class="line">  <span class="keyword">dev_t</span>             st_rdev;    <span class="comment">// device number for special files</span></span><br><span class="line">  <span class="keyword">nlink_t</span>           st_link;    <span class="comment">// number of links</span></span><br><span class="line">  <span class="keyword">uid_t</span>             st_uid;     <span class="comment">// user ID of owner</span></span><br><span class="line">  <span class="keyword">gid_t</span>             st_gid;     <span class="comment">// group ID of owner</span></span><br><span class="line">  <span class="keyword">off_t</span>             st_size;    <span class="comment">// size in bytes, for regular files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>   <span class="title">st_atime</span>;</span>   <span class="comment">// time of last access</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>   <span class="title">st_mtime</span>;</span>   <span class="comment">// time of last modification</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>   <span class="title">st_ctime</span>;</span>   <span class="comment">// time of last file status change</span></span><br><span class="line">  <span class="keyword">blksize_t</span>         st_blksize; <span class="comment">// best I/O block size 对文件I/O较适合的块长度</span></span><br><span class="line">  <span class="keyword">blkcnt_t</span>          st_blocks;  <span class="comment">// number of disk blocks allocated 所分配的实际512字节块块数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件信息结构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="comment">//根据描述符获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//获取与符号链接相关的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件（regular file)</li><li>目录文件（directory file）</li><li>块特殊文件（block special file）<br>这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定单位长度进行。</li><li>字特殊文件（character special file）<br>这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中所有设备要么是字特殊文件，要么是块特殊文件。</li><li>FIFO<br>这种类型的文件用于进程间通信，也称为命名管道（named pipe）。</li><li>套接字（socket）<br>这种类型的文件用于进程间的网络通信，也可用于一台宿主机上进程之间的非网络通信。</li><li>符号链接（symbolic link）<br>这种类型的文件指向另一个文件。</li></ul><h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>st_size表示以字节为单位的文件长度。此字段只对普通文件、目录文件和符号链接有意义。</p><ul><li>对于普通文件，长度可以是0。</li><li>对于目录，长度通常是一个数（16或512）的整数倍。</li><li>对于符号链接，尝试是文件名中的字节数。</li></ul><h4 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h4><p>文件空洞是由所设置的偏移量超过文件尾端，并写入了数据后造成的。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNIX文件系统有很多种实现，这里讨论UFS文件系统。<br><img src="4-13.png" alt=""><br><img src="4-14.png" alt=""></p><ul><li>每个i节点都有一个链接计数，其值指向i节点的目录项数。只有计数减少到0时，才可删除文件（也就是释放该文件占用的数据块）。链接计数包含在stat结构里的st_nlink字段中，这种链接类型称为硬链接。</li><li>另一种链接类型为符号链接（symbolic link）。符号链接文件的实际内容包含了该符号链接所指向的文件的名字。</li><li>i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中大多数信息都取自i节点，除了文件名和i节点编号。</li><li>目录项中的i节点编号指向同一文件系统中的i节点。</li><li>在不更换文件系统的情况下，重命名文件并不会让文件的实际内容变动，只需要构造一个指向现有i几点的新目录项，并删除老的目录项，链接数不变。</li></ul><p><img src="4-15.png" alt=""></p><ul><li>每个叶目录的链接计数总是2（来自 该目录名 和<code>.</code>）。</li><li>父目录中的每一个子目录都使该父目录的链接计数加1（子目录中的<code>..</code>项指向父目录）</li></ul><h3 id="link、linkat、unlink、unlinkat和remove"><a href="#link、linkat、unlink、unlinkat和remove" class="headerlink" title="link、linkat、unlink、unlinkat和remove"></a>link、linkat、unlink、unlinkat和remove</h3><p>任何一个文件可以有多个目录项指向其i节点。创建一个指向现有文件的链接的方法是使用link或linkat函数。<br>删除一个目录项使用unlink函数，只有链接计数达到0时，该文件内容才可被删除。<br>remove既能删文件（等同于unlink）也能删目录（等同于rmdir）。</p><h3 id="rename-和-renameat"><a href="#rename-和-renameat" class="headerlink" title="rename 和 renameat"></a>rename 和 renameat</h3><p>用来对文件重命名。</p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>符号链接是对一个文件的间接指针，硬链接直接指向文件的i节点。<br>使用symlink或syslinkat函数创建一个符号链接。</p><h3 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h3><ul><li>st_atime 文件数据的最后访问时间</li><li>st_mtime 文件数据的最后修改时间</li><li>st_ctime i节点状态的最后更改时间</li></ul><p>操作函数：</p><ul><li>futimens</li><li>utimensat</li><li>utimes</li></ul><h2 id="权限及属组"><a href="#权限及属组" class="headerlink" title="权限及属组"></a>权限及属组</h2><h3 id="用户ID和组ID"><a href="#用户ID和组ID" class="headerlink" title="用户ID和组ID"></a>用户ID和组ID</h3><p>与一个进程相关联的ID：<br><img src="4-5.png" alt=""></p><ul><li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。</li><li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li><li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的一个副本。</li></ul><p>执行一个程序文件时，进程的有效用户ID就是实际用户ID，有效组ID就是实际组ID。但可以在文件模式字（st_mode）中设置一个特殊标志，将执行此文件时的有效用户ID设置为文件所有者的用户ID；或将有效组ID设置为文件的组所有者ID。</p><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>st_mode值也包含了对文件的访问权限位。<br><img src="4-6.png" alt=""></p><ul><li>读权限决定了我们能否打开一个文件进行读操作，包括读目录中的内容。</li><li>写权限决定了我们能否打开一个文件进行写操作。</li><li>打开任一文件时要对它的每一级父目录（包括当前目录）有执行权限。</li><li>在目录中创建一个新文件需要对该目录有写和执行权限。</li><li>删除一个现有文件，需要对包含该文件的目录具有写和执行权限，对该文件本身不需要有读、写权限。</li></ul><p><strong>目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</strong></p><h3 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h3><ul><li>新文件的用户ID设置为进程的有效用户ID。</li><li>新文件的组ID可以是进程的有效组ID也可以是它所在的目录的组ID。</li></ul><h3 id="access-和-faccessat"><a href="#access-和-faccessat" class="headerlink" title="access 和 faccessat"></a>access 和 faccessat</h3><p>用<code>open</code>函数打开文件时，内核以进程的有效用户ID和有效组ID做访问权限测试，<code>access</code>和<code>faccessat</code>函数按实际用户ID和实际组ID进行测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccess</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode ,<span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p><code>umask</code>函数为进程设置文件膜创建屏蔽字，并返回之前的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="4-10.png" alt=""></p><h3 id="chmod、fchmod和fchmodat"><a href="#chmod、fchmod和fchmodat" class="headerlink" title="chmod、fchmod和fchmodat"></a>chmod、fchmod和fchmodat</h3><p>这三个函数使我们更改现有文件的访问权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="4-11.png" alt=""></p><h3 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h3><p>UNIX早期版本中，S_ISVTX位被称为<code>粘着位(sticky bit)</code>。如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分（机器指令）的一个副本仍被保存在交换区。这使得下次执行该程序时能较快的将其载入内存。</p><h4 id="Linux中的交换区"><a href="#Linux中的交换区" class="headerlink" title="Linux中的交换区"></a>Linux中的交换区</h4><blockquote><p>Linux中Swap（即：交换分区），类似于Windows的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。Android是基于Linux的操作系统，所以也可以使用Swap分区来提升系统运行效率 。</p></blockquote><p>现今交心的UNIX系统大多配置了虚拟存储系统以及快速文件系统，不再需要这种技术。<br>SUS允许针对目录设置粘着位，目录/tmp和/var/tmp是设置粘着位的典型候选者——任何用户都可在这两个目录中创建文件；任一用户对这两个目录的权限通常都是读、写、执行。</p><h3 id="chown、fchown、fchownat和lchown"><a href="#chown、fchown、fchownat和lchown" class="headerlink" title="chown、fchown、fchownat和lchown"></a>chown、fchown、fchownat和lchown</h3><p>这几个函数更改文件的用户ID和组ID。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>目录由DIR结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>__dd_fd;<span class="comment">// file descriptor associated with directory</span></span><br><span class="line"><span class="keyword">long</span>__dd_loc;<span class="comment">// offset in current buffer</span></span><br><span class="line"><span class="keyword">long</span>__dd_size;<span class="comment">// amount of data returned</span></span><br><span class="line"><span class="keyword">char</span>*__dd_buf;<span class="comment">// data buffer</span></span><br><span class="line"><span class="keyword">int</span>__dd_len;<span class="comment">// size of data buffer</span></span><br><span class="line"><span class="keyword">long</span>__dd_seek;<span class="comment">// magic cookie returned</span></span><br><span class="line">__unused <span class="keyword">long</span>__padding; <span class="comment">// (__dd_rewind space left for bincompat)</span></span><br><span class="line"><span class="keyword">int</span>__dd_flags;<span class="comment">// flags for readdir</span></span><br><span class="line"><span class="keyword">__darwin_pthread_mutex_t</span> __dd_lock; <span class="comment">// for thread locking</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">telldir</span> *__<span class="title">dd_td</span>;</span> <span class="comment">// telldir position recording</span></span><br><span class="line">&#125; DIR;</span><br></pre></td></tr></table></figure><p>目录项 dirent结构与实现有关，至少包含下列两个成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ino_t</span> d_ino; <span class="comment">//i-node number</span></span><br><span class="line"><span class="keyword">char</span> d_name[]; <span class="comment">//null-terminated filename</span></span><br></pre></td></tr></table></figure><ul><li><code>mkdir</code>/<code>mkdirat</code> 创建目录</li><li><code>rmdir</code> 删除目录</li><li><code>opendir</code>/<code>fdopendir</code> 打开目录</li><li><code>readdir</code> 读一个目录项</li><li><code>rewinddir</code> 将偏移量重制</li><li><code>closedir</code> 关闭文件</li><li><code>telldir</code> 获取偏移量</li><li><code>seekdir</code> 更改偏移量</li></ul><p><strong>有权限的用户都可以读目录，但只有内核才可以写目录。</strong></p><h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p>每个进程都有一个当前工作目录，它是搜索所有相对路径名的起点。</p><ul><li><code>chdir</code>/<code>fchdir</code> 指定新的当前工作目录</li><li><code>getcwd</code> 获取当前工作目录</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h2&gt;&lt;h3 id=&quot;文件结构-stat&quot;&gt;&lt;a href=&quot;#文件结构-stat&quot; class=&quot;headerlink&quot; title=&quot;文件结构 stat&quot;&gt;&lt;/a&gt;文件结构 stat&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stat&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt;            st_mode;    &lt;span class=&quot;comment&quot;&gt;// file type &amp;amp; mode (permisssions)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;ino_t&lt;/span&gt;             st_ino;     &lt;span class=&quot;comment&quot;&gt;// i-node number (serial number)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;dev_t&lt;/span&gt;             st_dev;     &lt;span class=&quot;comment&quot;&gt;// device number (file system)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;dev_t&lt;/span&gt;             st_rdev;    &lt;span class=&quot;comment&quot;&gt;// device number for special files&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;nlink_t&lt;/span&gt;           st_link;    &lt;span class=&quot;comment&quot;&gt;// number of links&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uid_t&lt;/span&gt;             st_uid;     &lt;span class=&quot;comment&quot;&gt;// user ID of owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;gid_t&lt;/span&gt;             st_gid;     &lt;span class=&quot;comment&quot;&gt;// group ID of owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt;             st_size;    &lt;span class=&quot;comment&quot;&gt;// size in bytes, for regular files&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timespec&lt;/span&gt;   &lt;span class=&quot;title&quot;&gt;st_atime&lt;/span&gt;;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// time of last access&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timespec&lt;/span&gt;   &lt;span class=&quot;title&quot;&gt;st_mtime&lt;/span&gt;;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// time of last modification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timespec&lt;/span&gt;   &lt;span class=&quot;title&quot;&gt;st_ctime&lt;/span&gt;;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// time of last file status change&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;blksize_t&lt;/span&gt;         st_blksize; &lt;span class=&quot;comment&quot;&gt;// best I/O block size 对文件I/O较适合的块长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;blkcnt_t&lt;/span&gt;          st_blocks;  &lt;span class=&quot;comment&quot;&gt;// number of disk blocks allocated 所分配的实际512字节块块数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文件" scheme="https://akaqin.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="目录" scheme="https://akaqin.github.io/tags/%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第2章——UNIX标准及实现</title>
    <link href="https://akaqin.github.io/2020/04/14/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC2%E7%AB%A0%E2%80%94%E2%80%94UNIX%E6%A0%87%E5%87%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://akaqin.github.io/2020/04/14/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC2%E7%AB%A0%E2%80%94%E2%80%94UNIX%E6%A0%87%E5%87%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-14T00:41:33.000Z</published>
    <updated>2020-04-14T01:26:49.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX标准化"><a href="#UNIX标准化" class="headerlink" title="UNIX标准化"></a>UNIX标准化</h2><h3 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h3><p>ISO（国际标准化组织） C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是适合UNIX系统。此标准不仅定了C程序设计语言的语法和语义，还定义了其标准库。</p><h3 id="IEEE-POSIX"><a href="#IEEE-POSIX" class="headerlink" title="IEEE POSIX"></a>IEEE POSIX</h3><p>POSIX是由IEEE（电气和电子工程师学会）指定的标准族。POSIX指的是可移植操作系统接口。</p><h3 id="Single-UNIX-Specification"><a href="#Single-UNIX-Specification" class="headerlink" title="Single UNIX Specification"></a>Single UNIX Specification</h3><p>Single UNIX Specification（SUS，单一UNIX规范）是POSIX.1标准的一个超集，它定义了一些附加接口扩展了POSIX.1规范提供的功能。POSIX.1相当于Single UNIX Specification中的基本规范部分。</p><a id="more"></a><h2 id="UNIX-系统实现"><a href="#UNIX-系统实现" class="headerlink" title="UNIX 系统实现"></a>UNIX 系统实现</h2><h3 id="SVR4"><a href="#SVR4" class="headerlink" title="SVR4"></a>SVR4</h3><h3 id="4-4BSD"><a href="#4-4BSD" class="headerlink" title="4.4BSD"></a>4.4BSD</h3><h3 id="FreeBSD"><a href="#FreeBSD" class="headerlink" title="FreeBSD"></a>FreeBSD</h3><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h3><h3 id="Solaris"><a href="#Solaris" class="headerlink" title="Solaris"></a>Solaris</h3><h2 id="标准和实现的关系"><a href="#标准和实现的关系" class="headerlink" title="标准和实现的关系"></a>标准和实现的关系</h2><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>以下两类的限制是必须的：</p><ul><li>编译时限制（例如，短整型的最大值是什么）</li><li>运行时限制（例如，文件名有多少个字符）</li></ul><p>为了解决这类问题，提供了以下3种限制：</p><ul><li>编译时限制（头文件）</li><li>与文件或目录无关的运行时限制（sysconf函数）</li><li>与文件或目录有关的运行时限制（pathconf和fpathconf函数）</li></ul><h3 id="ISO-C限制"><a href="#ISO-C限制" class="headerlink" title="ISO C限制"></a>ISO C限制</h3><p><img src="2-6.png" alt=""><br><img src="2-7.png" alt=""></p><h3 id="POSIX-限制"><a href="#POSIX-限制" class="headerlink" title="POSIX 限制"></a>POSIX 限制</h3><p><img src="2-8.png" alt=""><br><img src="2-9.png" alt=""></p><h3 id="sysconf、pathconf和fpathconf"><a href="#sysconf、pathconf和fpathconf" class="headerlink" title="sysconf、pathconf和fpathconf"></a>sysconf、pathconf和fpathconf</h3><p>运行时限制可以调用这三个函数之一获得</p><h2 id="基本系统数据类型"><a href="#基本系统数据类型" class="headerlink" title="基本系统数据类型"></a>基本系统数据类型</h2><p><img src="2-21.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UNIX标准化&quot;&gt;&lt;a href=&quot;#UNIX标准化&quot; class=&quot;headerlink&quot; title=&quot;UNIX标准化&quot;&gt;&lt;/a&gt;UNIX标准化&lt;/h2&gt;&lt;h3 id=&quot;ISO-C&quot;&gt;&lt;a href=&quot;#ISO-C&quot; class=&quot;headerlink&quot; title=&quot;ISO C&quot;&gt;&lt;/a&gt;ISO C&lt;/h3&gt;&lt;p&gt;ISO（国际标准化组织） C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是适合UNIX系统。此标准不仅定了C程序设计语言的语法和语义，还定义了其标准库。&lt;/p&gt;
&lt;h3 id=&quot;IEEE-POSIX&quot;&gt;&lt;a href=&quot;#IEEE-POSIX&quot; class=&quot;headerlink&quot; title=&quot;IEEE POSIX&quot;&gt;&lt;/a&gt;IEEE POSIX&lt;/h3&gt;&lt;p&gt;POSIX是由IEEE（电气和电子工程师学会）指定的标准族。POSIX指的是可移植操作系统接口。&lt;/p&gt;
&lt;h3 id=&quot;Single-UNIX-Specification&quot;&gt;&lt;a href=&quot;#Single-UNIX-Specification&quot; class=&quot;headerlink&quot; title=&quot;Single UNIX Specification&quot;&gt;&lt;/a&gt;Single UNIX Specification&lt;/h3&gt;&lt;p&gt;Single UNIX Specification（SUS，单一UNIX规范）是POSIX.1标准的一个超集，它定义了一些附加接口扩展了POSIX.1规范提供的功能。POSIX.1相当于Single UNIX Specification中的基本规范部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UNIX" scheme="https://akaqin.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第1章——UNIX基础知识</title>
    <link href="https://akaqin.github.io/2020/04/13/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC1%E7%AB%A0%E2%80%94%E2%80%94UNIX%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://akaqin.github.io/2020/04/13/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC1%E7%AB%A0%E2%80%94%E2%80%94UNIX%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-13T13:57:59.000Z</published>
    <updated>2020-04-14T01:36:39.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX-体系结构"><a href="#UNIX-体系结构" class="headerlink" title="UNIX 体系结构"></a>UNIX 体系结构</h2><p>严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们称这种软件为内核，内核的接口被称为 <strong>系统调用（system call）</strong>。<br>广义上说，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥作用，使其具有自己的特性。这里说的软件包括系统实用程序、应用程序、shell以及公用函数库等。<br>例如，Linux是GNU操作系统使用的内核。<br><img src="1-1.png" alt=""></p><a id="more"></a><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="登录名"><a href="#登录名" class="headerlink" title="登录名"></a>登录名</h3><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><h3 id="目录名"><a href="#目录名" class="headerlink" title="目录名"></a>目录名</h3><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><h3 id="不带缓存的I-O"><a href="#不带缓存的I-O" class="headerlink" title="不带缓存的I/O"></a>不带缓存的I/O</h3><p><code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>、<code>close</code></p><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。</p><h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p>程序的执行实例叫做进程。</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>3个主要的控制函数：<code>fork</code>、<code>exec</code>和<code>waitpid</code></p><h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>UNIX函数出错时，通常返回一个负值，而且整型变量errno通常被设置为特定的值。</p><h3 id="出错恢复"><a href="#出错恢复" class="headerlink" title="出错恢复"></a>出错恢复</h3><p>致命性错误无法恢复；非致命性错误可以恢复。</p><h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><h3 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h3><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>UNIX使用过两种不同的时间值：</p><ul><li>日历时间，time_t</li><li>进程时间/CPU时间，以时钟滴答计算，clock_t</li></ul><p>度量一个进程的执行时间时，UNIX系统为进程维护了3个进程时间值：</p><ul><li>时钟时间/墙上时钟时间</li><li>用户CPU时间</li><li>系统CPU时间</li></ul><p>用户CPU时间 + 系统CPU时间 = CPU时间</p><h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><p><img src="1-11.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UNIX-体系结构&quot;&gt;&lt;a href=&quot;#UNIX-体系结构&quot; class=&quot;headerlink&quot; title=&quot;UNIX 体系结构&quot;&gt;&lt;/a&gt;UNIX 体系结构&lt;/h2&gt;&lt;p&gt;严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们称这种软件为内核，内核的接口被称为 &lt;strong&gt;系统调用（system call）&lt;/strong&gt;。&lt;br&gt;广义上说，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥作用，使其具有自己的特性。这里说的软件包括系统实用程序、应用程序、shell以及公用函数库等。&lt;br&gt;例如，Linux是GNU操作系统使用的内核。&lt;br&gt;&lt;img src=&quot;1-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UNIX" scheme="https://akaqin.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第14章——高级I/O</title>
    <link href="https://akaqin.github.io/2020/04/11/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC14%E7%AB%A0%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7I-O/"/>
    <id>https://akaqin.github.io/2020/04/11/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC14%E7%AB%A0%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7I-O/</id>
    <published>2020-04-11T06:01:11.000Z</published>
    <updated>2020-04-14T13:03:49.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="同步，异步，阻塞，非阻塞"><a href="#同步，异步，阻塞，非阻塞" class="headerlink" title="同步，异步，阻塞，非阻塞"></a>同步，异步，阻塞，非阻塞</h3><p><strong>同步与异步</strong><br>同步是指代码调用IO操作时，必须等待IO操作完成才返回的调用方式。<br>异步是指代码调用IO操作时，不必等IO操作完成就返回的调用方式。</p><p>同步是最原始的调用方式。<br>异步则需要多线程，多CPU或者非阻塞IO的支持。<br><strong>阻塞与非阻塞</strong><br>阻塞是指调用线程或者进程被操作系统挂起。<br>非阻塞是指调用线程或者进程不会被操作系统挂起。</p><p>没有IO操作，所有的代码基本都是同步的<br>有了IO操作后，如果没有多进程多线程，所有代码还是同步的<br>有了IO操作，有了多进程多线程，代码才有了异步的可能性，同时也产生了阻塞与非阻塞</p><a id="more"></a><h3 id="”低速“系统调用（阻塞的原因）"><a href="#”低速“系统调用（阻塞的原因）" class="headerlink" title="”低速“系统调用（阻塞的原因）"></a>”低速“系统调用（阻塞的原因）</h3><p>系统调用分为两类：“低速”系统调用和其他。<br>低速系统调用是可能会使进程永远阻塞的一类系统调用，包括：</p><ul><li>如果某些文件类型（如读管道、终端设备和网络设备）的数据并不存在，读操作可能会使调用者永远阻塞；</li><li>如果数据不能被相同的文件类型立即接受（如管道中无空间、网络流控制），写操作可能会使调用者永远阻塞；</li><li>在某种条件发生之前打开某些文件类型可能会发生阻塞（如打开一个终端设备，需要先等待与之连接的调制解调器应答）</li><li>对已经加上强制性记录锁的文件进行读写；</li><li>某些ioctl操作；</li><li>某些进程间通信函数；</li></ul><p><strong>虽然读写磁盘文件会暂时阻塞调用者，但并不能将与磁盘I/O有关的系统调用视为”低速“</strong></p><h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p>阻塞I/O到处可见，比如从一个描述符读，然后又写到另一个描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n=<span class="built_in">read</span>(STDIN_FILENO, buf, BUFSIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n) &#123;</span><br><span class="line">    err_sys(<span class="string">"write error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>非阻塞I/O是我们可以发出 open、read 和 write 这样的I/O操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。<br>对于一个给定的描述符，有两种为其指定非阻塞I/O的方法：</p><ul><li>如果调用 open 获得描述符，可指定 O_NONBLOCK 标志。</li><li>对于已经打开的描述符，则可调用 fcntl 打开 O_NONBLOCK 文件状态标志。</li></ul><h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。它锁定的只是文件中的一个区域（也可能是整个文件）。<br>记录锁在各种系统种有不同的形式，POSIX。1标准的基础是fcntl方法。<br><img src="14-2.png" alt=""></p><h3 id="fcntl-记录锁"><a href="#fcntl-记录锁" class="headerlink" title="fcntl 记录锁"></a>fcntl 记录锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* struct flock *flockptr */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">  short l_type;   <span class="comment">/* 锁类型，F_RDLOCK（共享读锁）、F_WRLCK（独占写锁）或 F_UNLCK （解锁一个区域） */</span></span><br><span class="line">  short l_whence; <span class="comment">/* 根源（从什么地方开始)：SEEK_SET、SEEK_CUR or SEEK_END */</span></span><br><span class="line">  <span class="keyword">off_t</span> l_start;  <span class="comment">/* 和 l_whence 共同组成要加锁/解锁区域的其实字节偏移量 */</span></span><br><span class="line">  <span class="keyword">off_t</span> l_len;    <span class="comment">/* 加锁/解锁区域的字节长度 */</span></span><br><span class="line">  <span class="keyword">off_t</span> l_pid;    <span class="comment">/* 进程的ID（l_pid）持有的锁能阻塞当前进程（仅由 F_GETLK 返回） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共享读锁（L_RDLCK）和独占性写锁（L_WRLCK）。任意多个进程在一个给定的字节上可以各自有一把共享的读锁，但是在一个给定字节上只能有一个进程有一把独占写锁。<br>进一步而言，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁；如果一个字节上已经有一把独占写锁，则不能再对它加任何锁。<br>单个进程提出多个锁请求时，新锁将替换就锁。<br><img src="14-3.png" alt=""><br>加读锁时，描述符必须是读打开；加写锁时，描述符必须是写打开；<br><strong>频繁的加读锁可能会把请求写锁的进程给饿死</strong><br>锁会自动的分裂和组合：<br><img src="14-4.png" alt=""></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如果两个进程相互等待对方持有的锁并切不释放自己持有的锁时，这两个进程就进入了死锁的状态。</p><h3 id="锁的隐含继承和释放"><a href="#锁的隐含继承和释放" class="headerlink" title="锁的隐含继承和释放"></a>锁的隐含继承和释放</h3><ul><li>锁与进程和文件两者相关联：</li></ul><ol><li>当一个进程终止时，它所建立的锁全部释放；</li><li>无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁都会释放。</li></ol><ul><li>由 fork 产生的子进程不继承父进程所设置的锁。因为锁的作用是阻止多个进程同时写同一个文件。</li><li>在执行 exec 后，新程序可以继承原执行程序的锁。</li></ul><h3 id="FreeBSD-实现"><a href="#FreeBSD-实现" class="headerlink" title="FreeBSD 实现"></a>FreeBSD 实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd1 = <span class="built_in">open</span>(pathname, ...);</span><br><span class="line">write_lock(fd1, <span class="number">0</span>, SEEK_SET, <span class="number">1</span>);  <span class="comment">/* parent write locks byte 0 */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  fd2 = dump(fd1);</span><br><span class="line">  fd3 = <span class="built_in">open</span>(pathname, ...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">  read_lock(fd1, <span class="number">1</span>, SEEK_SET, <span class="number">1</span>);  <span class="comment">/* child read locks byte 1 * /</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="14-8.png" alt=""><br><strong>锁结构的指针放在了v节点（Linux里是i通用节点）结构里。</strong><br>在父进程中，关闭 fd1、fd2 或 fd3 中的任意一个都将释放由父进程设置的写锁。在关闭这三个中的任意一个h时，内核会从该描述符锁关联的i节点开始，逐个检查 lockf 链接表中的各项，并释放由调用进程持有的各把锁。内核并不清楚（也不关心）父进程是用这三个中的哪个描述符来设置这把锁的。</p><h3 id="建议锁和强制锁"><a href="#建议锁和强制锁" class="headerlink" title="建议锁和强制锁"></a>建议锁和强制锁</h3><p>考虑数据库访问例程库。如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数访问数据库的进程集为<code>合作进程（cooperating process）</code>。如果这些函数是唯一地用来访问数据库的函数，那么它们使用建议锁是可行的。但建议锁不能阻止对数据库文件有写权限的任何其他进程写这个数据库文件。不实用数据库访问例程库协同一致的方法来访问数据库的进程是非合作进程。<br>强制锁会让内核检查每一个 open、read 和 write，验证调用进程是否违背了正在访问的文件上的一把锁。强制性锁也被成为强迫方式锁。</p><h4 id="当两个人同时编辑同一个文件时会怎样？"><a href="#当两个人同时编辑同一个文件时会怎样？" class="headerlink" title="当两个人同时编辑同一个文件时会怎样？"></a>当两个人同时编辑同一个文件时会怎样？</h4><p><strong>一般的UNIX系统文本编辑器并不使用记录锁，所以该文件的最后结果取决于写该文件的最后一个进程。</strong></p><h4 id="守护进程可以用一把文件所保证守护进程的唯一副本在运行。"><a href="#守护进程可以用一把文件所保证守护进程的唯一副本在运行。" class="headerlink" title="守护进程可以用一把文件所保证守护进程的唯一副本在运行。"></a>守护进程可以用一把文件所保证守护进程的唯一副本在运行。</h4><h2 id="处理多个描述符"><a href="#处理多个描述符" class="headerlink" title="处理多个描述符"></a>处理多个描述符</h2><p>处理多个描述符的I/O操作时，我们不能在任何一个描述符上进行阻塞I/O，否则可能会因为被阻塞在一个描述符的I/O操作上而导致另一个描述符即使可以进行I/O也无法处理。如telnet命令：<br><img src="14-13.png" alt=""><br>处理这类问题有几个方法：</p><ul><li><strong>多进程</strong><br>父进程阻塞读终端数据，子进程阻塞读telnetd数据。但也产生了问题：操作什么时候终止？父/子进程其中一个终止时需要使用信号通知另一个进程终止，这使程序变得复杂。</li><li><strong>多线程</strong><br>这避免了终止的复杂性，但却要求处理两个线程之间的同步，在复杂性方面得不偿失。</li><li><strong>单线程轮询</strong><br>将两个输入描述符都设置为非阻塞，对第一个描述符发一个read，若有数据则处理，若没数据可读，则立即返回。然后对第二个描述符同样处理。等待一定时间后再次循环。<br>这种方法的弊端是浪费CPU时间。大多数时间是无数据可读的，因此执行read系统调用浪费了时间，而且需要等待多久很难确定。在多任务系统中应当避免使用这种方法。</li><li><strong>异步I/O</strong><br>进程告诉内核：当描述符准备好可以进行I/O时，用一个信号通知它。这种技术有两个问题：</li></ul><ol><li>可移植性。每个系统提供了各自的受限形式的异步I/O，但POSIX采纳了另外一套标准化接口。</li><li>这种信号对每个进程而言只有一个（SIGPOLL或SIGIO）。如果使该信号对两个描述符都起作用，那么进程在接到此信号时就无法判别是哪一个描述符准备好了，仍需将两个描述符都设置为非阻塞，然后顺序尝试执行I/O。</li></ol><ul><li><strong>I/O多路转接</strong><br>先构造一个我们感兴趣的描述符列表，然后调用函数（select/pselect/poll），直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。</li></ul><h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><h3 id="select-和-pselect"><a href="#select-和-pselect" class="headerlink" title="select 和 pselect"></a>select 和 pselect</h3><p>传给select的参数告诉内核：</p><ul><li>我们所关心的描述符</li><li>对于每个描述符我们所关心的条件（是否从一个给定的描述符读、是否写一个特定的描述符、是否关心一个特定描述符的异常条件）</li><li>愿意等待多长时间（永远等待、等待固定时间或不等待）<br>从select返回时，内核告诉我们：</li><li>已准备好的描述符总数量</li><li>对于读、写或异常这三个条件中的每一个，哪些描述符已准备好<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,</span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *<span class="keyword">restrict</span> writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *<span class="keyword">restrict</span> exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *<span class="keyword">restrict</span> tvptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>对于“准备好”的含义具体说明：</li><li>若对读集中的一个描述符进行的read操作不会阻塞，则认为此描述符是准备好的。</li><li>若对写集中的一个描述符进行的write操作不会阻塞，则认为此描述符是准备好的。</li><li>若对异常条件集中的一个描述符有一个未决异常条件，则认为此描述符是准备好的。包括：在网络连接上到达带外数据，或者在处于数据包模式的伪终端上发生了某些条件。</li><li><strong>对于读、写和异常条件，普通文件的描述符总是准备好的</strong></li></ul><p><strong>一个描述符阻塞与否并不影响select是否阻塞。</strong></p><h4 id="select和pselect的区别"><a href="#select和pselect的区别" class="headerlink" title="select和pselect的区别"></a>select和pselect的区别</h4><ul><li>select的超时值用timeval结构指定（秒和微秒）；pselect使用timespec结构（秒和纳秒），更精准</li><li>pselect的超时值被声明为const，这保证了调用pselect不会改变此值</li><li>pselect可使用可选信号屏蔽字</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll类似于select，但程序员接口有所不同。poll构造一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">/*要检测的描述符*/</span></span><br><span class="line">  short events; <span class="comment">/*要检测的事件*/</span></span><br><span class="line">  short revents; <span class="comment">/*发生了的事件*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前4行可读性，接下来3行是可写性，最后3行是由内核在返回时设置的。<br><img src="14-18.png" alt=""><br>如果我们正从终端输入数据，并键入文件结束符，那会打开POLLIN，于是我们就可以读文件结束指示。revertns中的POLLHUP没有打开。如果正在读调制解调器，并且电话线已挂断，我们将接到POLLHUP通知。</p><h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>使用 POSIX 异步I/O接口，会带来一些麻烦：</p><ul><li>每个异步操作有3处可能产生错误的地方：操作提交的部分；操作本身的结果；用于决定异步操作状态的函数中。</li><li>与POSIX异步I/O接口的传统方法相比，它们本身涉及大量的额外设置和处理规则。</li><li>从错误中恢复可能会比较困难。</li></ul><h3 id="BSD异步I-O"><a href="#BSD异步I-O" class="headerlink" title="BSD异步I/O"></a>BSD异步I/O</h3><p>在BSD派生的系统中，异步I/O是信号SIGIO和SIGURG的组合。SIGIO是通用异步I/O信号，SIGURG则只用来通知进程网络连接上的带外数据已到达。<br>接收SIGIO信号分三步：</p><ol><li>调用signal或sigaction为SIGIO信号建立信号处理程序。</li><li>以命令F_SETOWN调用fcntl来设置进程ID或进程组ID，用于接收对于该描述符的信号。</li><li>以命令F_SETFL调用fcntl设置O_ASYNC文件状态标志，使在该描述符上可以进行异步I/O。</li></ol><h3 id="POSIX-异步I-O"><a href="#POSIX-异步I-O" class="headerlink" title="POSIX 异步I/O"></a>POSIX 异步I/O</h3><p>POSIX异步I/O接口为对不同类型的文件进行异步I/O提供了一套一致的方法。<br>这些异步I/O接口使用AIO控制块来描述I/O操作。aiocb结构定义了AIO控制块，在进行异步I/O之前需要先初始化AIO模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>             aio_fildes;             <span class="comment">/*用来读/写的文件描述符*/</span></span><br><span class="line"><span class="keyword">off_t</span>           aio_offset;             <span class="comment">/*起始的偏移量*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">void</span>   *aio_buf;               <span class="comment">/*缓冲区地址*/</span></span><br><span class="line"><span class="keyword">size_t</span>          aio_nbytes;             <span class="comment">/*要读/写的长度*/</span></span><br><span class="line"><span class="keyword">int</span>             aio_reqprio;            <span class="comment">/*请求优先级，排序用*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>           <span class="comment">/*I/O完成后通知应用程序的方式*/</span></span><br><span class="line"><span class="keyword">int</span>             aio_lio_opcode;         <span class="comment">/*Operation to be performed*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>            sigev_notify;                   <span class="comment">/*通知类型：不通知/sigev_signo信号通知/分离状态下的单线程执行sigev_notify_function*/</span></span><br><span class="line"><span class="keyword">int</span>            sigev_signo;                    <span class="comment">/*指定通知信号*/</span></span><br><span class="line"><span class="keyword">union</span> sigval   sigev_value;                    <span class="comment">/*信号结构里的自定义参数*/</span></span><br><span class="line"><span class="keyword">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);   <span class="comment">/*通知方法*/</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;       <span class="comment">/*通知属性*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>异步I/O请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb *aiocbp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_write</span><span class="params">(struct aiocb *aiocbp)</span></span>;</span><br></pre></td></tr></table></figure><p>冲洗数据，强制所有等待中的异步操作不等待而写入持久化存储：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_fsync</span><span class="params">(<span class="keyword">int</span> op, struct aiocb *aiocbp)</span></span>;</span><br></pre></td></tr></table></figure><p>获取一个异步I/O操作的完成状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_error</span><span class="params">(<span class="keyword">const</span> struct aiocb *aiocbp)</span></span>;</span><br></pre></td></tr></table></figure><p>如果操作成功，可以调用aio_return函数获取异步操作的返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">aio_return</span><span class="params">(<span class="keyword">const</span> struct aiocb *aiocbp)</span></span>;</span><br></pre></td></tr></table></figure><p>如果完成了所有事务时，还有异步操作未完成时，可以调用aio_suspend函数来阻塞进程，直到操作完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> struct aiocb *<span class="keyword">const</span> <span class="built_in">list</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nent,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> struct timespec *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>不想再等待未完成的异步I/O操作时，调用aio_cancel:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_cancel</span><span class="params">(<span class="keyword">int</span> ofd, struct aiocb *aiocbp)</span></span>;</span><br></pre></td></tr></table></figure><p>批量I/O，可异步，可同步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lio_listio</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct aiocb *<span class="keyword">const</span> aiocblist[],</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nent,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sigevent *sigp</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="readv-和-writev"><a href="#readv-和-writev" class="headerlink" title="readv 和 writev"></a>readv 和 writev</h2><p>用于在一次函数调用中读、写锁哥非连续缓冲区。也成为散布读（scatter read）和聚集写（gather write）。</p><h2 id="readn-和-writen"><a href="#readn-和-writen" class="headerlink" title="readn 和 writen"></a>readn 和 writen</h2><p>管道、FIFO以及某些设备（终端和网络）有下列性质：</p><ul><li>一次read操作的返回值可能少于所有求的数据，即使还没到达文件尾端，也可能是这样，这不是错误，应当继续读该设备。</li><li>一次write操作的返回值可能少于指定字节数。这是某些原因造成的，如内核输出缓冲区变满。这也不是错误，应当继续写余下数据。</li></ul><p>readn和writen的功能是指定读/写n字节数据，并处理返回值可能小于要求值的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;同步，异步，阻塞，非阻塞&quot;&gt;&lt;a href=&quot;#同步，异步，阻塞，非阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步，异步，阻塞，非阻塞&quot;&gt;&lt;/a&gt;同步，异步，阻塞，非阻塞&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;同步与异步&lt;/strong&gt;&lt;br&gt;同步是指代码调用IO操作时，必须等待IO操作完成才返回的调用方式。&lt;br&gt;异步是指代码调用IO操作时，不必等IO操作完成就返回的调用方式。&lt;/p&gt;
&lt;p&gt;同步是最原始的调用方式。&lt;br&gt;异步则需要多线程，多CPU或者非阻塞IO的支持。&lt;br&gt;&lt;strong&gt;阻塞与非阻塞&lt;/strong&gt;&lt;br&gt;阻塞是指调用线程或者进程被操作系统挂起。&lt;br&gt;非阻塞是指调用线程或者进程不会被操作系统挂起。&lt;/p&gt;
&lt;p&gt;没有IO操作，所有的代码基本都是同步的&lt;br&gt;有了IO操作后，如果没有多进程多线程，所有代码还是同步的&lt;br&gt;有了IO操作，有了多进程多线程，代码才有了异步的可能性，同时也产生了阻塞与非阻塞&lt;/p&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="I/O" scheme="https://akaqin.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第3章——文件I/O</title>
    <link href="https://akaqin.github.io/2020/04/10/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC3%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://akaqin.github.io/2020/04/10/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC3%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6I-O/</id>
    <published>2020-04-10T05:11:54.000Z</published>
    <updated>2020-04-15T02:55:38.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。</p><ul><li>0 - STDIN_FILENO - 标准输入</li><li>1 - STDOUT_FILENO - 标准输出</li><li>2 - STDERR_FILENO - 标准错误</li></ul><h2 id="不带缓冲的I-O函数"><a href="#不带缓冲的I-O函数" class="headerlink" title="不带缓冲的I/O函数"></a>不带缓冲的I/O函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/* mode_t mode */</span>)</span></span>; <span class="comment">//打开或创建一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//创建一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">//关闭一个文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>; <span class="comment">//设置偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>; <span class="comment">//读</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>; <span class="comment">//写</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="带缓冲与不带缓冲的区别"><a href="#带缓冲与不带缓冲的区别" class="headerlink" title="带缓冲与不带缓冲的区别"></a>带缓冲与不带缓冲的区别</h3><p>所谓不带缓冲，并不是指内核不提供缓冲，而是只单纯的系统调用，不是函数库的调用。系统内核对磁盘的读写都会提供一个块缓冲（在有些地方也被称为内核高速缓存），当用write函数对其写数据时，直接调用系统调用，将数据写入到块缓冲进行排队，当块缓冲达到一定的量时，才会把数据写入磁盘。因此所谓的不带缓冲的I/O是指进程不提供缓冲功能（但内核还是提供缓冲的）。每调用一次write或read函数，直接系统调用。<br>而带缓冲的I/O是指进程对输入输出流进行了改进，提供了一个流缓冲，当用fwrite函数网磁盘写数据时，先把数据写入流缓冲区中，当达到一定条件，比如流缓冲区满了，或刷新流缓冲，这时候才会把数据一次送往内核提供的块缓冲，再经块缓冲写入磁盘。（双重缓冲）<br>因此，带缓冲的I/O在往磁盘写入相同的数据量时，会比不带缓冲的I/O调用系统调用的次数要少。<br>无缓存IO操作数据流向路径：<strong>数据——内核缓存区——磁盘</strong><br>标准IO操作数据流向路径：<strong>数据——流缓存区——内核缓存区——磁盘</strong></p><h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><p>大多数文件系统为改善性能都采用某种预读（read ahead）技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。</p><h3 id="延迟写"><a href="#延迟写" class="headerlink" title="延迟写"></a>延迟写</h3><p>传统的UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被成为延迟写（delayed write）。</p><h3 id="I-O与磁盘交互流程"><a href="#I-O与磁盘交互流程" class="headerlink" title="I/O与磁盘交互流程"></a>I/O与磁盘交互流程</h3><p>当应用程序尝试读取某块数据的时候，如果这块数据已经存放在页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中（也就是上面提到的内核高速缓存），那么就需要先将数据从磁盘读到页缓存中去(这个过程触发缺页异常)。对于写操作来说，应用程序也会将数据先写到页缓存中去（这里所说的写到页缓存中，如果是调用标准库I/O进行写，那么首先是写到标准库的缓冲区内，如果标准库的缓冲区写满以后，在写到页缓冲内；如果是系统调用，那么直接写到页缓冲内），数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制,那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制，那么应用程序就完全不需要等到数据全部被 写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制不同的是，延迟写机制在数据完全写到磁盘上得时候不会通知应用程序，而异步写机制在数据完全写到磁盘上得时候是会返回给应用程序的。所以延迟写机制本省是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>内核使用4种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p><ul><li><code>进程表</code>。每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ol><li>文件描述符标志（close_on_exec）</li><li>指向一个文件表项的指针</li></ol></li><li><code>文件表</code>。内核为所以打开文件维持一张文件表（全局唯一，所有进程共享一个文件表）。其中的每个文件表项对应一个进程中打开的文件，它包含：<ol><li>文件状态标志（只读、只写、读写、追加写、同步/异步、阻塞/非阻塞等）</li><li>当前文件偏移量</li><li>指向该文件v节点表项的指针</li></ol></li><li><code>v节点</code>。每个打开文件（或设备）都有一个v节点（v-node）结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点指针。</li><li><code>i节点</code>。i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘所在位置的指针等。</li></ul><blockquote><p>Linux没有使用v节点，而是使用了通用i节点结构（一个与文件系统相关的i节点，一个与文件系统无关的i节点）。虽然实现不同，但在概念上，v节点与i节点是一样的，两者都指向文件系统特有的i节点结构。</p></blockquote><p><img src="3-7.png" alt=""><br><img src="3-8.png" alt=""></p><p>打开该文件的每个进程都能获得各自的一个文件表项，但对一个给的文件只有一个v节点表项。这样每个进程都有它自己对该文件偏移量以及打开方式。<br>可能有多个文件描述符指向同一文件表项的情况，如dup和fork函数。</p><h3 id="文件描述符标志与文件状态标志的区别"><a href="#文件描述符标志与文件状态标志的区别" class="headerlink" title="文件描述符标志与文件状态标志的区别"></a>文件描述符标志与文件状态标志的区别</h3><p><strong>前者只用于一个进程的一个描述符，后者则应用于指向该给定文件表项的任何进程中的所有描述符。</strong></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><code>原子操作（atomic operation）</code>指的是由多步组成的一个操作。如果该操作原子的执行，要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程。<br>我们用<code>pread</code>和<code>pwrite</code>函数进行I/O来保证<code>lseek</code>和<code>read</code>/<code>write</code>构成原子操作。</p><h2 id="其他I-O函数"><a href="#其他I-O函数" class="headerlink" title="其他I/O函数"></a>其他I/O函数</h2><h3 id="dup（dup2）"><a href="#dup（dup2）" class="headerlink" title="dup（dup2）"></a>dup（dup2）</h3><p>用来复制一个现有的文件描述符。复制后每个文件描述符都有它自己的一套文件描述符标志。两个描述符指向同一文件表项，所以它们共享同一文件状态标志（读、写、追加写等）<br><img src="3-9.png" alt=""></p><h3 id="sync、fsync和fdatasync"><a href="#sync、fsync和fdatasync" class="headerlink" title="sync、fsync和fdatasync"></a><code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h3><p>用于保证磁盘上实际文件系统与缓冲区中内容的一致性。</p><ul><li><code>sync</code>只是将所有修改过的块缓冲区排入写队列就返回，它不等待实际写磁盘操作结束。通常称为update的系统守护进程周期性地（一般为30秒）调用sync函数，这就保证了定期冲洗（flush）内核的块缓冲区。</li><li><code>fsync</code>只对由fd指定的一个文件起作用，并等待写磁盘操作结束才返回。</li><li><code>fdatasync</code>类似于<code>fsync</code>，但影响文件的数据部分</li></ul><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>用于改变已经打开文件的属性，主要由以下5种功能：</p><ol><li>复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC)</li><li>获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD)</li><li>获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL)</li><li>获取/设置异步I/O所有权(cmd = F_GETONW 或 F_SETOWN)</li><li>获取/设置记录锁(cmd = F_GETLK 、 F_SETLK 或 F_SETLKW（阻塞版本）)</li></ol><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><p>I/O操作的杂物箱，未总结的其他I/O操作都在里面。</p><h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供/dev/fd目录，其目录项是名为0、1、2等文件，打开文件/dev/fd/n 等效于 复制描述符n（假定描述符n是打开的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;&lt;/a&gt;文件描述符&lt;/h2&gt;&lt;p&gt;对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 - STDIN_FILENO - 标准输入&lt;/li&gt;
&lt;li&gt;1 - STDOUT_FILENO - 标准输出&lt;/li&gt;
&lt;li&gt;2 - STDERR_FILENO - 标准错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不带缓冲的I-O函数&quot;&gt;&lt;a href=&quot;#不带缓冲的I-O函数&quot; class=&quot;headerlink&quot; title=&quot;不带缓冲的I/O函数&quot;&gt;&lt;/a&gt;不带缓冲的I/O函数&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oflag, ...&lt;span class=&quot;comment&quot;&gt;/* mode_t mode */&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//打开或创建一个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openat&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oflag, ...&lt;span class=&quot;comment&quot;&gt;/* mode_t mode */&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;creat&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//创建一个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//关闭一个文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lseek&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; offset, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; whence)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//设置偏移量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; nbytes)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//读&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; nbytes)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="I/O" scheme="https://akaqin.github.io/tags/I-O/"/>
    
      <category term="文件" scheme="https://akaqin.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第13章——守护进程</title>
    <link href="https://akaqin.github.io/2020/04/09/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC13%E7%AB%A0%E2%80%94%E2%80%94%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>https://akaqin.github.io/2020/04/09/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC13%E7%AB%A0%E2%80%94%E2%80%94%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-04-09T13:39:09.000Z</published>
    <updated>2020-04-14T01:23:51.597Z</updated>
    
    <content type="html"><![CDATA[<p>守护进程（daemon）是生存期长的一种进程。它们常常在系统引导装入时启动，仅在系统关闭时才终止。守护进程没有控制终端，终端名为问号。后台运行，大多数都以超级用户（root）特权运行。用户层守护进程的父进程是init。</p><h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><ol><li>调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）。</li><li>调用fork，然后使父进程exit。</li><li>调用setsid创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。</li><li>将当前工作目录更改为根目录。避免文件系统被卸载。</li><li>关闭不再需要的文件描述符。</li><li>某些守护进程打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读/写标准输入/输出/错误的库例程都不会产生任何效果。</li></ol><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dameonize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, pid, fd0, fd1, fd2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 关闭屏蔽字</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 获取最大描述符限制</span></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) != <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"%s: can't get file limit"</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 fork，父进程退出</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"%s: can't fork"</span>, cmd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 建立新会话</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 Ensure future opens won't allocate controlling TTYs.</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"%s: can't ignore SIGHUP"</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"%s: can't fork"</span>, cmd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 Change the current working directory to the root so</span></span><br><span class="line">    <span class="comment">// we won't prevent file systems from being unmounted.</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"%s: can't change directory to /"</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all open file descriptors.</span></span><br><span class="line">    <span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">        rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++) &#123;</span><br><span class="line">        <span class="built_in">close</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach file descriptors 0, 1, and 2 to /dev/null.</span></span><br><span class="line">    fd0 = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    fd1 = dup(<span class="number">0</span>);</span><br><span class="line">    fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the log file.</span></span><br><span class="line">    openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">    <span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">"unexpected file descriptors %d %d %d"</span>, fd0, fd1, fd2);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>syslog 是一个用于集中记录所有守护进程出错记录的设施，它自身的守护进程是syslogd，该设施的接口是syslog函数。<br><img src="13-2.png" alt=""><br>有3种方法产生日志消息，syslogd守护进程读取所有3种格式的日志消息：</p><ol><li>内核例程调用log函数。</li><li>大多数用户进程（守护进程）调用syslog函数产生日志消息。这使消息被发送至UNIX域数据报套接字/dev/log。</li><li>无论用户进程在此主机上还是通过TCP/IP网络连接的其他主机上，都可将日志消息发向UDP端口514.</li></ol><h2 id="单例守护进程"><a href="#单例守护进程" class="headerlink" title="单例守护进程"></a>单例守护进程</h2><p>文件和记录锁提供了一种方便的互斥机制用于实现单例.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKFILE <span class="meta-string">"/var/run/daemon.pid"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lockfile</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">already_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>fd;</span><br><span class="line"><span class="keyword">char</span>buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">syslog(LOG_ERR, <span class="string">"can't open %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lockfile(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EACCES || errno == EAGAIN) &#123;</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">syslog(LOG_ERR, <span class="string">"can't lock %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ftruncate(fd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line"><span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><ul><li>若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。</li><li>若守护进程支持配置选项，那么配置文件通常存放在/etc目录中。</li><li>守护进程可以命令行启动，但它们通常是系由系统初始化脚本之一启动的。</li><li>若一个首进程有一个配置文件，那么当该守护进程启动时会读该文件，之后不再查看。若想reload可以使用SIGHUP信号。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;守护进程（daemon）是生存期长的一种进程。它们常常在系统引导装入时启动，仅在系统关闭时才终止。守护进程没有控制终端，终端名为问号。后台运行，大多数都以超级用户（root）特权运行。用户层守护进程的父进程是init。&lt;/p&gt;
&lt;h2 id=&quot;编程规则&quot;&gt;&lt;a href=&quot;#编程规则&quot; class=&quot;headerlink&quot; title=&quot;编程规则&quot;&gt;&lt;/a&gt;编程规则&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）。&lt;/li&gt;
&lt;li&gt;调用fork，然后使父进程exit。&lt;/li&gt;
&lt;li&gt;调用setsid创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。&lt;/li&gt;
&lt;li&gt;将当前工作目录更改为根目录。避免文件系统被卸载。&lt;/li&gt;
&lt;li&gt;关闭不再需要的文件描述符。&lt;/li&gt;
&lt;li&gt;某些守护进程打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读/写标准输入/输出/错误的库例程都不会产生任何效果。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="daemon" scheme="https://akaqin.github.io/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第12章——线程控制</title>
    <link href="https://akaqin.github.io/2020/04/07/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC12%E7%AB%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://akaqin.github.io/2020/04/07/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC12%E7%AB%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-04-07T02:53:02.000Z</published>
    <updated>2020-04-14T01:27:58.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h2><p>Single UNIX Specification定义了一些与线程操作有关的限制：</p><ul><li>线程退出时操作系统试图销毁特定数据的最大次数</li><li>进程可创建的键的最大数目</li><li>一个线程的栈可用的最小字节数</li><li>进程可创建的最大线程数</li></ul><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ul><li>属性类型为 pthread_attr_t</li><li>通过 pthread_attr_init 初始化</li><li>通过 pthread_attr_destroy 反初始化</li><li>如果对线程的终止状态不感兴趣，可以使用pthread_detach函数让操作系统在线程退出时回收它所占用的资源。</li><li>创建线程前可以通过pthread_attr_getdetachstate 和 pthread_attr_setdetachstate设置线程的分离状态</li><li>通过pthread_attr_getstack 和 pthread_attr_setstack 设置栈帧</li></ul><a id="more"></a><p><strong>对于进程来说，虚拟地址的空间大小是固定的，因为进程中只有一个栈，所以大小通常不是问题。但对于线程来说，同样大小的虚拟地址空间必须被所有线程共享。如果应用程序使用了许多线程，以致这些线程的累计大小超过了可用的虚拟地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了大量的自动变量，或者调用的函数涉及许多很深的栈帧，那么需要的栈大小可能要比默认的大</strong><br>如果线程的虚拟地址空间都用完了，可以使用malloc或者mmap来为可替代的栈分配空间，并使用pthread_attr_setstack函数来改变新建线程的栈位置。</p><!--more--><h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>用 pthread_mutex_attr 结构表示，值得注意的三个属性是：</p><ol><li><p>进程共享属性：允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为 PTHREAD_PROCESS_SHARED，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步；设置为 PTHREAD_PROCESS_PRIVATE时，允许pthread线程库提供更有效的互斥量实现，这在多线程应用程序中是默认情况。</p></li><li><p>健壮属性：与多个进程共享的互斥量有关。当持有互斥量的进程终止时，需要解决互斥量状态修复的问题。健壮属性默认值是 PTHREAD_MUTEX_STALLED，这意味着持有互斥量的进程终止时不需要采取特别的动作，而等待互斥量的应用程序会被有效的“拖住”。另一个取值是 PTHREAD_MUTEX_ROBUST，这个值将导致线程调用 pthread_mutex_lock获取锁，而该锁被另一个进程持有，但它终止时没有进行解锁，此时线程会阻塞，从pthread_mutex_lock 返回的值为 EONWERDEAD 而不是0。</p></li><li><p>类型属性：POSIX.1定义了4种类型</p><ul><li>PTHREAD_MUTEX_NORMAL 一种标准互斥量类型，不做任何特殊的错误检查或死锁检测。</li><li>PTHREAD_MUTEX_ERRORCHECK 此互斥量类型提供错误检查</li><li>PTHREAD_MUTEX_RECURSIVE 此类型允许多次加锁，递归维护锁计数，解锁次数和加锁次数不一致时，锁不会释放。</li><li>PTHREAD_MUTEX_DEFAULT 上述三种类型之一</li></ul></li></ol><h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><ul><li>进程共享属性（同上）</li></ul><h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><ul><li>进程共享属性（同上）</li><li>时钟属性：控制计算 pthread_cond_timewait 函数的超时参数（tsptr）时采用的是哪个时钟。</li></ul><h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><ul><li>进程共享属性（同上）</li></ul><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>线程在遇到重入问题时与信号处理程序是类似的。在这两种情况下，多个控制线程在相同时间有可能调用相同的函数。<br><strong>如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是<code>线程安全</code>的。</strong><br>很多函数不是线程安全的，因为它们返回的数据存放在静态的内容缓冲区中。通过修改接口，要求调用者自己提供缓冲区可以使函数变为线程安全的。<br><strong>如果一个函数对多个线程来说是可重入的，就是线程安全的，但并不能说明对信号处理程序也是可重入的。如果对信号处理程序也可重入，那就可以说函数是<code>异步信号安全</code>的。</strong></p><h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>也称线程私有数据，是存储和查询某个特定线程相关数据的一种机制。一个进程中的所有线程可以访问这个进程的整个地址空间。除了使用寄存器以外，一个线程没有办法阻止另一个线程访问它的数据。线程特定数据也不例外。但使用特定数据可以提高线程空间的数据独立性，使得线程不太容易访问到其他线程的特定数据</p><ul><li>pthread_key_create 创建与特定数据关联的key，这个键可以被进程中的所有线程使用，但每个线程把这个键与不同的线程特定数据进行关联。</li><li>线程通常使用malloc为线程特定数据分配内存。析构函数释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程出现了内存泄漏。</li><li>使用 pthread_once 可以保证某个逻辑在多线程中只执行一次，如创建特定数据的键。</li><li>使用 pthread_getspecific 与 pthread_setspecific 访问管理特定数据。</li></ul><h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程没有包含在 pthread_attr 结构中，它们是可取消状态和可取消类型。</p><ul><li>可取消状态状态属性决定了线程是否可以被取消。pthread_cancel 调用并不等待线程终止，而是继续运行，直到线程到达某个取消点（POSIX.1指定的多个函数）再去检查。如果取消了则按照请求行事。</li><li>调用 pthread_testcancel 可以主动测试线程是否被取消。</li><li>取消类型包括推迟取消（默认上述逻辑）和异步取消。使用异步取消时，线程可以在任意时间撤销，不是非得遇到取消点才被取消。</li></ul><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>线程和进程类似，也可以设置信号集来屏蔽信号。<br><strong>进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去，而其他信号则被发送到任意一个线程。</strong><br>线程中递送信号使用 pthread_kill。</p><h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>线程调用fork时，就为子进程创建了整个进程空间的副本，包括每个互斥量、读写锁和雕件变量的状态。如果父进程包含一个以上的线程，子进程在fork返回后如果不是马上调用exec的话，就需要清理锁状态。问题是子进程并不一定包含占有锁的线程的副本，所以子进程没有办法直到它占有了哪些锁，需要释放哪些锁。<br>在多线程中，为了避免不一致状态的问题，POSIX.1声明，在fork返回和子进程调用一个exec函数之间，子进程只能调用<code>异步信号安全</code>的函数。<br>要清除锁状态，可以通过调用 pthread_affork 函数建立fork处理程序，它分别在调用fork前、父子进程中fork返回后 这三个时机安装三个处理程序用于清理锁。</p><h2 id="线程和I-O"><a href="#线程和I-O" class="headerlink" title="线程和I/O"></a>线程和I/O</h2><p>因为进程中的所有线程共享相同的文件描述符，所以多线程中要使用 pread 和 pwrite 函数进行读写来保证seek和I/O是绑定的原子操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程限制&quot;&gt;&lt;a href=&quot;#线程限制&quot; class=&quot;headerlink&quot; title=&quot;线程限制&quot;&gt;&lt;/a&gt;线程限制&lt;/h2&gt;&lt;p&gt;Single UNIX Specification定义了一些与线程操作有关的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程退出时操作系统试图销毁特定数据的最大次数&lt;/li&gt;
&lt;li&gt;进程可创建的键的最大数目&lt;/li&gt;
&lt;li&gt;一个线程的栈可用的最小字节数&lt;/li&gt;
&lt;li&gt;进程可创建的最大线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程属性&quot;&gt;&lt;a href=&quot;#线程属性&quot; class=&quot;headerlink&quot; title=&quot;线程属性&quot;&gt;&lt;/a&gt;线程属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;属性类型为 pthread_attr_t&lt;/li&gt;
&lt;li&gt;通过 pthread_attr_init 初始化&lt;/li&gt;
&lt;li&gt;通过 pthread_attr_destroy 反初始化&lt;/li&gt;
&lt;li&gt;如果对线程的终止状态不感兴趣，可以使用pthread_detach函数让操作系统在线程退出时回收它所占用的资源。&lt;/li&gt;
&lt;li&gt;创建线程前可以通过pthread_attr_getdetachstate 和 pthread_attr_setdetachstate设置线程的分离状态&lt;/li&gt;
&lt;li&gt;通过pthread_attr_getstack 和 pthread_attr_setstack 设置栈帧&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="pthread" scheme="https://akaqin.github.io/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第11章——线程</title>
    <link href="https://akaqin.github.io/2020/03/25/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC11%E7%AB%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
    <id>https://akaqin.github.io/2020/03/25/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC11%E7%AB%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-25T14:19:30.000Z</published>
    <updated>2020-04-14T01:27:48.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>每个线程都包含有表示执行环境所必须的信息，包括线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>每个线程有一个线程ID，线程可以通过调用 pthread_self 函数获得自身的线程ID。<br><img src="11-1.png" alt=""></p><a id="more"></a><h2 id="线程创建-pthread-create"><a href="#线程创建-pthread-create" class="headerlink" title="线程创建 pthread_create"></a>线程创建 pthread_create</h2><p>线程创建时不保证哪个线程会先运行。新创建的线程可以访问进程的地址空间，并继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    tid = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s pid %lu tid %lu (0x%lx)\n"</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) pid, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) tid, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    printids(<span class="string">"new thread: "</span>);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(err, <span class="string">"can't create thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printids(<span class="string">"main thread:"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实例有两个特别之处，主线程与新线程之间存在竞争：</p><ol><li>主线程如果不休眠，可能新线程还没有机会执行，整个进程就终止了</li><li>新线程通过调用pthread_self获取自身的线程ID，而不是从共享内存读出或从线程的启动例程中以参数形式接收，因为那样并不安全。</li></ol><!--more--><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit、或者_exit，那么整个进程就会终止。<br>单个线程可以在不终止整个进程的情况下，以以下三种方式停止它的控制流：</p><ol><li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li><li>线程可以被同一进程中的其他线程取消。</li><li>线程调用pthread_exit。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfoo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> struct foo *fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  structure at 0x%lx\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  foo.a = %d\n"</span>, fp-&gt;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  foo.b = %d\n"</span>, fp-&gt;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  foo.c = %d\n"</span>, fp-&gt;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  foo.d = %d\n"</span>, fp-&gt;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">foo</span> = &#123;</span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    printfoo(<span class="string">"thread 1:\n"</span>, &amp;foo);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *) &amp;foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2: ID is %lu\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) pthread_self());</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        err_exit(err, <span class="string">"can't create thread 1"</span>);</span><br><span class="line">    err = pthread_join(tid1, (<span class="keyword">void</span> *) &amp;fp);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        err_exit(err, <span class="string">"can't join with thread 1"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent starting second thread\n"</span>);</span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        err_exit(err, <span class="string">"can't create thread 2"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    printfoo(<span class="string">"parent:\n"</span>, fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在macOS X上运行：</span><br><span class="line">$ ./a.out  </span><br><span class="line">thread 1:</span><br><span class="line"> structure at 0x700001aa0f90</span><br><span class="line"> foo.a = 1</span><br><span class="line"> foo.b = 2</span><br><span class="line"> foo.c = 3</span><br><span class="line"> foo.d = 4</span><br><span class="line">parent starting second thread</span><br><span class="line">thread 2: ID is 123145330233344</span><br><span class="line">parent:</span><br><span class="line"> structure at 0x700001aa0f90</span><br><span class="line">[1]    50009 segmentation fault  ./a.out</span><br></pre></td></tr></table></figure><p>可以看到，当主线程访问这个结构时,结构的内容（在线程tid1的栈上分配的）已经改变了。父进程试图访问已退出的第一个线程传给它的结构时，内存不再有效，这时得到的是SIGSEGV信号。为了解决这个问题，可以使用全局结构，或者用malloc函数分配结构。</p><p>线程可以通过pthread_cancel函数来请求取消同一进程中的其他线程。<br><img src="11-6.png" alt=""></p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当进程中存在多个线程时，每个线程使用的变量可能会被其他线程读取或修改，为解决这个问题，就必须使用锁。<br><img src="11-7.png" alt=""></p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量本质是一把锁，在访问共享资源前加锁（对互斥量进行设置），完成后解锁（释放互斥量）。涉及以下函数：</p><ul><li>pthread_mutex_init 互斥量初始化，也可以直接用 PTHREAD_MUTEX_INITIALIZER 常量静态初始化</li><li>pthread_mutex_destory 释放互斥量</li><li>pthread_mutex_lock 对互斥量加锁，如果已经上锁，则调用线程将阻塞直至互斥量被解锁</li><li>pthread_mutex_trylock 对互斥量尝试加锁，成功返回0，失败不阻塞，直接返回EBUSY</li><li>pthread_mutex_unlock 对互斥量解锁</li></ul><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a>造成死锁的原因</h4><p>如果线程对同一个互斥量加锁两次，会造成死锁；两个线程各自锁住一个互斥量，并等待对方解锁它持有的互斥量，也会造成死锁。</p><h4 id="避免死锁的方法："><a href="#避免死锁的方法：" class="headerlink" title="避免死锁的方法："></a>避免死锁的方法：</h4><ol><li>可以通过仔细控制互斥量加锁的顺序来避免死锁发生（按相同的顺序加锁）</li><li>使用tpthread_mutex_trylock尝试加锁，如果失败则先释放已有的锁，做好清理工作，过段时间再试<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(id) (((unsigned long) id) % NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">fh</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f_count; /\* <span class="keyword">protected</span> by hashlock \*/</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> f_lock;</span><br><span class="line">    <span class="keyword">int</span> f_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">f_next</span>;</span> /\* <span class="keyword">protected</span> by hashlock \*/</span><br><span class="line">    /\* ... more stuff here ... \*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \* <span class="title">foo_alloc</span>(<span class="title">int</span> <span class="title">id</span>) /\* <span class="title">allocate</span> <span class="title">the</span> <span class="title">object</span> \*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">fp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        idx = HASH(id);</span><br><span class="line">        pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">        fp-&gt;f_next = fh[idx];</span><br><span class="line">        fh[idx] = fp;</span><br><span class="line">        pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">        pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">        /\* ... <span class="keyword">continue</span> initialization ... \*/</span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo_hold(struct foo \*fp) /\* add a reference to the object \*/</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \* <span class="title">foo_find</span>(<span class="title">int</span> <span class="title">id</span>) /\* <span class="title">find</span> <span class="title">an</span> <span class="title">existing</span> <span class="title">object</span> \*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">    <span class="keyword">for</span> (fp = fh[HASH(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_id == id) &#123;</span><br><span class="line">            fp-&gt;f_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo_rele(struct foo \*fp) /\* release a reference to the object \*/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> \*<span class="title">tfp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">    <span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>) &#123; /\* last reference, <span class="built_in">remove</span> from <span class="built_in">list</span> \*/</span><br><span class="line">        idx = HASH(fp-&gt;f_id);</span><br><span class="line">        tfp = fh[idx];</span><br><span class="line">        <span class="keyword">if</span> (tfp == fp) &#123;</span><br><span class="line">            fh[idx] = fp-&gt;f_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">                tfp = tfp-&gt;f_next;</span><br><span class="line">            tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">        pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>多线程的软件设计要注意锁的粒度：如果锁的粒度太粗，就会出现多线程阻塞等待相同的锁，这可能并不能改善并发性；如果锁的粒度太细，那么过多的锁开销会使系统性能受影响，而且代码变得复杂。作为一个程序员，需要在满足锁需求的情况下，在代码复杂性和性能之间找到正确的平衡。</strong></p><h4 id="带有超时的互斥量"><a href="#带有超时的互斥量" class="headerlink" title="带有超时的互斥量"></a>带有超时的互斥量</h4><p>函数 pthread_mutex_timedlock，加锁时设置一个愿意等待的绝对时间，超时后放弃加锁，返回错误码ETIMEDOUT。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量类似，但允许更高的并行性。非常适合于对数据结构读的次数远大于写的情况。</p><ul><li>pthread_rwlock_init 初始化</li><li>pthread_rwlock_destory 销毁</li><li>pthread_rwlock_rdlock 加读锁</li><li>pthread_rwlock_wrlock 加写锁</li><li>pthread_rwlock_unlock 解锁</li><li>pthread_rwlock_tryrdlock 尝试加读锁</li><li>pthread_rwlock_trywrlock 尝试加写锁</li></ul><p>下面的例子通过读写锁实现了一个多线程的作业请求队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_init</span><span class="params">(struct <span class="built_in">queue</span> \*qp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    qp-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    qp-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_rwlock_init(&amp;qp-&gt;lock, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_insert</span><span class="params">(struct <span class="built_in">queue</span> \*qp, struct job \*jp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;lock);</span><br><span class="line">    jp-&gt;next = qp-&gt;head;</span><br><span class="line">    jp-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qp-&gt;tail = jp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        qp-&gt;head-&gt;prev = jp;</span><br><span class="line">    &#125;</span><br><span class="line">    qp-&gt;head = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_append</span><span class="params">(struct <span class="built_in">queue</span> \*qp, struct job \*jp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;lock);</span><br><span class="line">    jp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    jp-&gt;prev = qp-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qp-&gt;head = jp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        qp-&gt;tail-&gt;next = jp;</span><br><span class="line">    &#125;</span><br><span class="line">    qp-&gt;tail = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_remove</span><span class="params">(struct <span class="built_in">queue</span> \*qp, struct job \*jp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (jp == qp-&gt;head) &#123;</span><br><span class="line">        qp-&gt;head = jp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (qp-&gt;tail == jp) &#123;</span><br><span class="line">            qp-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jp-&gt;next-&gt;prev = jp-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp-&gt;tail) &#123;</span><br><span class="line">        qp-&gt;tail = jp-&gt;prev;</span><br><span class="line">        jp-&gt;prev-&gt;next = jp-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jp-&gt;prev-&gt;next = jp-&gt;next;</span><br><span class="line">        jp-&gt;next-&gt;prev = jp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">job_find</span>(<span class="title">struct</span> <span class="title">queue</span> \*<span class="title">qp</span>, <span class="title">pthread_t</span> <span class="title">id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> \*<span class="title">jp</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;qp-&gt;lock) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (jp = qp-&gt;head; jp != <span class="literal">NULL</span>; jp = jp-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(jp-&gt;id, id)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> jp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h4><p>函数 pthread_rwlock_timedrdlock 和 pthread_rwlock_timedwdlock 提供带有超时的加锁功能，避免在获取锁时永久阻塞。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量(cond)是在多线程程序中用来实现”等待–》唤醒”逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。</p><h4 id="那为什么有互斥锁，还需要条件变量？"><a href="#那为什么有互斥锁，还需要条件变量？" class="headerlink" title="那为什么有互斥锁，还需要条件变量？"></a>那为什么有互斥锁，还需要条件变量？</h4><p>因为：互斥锁和条件变量所解决的，是不同的问题，不同的场景。</p><p>互斥锁解决的是在 shared memory space 模型下，多个线程对同一个全局变量的访问的竞争问题(惊群效应)。由于一些常用写操作的非原子性（从内存中读进寄存器，修改，如果其他线程完成了对这个变量的修改，则旧的修改就被覆盖，等等问题），必须保证同一时间只有一个线程在进行写操作。这就涉及到了互斥锁，将临界区的操作锁起来，保证只有一个线程在进行操作。多个线程在等待同一把锁的时候，按照 FIFO 组织队列，当锁被释放时，队头线程获得锁（由操作系统管理，具体不表）。没有获得锁的线程继续被 block，换言之，它们是因为没有获得锁而被 block。</p><p>假如我们没有“条件变量”这个概念，如果一个线程要等待某个“自定义的条件”满足而继续执行，而这个条件只能由另一个线程来满足，比如 T1不断给一个全局变量 x +1， T2检测到x 大于100时，将x 置0，如果我们没有条件变量，则只通过互斥锁则可以有如下实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Assume we have global variables:</span><br><span class="line"> * int iCount &#x3D;&#x3D; 0;</span><br><span class="line"> * pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;thread 1:</span><br><span class="line"></span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    iCount++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;thread 2:</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    if(iCount &gt;&#x3D; 100)</span><br><span class="line">    &#123;</span><br><span class="line">        iCount &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现下，就算 lock 空闲，thread2需要不断重复&lt;加锁，判断，解锁&gt;这个流程，会给系统带来不必要的开销。有没有一种办法让 thread2先被 block，等条件满足的时候再唤醒 thread2？这样 thread2 就不用不断进行重复的加解锁操作了？这就要用到条件变量了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;thread1 :</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    iCount++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    if(iCount &gt;&#x3D; 100)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;thread2:</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while(iCount &lt; 100)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;iCount &gt;&#x3D; 100\r\n&quot;);</span><br><span class="line">    iCount &#x3D; 0;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，条件变量需要配合互斥锁来使用：<br>为什么要与pthread_mutex 一起使用呢？ 这是为了应对 线程1在调用pthread_cond_wait()但线程1还没有进入wait cond的状态的时候，此时线程2调用了 cond_singal 的情况。 如果不用mutex锁的话，这个cond_singal就丢失了。加了锁的情况是，线程2必须等到 mutex 被释放（也就是 pthread_cod_wait() 释放锁并进入wait_cond状态 ，此时线程2上锁） 的时候才能调用cond_singal.</p><p>简而言之就是，在thread 2 call pthread_cond_wait() 的时刻到 thread 2真正进入 wait 状态时，是存在着时间差的。如果在这段时间差内 thread1 调用了 pthread_cond_signal() 那这个 signal 信号就丢失了。给 wait 加锁可以防止同时有另一个线程在 signal。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁适用与以下情况：锁被持有的时间短，而且线程并不希望在重新调度上话费太多成本。当线程自旋等待锁变为可用时，CPU不能做其他事情，这是它只能被持有一小段时间的原因，超过时间分片后会被CPU强行切换。</p><p>自旋锁在非抢占式内核中非常有用，但在用户层，自旋锁不是非常有用，除非运行在不允许抢占的实时调度类中。<br>pthread_spin_init函数对自旋锁初始化，pthread_spin_destory 函数对自旋锁进行反初始化。<br>pthread_spin_lock 和 pthread_spin_trylock 进行加锁，pthread_spin_unlock 进行解锁。</p><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障是用户协调多个线程并行工作的同步机制。它允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有的线程到达屏障后可以接着工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h2&gt;&lt;p&gt;每个线程都包含有表示执行环境所必须的信息，包括线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。&lt;/p&gt;
&lt;h2 id=&quot;线程标识&quot;&gt;&lt;a href=&quot;#线程标识&quot; class=&quot;headerlink&quot; title=&quot;线程标识&quot;&gt;&lt;/a&gt;线程标识&lt;/h2&gt;&lt;p&gt;每个线程有一个线程ID，线程可以通过调用 pthread_self 函数获得自身的线程ID。&lt;br&gt;&lt;img src=&quot;11-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="pthread" scheme="https://akaqin.github.io/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第10章——信号</title>
    <link href="https://akaqin.github.io/2020/03/13/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7/"/>
    <id>https://akaqin.github.io/2020/03/13/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7/</id>
    <published>2020-03-13T12:35:08.000Z</published>
    <updated>2020-04-14T01:25:51.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>信号是软件中断。它提供了一种处理异步事件的方法。每个信号都有一个名字，以SIG开头。在头文件&lt;signal.h&gt;中，信号名都被定义为正整数常量（信号编号）。<br>不存在编号为0的信号。kill函数对信号编号0有特殊的作用。POSIX.1将此中信号编号值称为空信号。<br>信号出现时，内核按下列三种方式之一进行处理：</p><ul><li>忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号决不能被忽略，它们是SIGKILL和SIGSTOP。原因是它们想内核提供了使进程终止或停止的可靠方法。</li><li>捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个可执行用户希望对这种事件进行的处理的用户函数。</li><li>执行系统默认动作。对大多数信号的系统默认动作是终止该进程。<br><img src="10-1.png" alt=""></li></ul><a id="more"></a><h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void (*signal(int signo, void (*func)(int)))(int);</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, Sigfunc *)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGUSR1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err_dump(<span class="string">"received signal %d\n"</span>, signo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：在UNIX系统中，杀死（kill）这个术语是不恰当的。kill（1）命令和kill（2）函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号</strong></p><h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。<br>当进程执行一个新程序后，信号捕捉函数的地址很可能在所执行的新程序文件中已无意义。</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。</p><h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果信号处理程序返回（例如没有调用exit或longjmp），则继续执行在捕捉到信号时进程正在执行的正常指令序列。</p><p>Single UNIX Specifiation 说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是异步信号安全的。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。</p><h2 id="可靠信号术语和语义"><a href="#可靠信号术语和语义" class="headerlink" title="可靠信号术语和语义"></a>可靠信号术语和语义</h2><p>首先，当造成信号事件的发生时，为进程<code>产生</code>一个信号（或向一个进程发送一个信号）。事件可以是硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用kill函数。当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。</p><p>当对信号采取了这种动作时，我们说向进程<code>递送</code>了一个信号。在信号<code>产生（generation）</code>和<code>递送（delivery）</code>之间的时间间隔内，称信号是<code>未决的（pending）</code>。</p><p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不是在产生该信号时），才决定对它的处理方式。</p><p>POSIX.1允许系统递送该信号一次或多次。如果多次则排队。但除非支持POSIX.1实时扩展，否则大多数UNIX并不排队，而是只递送这种信号一次。</p><p>每个进程都一个信号屏蔽字（singal mask），它规定了当前要阻塞递送该进程的信号集。</p><h2 id="函数kill-和-raise"><a href="#函数kill-和-raise" class="headerlink" title="函数kill 和 raise"></a>函数kill 和 raise</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure><p>kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。</p><h2 id="函数alarm-和-pause"><a href="#函数alarm-和-pause" class="headerlink" title="函数alarm 和 pause"></a>函数alarm 和 pause</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    /\* nothing to <span class="keyword">do</span>, just <span class="keyword">return</span> to wake up the pause \*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sleep1(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册信号处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置闹钟</span></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    <span class="comment">//暂停</span></span><br><span class="line">    pause();</span><br><span class="line">    <span class="comment">//关掉闹钟</span></span><br><span class="line">    <span class="keyword">return</span> alarm(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep1存在3个问题：</p><ol><li>如果调用alarm前设置了闹钟，则它被sleep1函数中的第一次alarm调用擦除。更正方法：检查第一次调用的返回值，如果小于本次调用的参数值，则只应等待超时例如过大于本次参数，则在sleep1函数返回前，重置此闹钟，使其再次发生超时。</li><li>该程序修改了对SIGALRM的配置。如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正方法：保存signal函数的返回值，在返回前重置原配置。</li><li>在第一次调用alarm和pause之间有一个竞争条件。在一个繁忙的系统中，可能alarm在调用pause之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用pause后，如果没有捕捉到其他信号，调用者将永远被挂起。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">        alarm(seconds);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alarm(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep2通过longjmp的方式解决了sleep1中的竞争条件问题，但带来了另外一个问题：它涉及与其他信号的交互。如果SIGALRM中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"signal(SIGINT) error"</span>);</span><br><span class="line">    unslept = sleep2(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sleep2 returned: %u\n"</span>, unslept);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Tune these loops to <span class="built_in">run</span> <span class="keyword">for</span> more than <span class="number">5</span> seconds</span><br><span class="line">     \* on whatever system <span class="keyword">this</span> test program is <span class="built_in">run</span>.</span><br><span class="line">     \*/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nsig_int starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">300000</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4000</span>; j++)</span><br><span class="line">            k += i * j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig_int finished\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">^C</span><br><span class="line">sig_int starting</span><br><span class="line">sig_int finished</span><br><span class="line">sleep2 returned: 2</span><br></pre></td></tr></table></figure><p>从中可见sleep2函数所引起的longjmp使另一个信号处理程序sig_int提早终止，即使它未完成也会如此。</p><p><em>sleep1 和 sleep2 函数的这两个实例告诉我们在涉及信号时需要有精细而周到的考虑。</em></p><p>除了用来实现sleep函数外，alarm还常用语对可能阻塞的操作设置时间上线值。例如，程序中有一个读低速设备的可能阻塞的操作，我们希望超过一定时间量后就停止执行该操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, <span class="built_in">line</span>, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="built_in">line</span>, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    /\* nothing to <span class="keyword">do</span>, just <span class="keyword">return</span> to interrupt the <span class="built_in">read</span> \*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种程序有两个问题：</p><ol><li>第一次调用alarm与read之间存在竞争条件。大多数解决方案是把闹钟的时长设置久一点。</li><li>如果系统调用是自动重启的，则当alarm信号处理程序返回时，read并不被中断。这种情况下，设置时间限制不起作用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env_alrm) != <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"read timeout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, <span class="built_in">line</span>, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="built_in">line</span>, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的程序不管系统是否重新启动被中断的系统调用都能正常工作，但仍旧存在与其他信号处理程序交互的问题。</p><h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>一个能表示多个信号的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(sigset *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(sigset *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(sigset_st *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="函数-sigprocmask"><a href="#函数-sigprocmask" class="headerlink" title="函数 sigprocmask"></a>函数 sigprocmask</h3><p>一个进程信号屏蔽字规定了当前阻塞而不能递送该进程的信号集。调用函数 sigprocmask 可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。</p><h3 id="函数-sigpending"><a href="#函数-sigpending" class="headerlink" title="函数 sigpending"></a>函数 sigpending</h3><p>sigpending返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> newmask, oldmask, pendmask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, sig_quit) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"can't catch SIGQUIT"</span>);</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Block SIGQUIT <span class="keyword">and</span> save current signal mask.</span><br><span class="line">     \*/</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);    /\* SIGQUIT here will remain pending \*/</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigpending(&amp;pendmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"sigpending error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigismember(&amp;pendmask, SIGQUIT))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nSIGQUIT pending\n"</span>);</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Restore signal mask which unblocks SIGQUIT.</span><br><span class="line">     \*/</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGQUIT unblocked\n"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);    /\* SIGQUIT here will <span class="built_in">terminate</span> with core file \*/</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"caught SIGQUIT\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"can't reset SIGQUIT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数-sigaction"><a href="#函数-sigaction" class="headerlink" title="函数 sigaction"></a>函数 sigaction</h3><p>它的功能是检查或（并）修改与指定信号相关联的处理动作。它取代了UNIX早期版本的signal函数。</p><h3 id="函数-sigsetjmp-与-siglongjmp"><a href="#函数-sigsetjmp-与-siglongjmp" class="headerlink" title="函数 sigsetjmp 与 siglongjmp"></a>函数 sigsetjmp 与 siglongjmp</h3><p>它们比setjmp与longjmp多了一个参数，用来保存当前信号的屏蔽字，用于在调用siglongjmp时恢复。</p><h3 id="函数-sigsuspend"><a href="#函数-sigsuspend" class="headerlink" title="函数 sigsuspend"></a>函数 sigsuspend</h3><p>它在一个原子操作中先恢复信号屏蔽字，再使进程休眠。解决了信号丢失的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">pause();</span><br><span class="line"><span class="comment">//当信号放生在sigprocmask与pause之间时，信号就丢失了，进程将永远阻塞</span></span><br></pre></td></tr></table></figure><p>另一种应用是等待一个信号处理程序设置一个全局变量，以此实现父、子进程之间的同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> sigflag; <span class="comment">/* set nonzero by sig handler * /</span></span><br><span class="line"><span class="comment">static sigset_t newmask, oldmask, zeromask;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void sig_usr(int signo)    /* one signal handler for SIGUSR1 and SIGUSR2 * /</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    sigflag = 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void TELL_WAIT(void) &#123;</span></span><br><span class="line"><span class="comment">    if (signal(SIGUSR1, sig_usr) == SIG_ERR)</span></span><br><span class="line"><span class="comment">        err_sys("signal(SIGUSR1) error");</span></span><br><span class="line"><span class="comment">    if (signal(SIGUSR2, sig_usr) == SIG_ERR)</span></span><br><span class="line"><span class="comment">        err_sys("signal(SIGUSR2) error");</span></span><br><span class="line"><span class="comment">    sigemptyset(&amp;zeromask);</span></span><br><span class="line"><span class="comment">    sigemptyset(&amp;newmask);</span></span><br><span class="line"><span class="comment">    sigaddset(&amp;newmask, SIGUSR1);</span></span><br><span class="line"><span class="comment">    sigaddset(&amp;newmask, SIGUSR2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TELL_PARENT</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    kill(pid, SIGUSR2);        <span class="comment">/* tell parent we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAIT_PARENT</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;zeromask);    <span class="comment">/* and wait for parent */</span></span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TELL_CHILD</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    kill(pid, SIGUSR1);            <span class="comment">/* tell child we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAIT_CHILD</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;zeromask);    <span class="comment">/* and wait for child */</span></span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果等待信号发生时希望去休眠，则使用sigsuspend函数非常合适，但如果在等待信号期间希望调用其他系统函数，在单线程环境下没有妥善的解决办法。如果不使用线程，我们能尽力做到最好的是：当信号发生时，在信号捕捉程序中对一个全局变量置1。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h2&gt;&lt;p&gt;信号是软件中断。它提供了一种处理异步事件的方法。每个信号都有一个名字，以SIG开头。在头文件&amp;lt;signal.h&amp;gt;中，信号名都被定义为正整数常量（信号编号）。&lt;br&gt;不存在编号为0的信号。kill函数对信号编号0有特殊的作用。POSIX.1将此中信号编号值称为空信号。&lt;br&gt;信号出现时，内核按下列三种方式之一进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号决不能被忽略，它们是SIGKILL和SIGSTOP。原因是它们想内核提供了使进程终止或停止的可靠方法。&lt;/li&gt;
&lt;li&gt;捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个可执行用户希望对这种事件进行的处理的用户函数。&lt;/li&gt;
&lt;li&gt;执行系统默认动作。对大多数信号的系统默认动作是终止该进程。&lt;br&gt;&lt;img src=&quot;10-1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="signal" scheme="https://akaqin.github.io/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第9章——进程关系</title>
    <link href="https://akaqin.github.io/2020/03/08/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"/>
    <id>https://akaqin.github.io/2020/03/08/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</id>
    <published>2020-03-08T07:53:47.000Z</published>
    <updated>2020-04-16T06:29:37.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关，可以是基于字符的终端、仿真基于字符终端的图形终端，或者运行窗口系统的图形终端。</p><h3 id="BSD终端登录"><a href="#BSD终端登录" class="headerlink" title="BSD终端登录"></a>BSD终端登录</h3><p>系统管理者创建通常名为/etc/ttys的文件，其中每个终端设备都有一行，说明设备名和传到getty程序的参数。当系统自举时，内核创建进程ID为1的进程，也就是init进程。<br>init进程使系统进入多用户模式。init读取文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则exec getty程序。<br><img src="9-1.png" alt=""></p><a id="more"></a><p>getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。<br>一旦设备被打开，则文件描述符0、1、2就被设置到该设备，然后getty输出“login：”之类的信息，等待用户键入用户名。<br><img src="9-2.png" alt=""></p><p>因为init进程具有超级用户特权，所以图9-2中的所有进程都有超级用户特权。图9-2中的下面三个进程ID相同，exec不会改变进程ID，父进程ID都为1。</p><p>如果用户正确登录，login将完成下列工作：</p><ul><li>将当前工作目录改为该用户的起始目录（chdir）。</li><li>调用chown更改该终端的所有权，使登录用户成为它的所有者。</li><li>将对该终端设备的访问权限改变成“用户读和写”。</li><li>调用 setgid 及 initgroups 设置进程的组ID。</li><li>用 login 得到的所有信息初始化环境：起始目录（HOME）、shell（SHELL）、用户名（USER和LOGNAME）以及一个系统默认路径（PATH）。</li><li>login 进程更改为登录用户的用户ID（setuid）并调用该用户登录的shell，其方式类似于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"-sh"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li>其他任务（打印日期消息文件、检查新邮件等）</li></ul><p>至此，登录用户的登录shell开始运行。其父进程ID是init进程，所以此登录shell终止时，init会等到通知（接到SIGCHLD信号），它会对该终端重复全部上述过程。登录shell的文件描述符0、1和2设置为终端设备。<br>   <img src="9-3.png" alt=""></p><h3 id="Mac-OS-X-终端登录"><a href="#Mac-OS-X-终端登录" class="headerlink" title="Mac OS X 终端登录"></a>Mac OS X 终端登录</h3><p>Mac OS X部分地基于FreeBSD，所以其终端登录进程与BSD基本一致，不同之处在于：</p><ul><li>init的工作是由launchd完成的。</li><li>一开始提供的就是图形终端</li></ul><h3 id="Linux-终端登录"><a href="#Linux-终端登录" class="headerlink" title="Linux 终端登录"></a>Linux 终端登录</h3><p>Linux的终端登录过程非常类似于BSD。Linux login命令是从4.3BSD login命令派生出来的。登录过程的主要区别在于说明终端配置的方式。</p><h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和由网络登录至系统两者之间的主要（物理上的）区别是：网络登录时，在终端和计算机之间的连接不再是点到点的。在网络登录情况下，login仅仅是一种可用的服务，这与其他网络服务（如FTP、SMTP）的性质相同。<br>所有登录都经由内核的网络接口驱动程序（如以太网驱动程序），而且事先并不知道会有多少这样的登录。因此必须等待一个网络请求的到达，而不是使一个进程等待每一个可能的登录。</p><h3 id="BSD网络登录"><a href="#BSD网络登录" class="headerlink" title="BSD网络登录"></a>BSD网络登录</h3><p>在BSD中，有一个inetd进程，它等待大多数网络连接。作为系统启动的一部分，init调用一个shell，使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后生成的子进程exec适当的程序。</p><p><img src="9-4.png" alt=""></p><p><img src="9-5.png" alt=""></p><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID之外，还属于一个进程组。<br>进程组是一个或多个进程的集合。通常，它们是同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID——它是一个正整数，并可存放在pid_t数据类型中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//获取调用进程的组ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; <span class="comment">//获取指定pid的进程组ID</span></span><br></pre></td></tr></table></figure><p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。<br>进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命周期。某个进程组的最后一个进程可以终止，也可以转移到另一个进程组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>; <span class="comment">// 设置pid为pgid组的组长</span></span><br></pre></td></tr></table></figure><p>一个进程只能为它自己或紫的子进程设置进程组ID。在它的子进程调用了exec后，它就不能再更改该子进程的组ID了。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话（session）是一个或多个进程组的集合。<br><img src="9-6.png" alt=""><br>进程调用<code>setsid</code>函数建立一个新会话。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体发生以下3件事：</p><ol><li>该进程变成新会话的 <strong>会话首进程（session leader）</strong>。此时，该进程是新会话中的唯一进程。</li><li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li><li>该进程没有控制终端。如果调用setsid之前由，那么这种联系也被切断。</li></ol><h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性：</p><ul><li>一个会话可以有一个 <strong>控制终端（controlling terminal）</strong>。这通常是终端设备（在终端登录情况下）或伪终端设备（在网络登录情况下）。</li><li>建立与控制终端连接的 <strong>会话首进程</strong> 被称为 <strong>控制进程（controlling process）</strong>。</li><li>一个会话中的几个进程组可被分成一个 <strong>前台进程组（foreground process group）</strong> 以及一个或多个 <strong>后台进程组（background process group）</strong>。</li><li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li><li>无论何时键入终端的中断键（通常是Delete或Ctrl+C），都会将中断信号发送至前台进程组的所有进程。</li><li>无论何时键入终端的退出键（通常是Ctrl+\）,都会将退出信号发送至前台进程组的所有进程。</li><li>如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（会话首进程）。<br><img src="9-7.png" alt=""></li></ul><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">//返回前台进程组ID，它与fd上打开的终端相关联</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>; <span class="comment">//将前台进程组ID设置为 pgrpid</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetsid</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">//获得会话首进程的进程组ID（等价于会话ID）</span></span><br></pre></td></tr></table></figure><h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合。<br>作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行。</p><p>有3个特殊字符会使终端程序产生信号，发送给前台进程组。它们是：</p><ul><li>中断字符（一般采用Delete或Ctrl+C）产生SIGINT</li><li>退出字符（一般采用Ctrl+\）产生SIGQUIT</li><li>挂起字符（一般采用Ctrl+Z）产生SIGSTP</li></ul><p>只有前台作业可以接收终端输入或向终端输出。<br>如果后台作业尝试读终端，终端驱动程序会向后台作业发送信号SIGTTIN，该信号通常会停止后台。然后通知用户。<br>后台作业能否输出到控制终端与配置有关。<br><img src="9-9.png" alt=""></p><h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><p><img src="9.9.1.png" alt=""><br><strong>在不支持作业控制的shell中，管道中的最后一个进程是shell的子进程，管道中的其他进程是最后一个进程的子进程。从中可以看出，shell fork一个它自身的副本，然后此副本再为管道中的每条命令各fork一个进程。</strong><br><img src="9-10.png" alt=""><br>有作业控制时，后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号SIGTTIN。<br><img src="9.9.2.png" alt=""><br><img src="9.9.3.png" alt=""></p><h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。另一种描述可以是：一个进程组不是孤儿进程组的条件是——该组中有一个进程，其父进程属于同一会话的另一个组中。如果进程组不是孤儿进程组，那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。<br><img src="9-11.png" alt=""><br>因为在父进程终止后，进程组包含一个停止的进程，进程组称为孤儿进程组，POSIX。1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号（SIGHUP），接着又向其发送继续信号（SIGCONT）。<br>在处理了挂断信号后，子进程继续。对挂断信号的系统默认动作是终止该进程。</p><h2 id="FreeBSD实现"><a href="#FreeBSD实现" class="headerlink" title="FreeBSD实现"></a>FreeBSD实现</h2><p><img src="9-13.png" alt=""><br>每个会话都分配一个session结构。在调用setsid时，在内核分配一个心得session结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;终端登录&quot;&gt;&lt;a href=&quot;#终端登录&quot; class=&quot;headerlink&quot; title=&quot;终端登录&quot;&gt;&lt;/a&gt;终端登录&lt;/h2&gt;&lt;p&gt;我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关，可以是基于字符的终端、仿真基于字符终端的图形终端，或者运行窗口系统的图形终端。&lt;/p&gt;
&lt;h3 id=&quot;BSD终端登录&quot;&gt;&lt;a href=&quot;#BSD终端登录&quot; class=&quot;headerlink&quot; title=&quot;BSD终端登录&quot;&gt;&lt;/a&gt;BSD终端登录&lt;/h3&gt;&lt;p&gt;系统管理者创建通常名为/etc/ttys的文件，其中每个终端设备都有一行，说明设备名和传到getty程序的参数。当系统自举时，内核创建进程ID为1的进程，也就是init进程。&lt;br&gt;init进程使系统进入多用户模式。init读取文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则exec getty程序。&lt;br&gt;&lt;img src=&quot;9-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="process" scheme="https://akaqin.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>vnode与inode区别</title>
    <link href="https://akaqin.github.io/2020/03/08/vnode%E4%B8%8Einode%E5%8C%BA%E5%88%AB/"/>
    <id>https://akaqin.github.io/2020/03/08/vnode%E4%B8%8Einode%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-08T05:30:41.000Z</published>
    <updated>2020-03-08T07:46:35.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vnode与inode的区别"><a href="#vnode与inode的区别" class="headerlink" title="vnode与inode的区别"></a>vnode与inode的区别</h1><blockquote><p>文章整理自  <a href="https://www.freebsd.org/cgi/man.cgi?query=vnode" target="_blank" rel="noopener">FreeBSD docs</a> 和  <a href="https://stackoverflow.com/questions/27345342/inode-vs-vnode-difference" target="_blank" rel="noopener">StackOverflow</a></p></blockquote><h2 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h2><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>vnode —— 文件或目录的内部表示</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/vnode.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li>vnode是UNIX中所有文件活动的焦点。</li><li>vnode节点由<code>struct vnode</code>声明。</li><li>每个活动文件、当前目录、挂载文件、文本文件和根目录都分配了一个vnode节点。</li><li>vnode最初是为FreeBSD创建的，因为需要使用的不同类型的文件系统（例如UFS、NFS等）激增。</li><li>Vnode旨在为所有可能的文件系统提供抽象，以便OS可以与它们进行对接，从而让内核方法不必兼容每个特定的文件系统；内核只需要知道如何与Vnode进行交互。</li><li>Vnode抽象在内存中，可以与UFS、ext4等文件系统进行交互；而inode存储在磁盘上，只能用于特定的文件系统。</li><li>inode节点包含文件大小、拥有者、指向地址块的指针等元数据。</li><li>vnode仅包含在文件生命周期中不会改变的一些属性，因此如果想获得更多信息请使用inode作为参考。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vnode与inode的区别&quot;&gt;&lt;a href=&quot;#vnode与inode的区别&quot; class=&quot;headerlink&quot; title=&quot;vnode与inode的区别&quot;&gt;&lt;/a&gt;vnode与inode的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文章整理自  &lt;a
      
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="File System" scheme="https://akaqin.github.io/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>strlen与sizeof区别</title>
    <link href="https://akaqin.github.io/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/"/>
    <id>https://akaqin.github.io/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-02T13:18:44.000Z</published>
    <updated>2020-03-08T07:41:04.398Z</updated>
    
    <content type="html"><![CDATA[<ul><li>strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度</li><li>strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度&lt;/li&gt;
&lt;li&gt;strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第8章——进程控制</title>
    <link href="https://akaqin.github.io/2020/03/02/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://akaqin.github.io/2020/03/02/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-03-02T13:01:18.000Z</published>
    <updated>2020-04-16T02:19:27.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。</p><p>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。</p><p>进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init读取与系统有关的初始化文件，并将系统引导到一个状态。init进程不会终止，它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），以超级用户特权运行。</p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li>调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1</li><li>子进程和父进程继续执行fork之后的指令；<strong>子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段</strong></li><li>fork时用到<code>写时复制（Copy-On-Write）</code>技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”</li><li>fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法</li><li>文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。<br><img src="8-2.png" alt=""></li></ul><a id="more"></a><h3 id="子进程从父进程继承"><a href="#子进程从父进程继承" class="headerlink" title="子进程从父进程继承"></a>子进程从父进程继承</h3><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>信号屏蔽和安排</li><li>对任一打开间描述符的执行时关闭（close-on-exec）标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li>资源限制</li></ul><h3 id="父进程与子进程的区别"><a href="#父进程与子进程的区别" class="headerlink" title="父进程与子进程的区别"></a>父进程与子进程的区别</h3><ul><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空集</li></ul><h3 id="fork失败的两个主要原因："><a href="#fork失败的两个主要原因：" class="headerlink" title="fork失败的两个主要原因："></a>fork失败的两个主要原因：</h3><ul><li>系统中已经有了太多的进程</li><li>该用户ID的进程总数超过了系统的限制</li></ul><h2 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h2><ul><li>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。</li><li>vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。</li><li>vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中任意一个时，父进程会恢复运行。</li></ul><h2 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h2><p>进程的5种正常终止方式：</p><ul><li>在main函数内执行return语句。等效于调用exit</li><li>调用exit函数。由ISO C定义，其操作包括调用各终止处理程序，关闭所有标准I/O流等</li><li>调用_exit或_Exit函数。ISO C定义_Exit，目的是提供一种无需运行终止处理程序和信号处理程序的方法。对标准I/O流是否进行冲洗，这取决于实现。</li><li>进程的最后一个线程在启动例程中执行return语句。</li><li>进程的最后一个线程调用pthread_exit函数。</li></ul><p>进程的3种异常终止方式：</p><ul><li>调用abort，它产生SIGABRT信号</li><li>当进程接收到某种信号时</li><li>最后一个线程对“取消”请求做出响应。</li></ul><p>不管进程如何终止，最后内核都会为相应进程关闭所有打开描述符，释放它所使用的存储器等。所以大多数exit的现代实现不再关闭流</p><h3 id="终止进程如何通知父进程它是如何终止的？"><a href="#终止进程如何通知父进程它是如何终止的？" class="headerlink" title="终止进程如何通知父进程它是如何终止的？"></a>终止进程如何通知父进程它是如何终止的？</h3><p>对于三个终止函数（exit、_exit和_Exit），将其<code>退出状态</code>作为参数传递给函数。对于异常终止情况，内核（不是进程本身）产生一个指示其终止原因的<code>终止状态</code>。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态。</p><h3 id="父进程在子进程之前终止会怎样？"><a href="#父进程在子进程之前终止会怎样？" class="headerlink" title="父进程在子进程之前终止会怎样？"></a>父进程在子进程之前终止会怎样？</h3><p>对于父进程已经终止的所有进程，它们的父进程都改变为init进程（称为由init进程收养）。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，如果是正要终止进程的子进程，则将该进程的父进程ID改为1。</p><h3 id="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"><a href="#如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？" class="headerlink" title="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"></a>如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？</h3><p>如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。包括进程ID、终止状态和CPU时间总量。</p><h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵尸进程。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵尸进程。</p><h3 id="一个由init进程收养的进程终止后会不会变成僵尸进程？"><a href="#一个由init进程收养的进程终止后会不会变成僵尸进程？" class="headerlink" title="一个由init进程收养的进程终止后会不会变成僵尸进程？"></a>一个由init进程收养的进程终止后会不会变成僵尸进程？</h3><p>不会的。因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。</p><h2 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li>成功返回进程id，出错返回0或-1</li><li>statloc是一个整型指针，保存终止进程的终止状态，当它是一个空指针时，则不保存</li></ul><h3 id="调用wait或waitpid会发生什么？"><a href="#调用wait或waitpid会发生什么？" class="headerlink" title="调用wait或waitpid会发生什么？"></a>调用wait或waitpid会发生什么？</h3><ul><li>如果所有子进程都还在运行，则阻塞</li><li>如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回</li><li>如果它没有任何子进程，则立即出错返回</li></ul><h3 id="两个函数的区别"><a href="#两个函数的区别" class="headerlink" title="两个函数的区别"></a>两个函数的区别</h3><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞</li><li>waitpid并不等待其调用之后的第一个子进程终止，它有若干选项，可以控制它所等待的进程</li></ul><h3 id="其他相关函数"><a href="#其他相关函数" class="headerlink" title="其他相关函数"></a>其他相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><p>与waitpid相似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *resage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数提供的功能比wait、waitpid和waitid要多一个，与附加参数有关。该参数允许内核返回由终止进程及其所有子进程所使用的资源概况。</p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件。<br>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。<br>如果一个进程要等待其父进程终止，则可使用下列形式的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>) &#123;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的循环称为<code>轮询（polling）</code>，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试<br>为了避免竞争条件和轮询，在多个进程之间需要某种形式的信号发送和接收的方法。包括信号机制和进程间通信（IPC）</p><h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><h3 id="函数说明-2"><a href="#函数说明-2" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">int execl(const char *pathname, const char *arg0, ... /* (char *(0 */)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[] */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，从main函数开始执行。</li><li>exec不创建新进程，进程ID不变。</li><li>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</li><li>7个函数的关系：<br><img src="8-15.png" alt=""></li></ul><h2 id="更改用户ID、组ID"><a href="#更改用户ID、组ID" class="headerlink" title="更改用户ID、组ID"></a>更改用户ID、组ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="8-19.png" alt=""></p><h2 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</span><br></pre></td></tr></table></figure><p>system在其实现中调用了fork、exec和waitpid。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程标识&quot;&gt;&lt;a href=&quot;#进程标识&quot; class=&quot;headerlink&quot; title=&quot;进程标识&quot;&gt;&lt;/a&gt;进程标识&lt;/h2&gt;&lt;p&gt;每个进程都有一个非负整型表示的唯一进程ID。&lt;/p&gt;
&lt;p&gt;ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。&lt;/p&gt;
&lt;p&gt;进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init读取与系统有关的初始化文件，并将系统引导到一个状态。init进程不会终止，它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），以超级用户特权运行。&lt;/p&gt;
&lt;h2 id=&quot;fork函数&quot;&gt;&lt;a href=&quot;#fork函数&quot; class=&quot;headerlink&quot; title=&quot;fork函数&quot;&gt;&lt;/a&gt;fork函数&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;函数说明&quot;&gt;&lt;a href=&quot;#函数说明&quot; class=&quot;headerlink&quot; title=&quot;函数说明&quot;&gt;&lt;/a&gt;函数说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1&lt;/li&gt;
&lt;li&gt;子进程和父进程继续执行fork之后的指令；&lt;strong&gt;子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;fork时用到&lt;code&gt;写时复制（Copy-On-Write）&lt;/code&gt;技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”&lt;/li&gt;
&lt;li&gt;fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法&lt;/li&gt;
&lt;li&gt;文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。&lt;br&gt;&lt;img src=&quot;8-2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="process" scheme="https://akaqin.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <link href="https://akaqin.github.io/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/"/>
    <id>https://akaqin.github.io/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</id>
    <published>2020-02-23T09:03:12.000Z</published>
    <updated>2020-03-08T07:41:56.376Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>malloc</code>和<code>calloc</code>分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用<code>mmap</code>或<code>sbrk</code>系统调用</li><li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此<code>mmap()</code>保证返回的新内存始终为零</li><li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li><li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从<code>mmap()</code>返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;calloc&lt;/code&gt;分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用&lt;code&gt;mmap&lt;/code&gt;或&lt;code&gt;sbrk&lt;/code&gt;系统调用&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX环境高级编程》第7章——进程环境</title>
    <link href="https://akaqin.github.io/2020/02/23/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>https://akaqin.github.io/2020/02/23/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</id>
    <published>2020-02-23T08:03:39.000Z</published>
    <updated>2020-04-15T07:02:30.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程开始"><a href="#进程开始" class="headerlink" title="进程开始"></a>进程开始</h2>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure><p>   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><h3 id="终止方式"><a href="#终止方式" class="headerlink" title="终止方式"></a>终止方式</h3><p>有8种终止方式，前5种为正常终止，后3种为异常终止：</p><ol><li>从main返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit</li><li>调用abort</li><li>遇到一个信号</li><li>最后一个线程对取消请求做出响应</li></ol><a id="more"></a><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。<br>退出函数的参数叫做<em>终止状态</em>。<br><img src="7-2.png" alt=""><br>注意，内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。</p><h3 id="终止处理程序"><a href="#终止处理程序" class="headerlink" title="终止处理程序"></a>终止处理程序</h3><p>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br>调用顺序与登记顺序相反，登记多次也会调用多次。如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="存储空间布局与分配"><a href="#存储空间布局与分配" class="headerlink" title="存储空间布局与分配"></a>存储空间布局与分配</h2><h3 id="存储空间布局"><a href="#存储空间布局" class="headerlink" title="存储空间布局"></a>存储空间布局</h3><p>C程序由下列几部分构成：</p><ul><li>正文段<br>由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使频繁执行的程序在存储器中也只需要由一个副本。正文段通常是只读的，以防止程序由于意外而修改其指令。</li><li>初始化数据段（.data）<br>通常称为数据段。包含了明确赋初值的变量。例如C程序中任何函数之外的声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxcount = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>使此变量以其初值存放在初始化数据段种。</li><li>未初始化数据段（.bss）<br>也称为bss（block started by symbol）段。程序开始执行前，内核将此段中数据初始化为0或空指针。例如函数外的声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>使此变量存放在非初始化数据段中。未初始化数据段的内容并不存储在磁盘文件中，内核在程序运行前将它们设置为0.存放在磁盘文件中的段只有正文段和初始化数据段。</li><li>栈<br>自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。</li><li>堆<br>通常用于进行动态存储分配。</li></ul><p><img src="7-6.png" alt=""></p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时或每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑。</p><h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>malloc</code>分配指定字节数的存储区。其中的初始值不确定。</li><li><code>calloc</code>分配的每一位都初始化为0。</li><li><code>realloc</code>增加或减少分配区长度。新增区域内初始值不确定</li></ul><p>这三个函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。这些分配例程通常通过<code>sbrk</code>系统调用实现。<br>大部分<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。大多数实现所分配的存储空间比要求的要大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。</p><p><a href="../为什么calloc会比malloc-memset快">为什么calloc会比malloc+memset快</a></p><h4 id="内存分配时常见错误"><a href="#内存分配时常见错误" class="headerlink" title="内存分配时常见错误"></a>内存分配时常见错误</h4><ul><li>在动态分配的缓冲区前后进行写操作，破坏管理记录信息或用于其他动态分配的对象</li><li>释放一个已经释放了的块</li><li>调用free时的指针不是三个alloc函数的返回值</li><li>调用malloc不调用free，造成内存泄漏。进程地址空间长度会慢慢增加，直至没有空闲空间。此时由于过度的换页开销，会导致性能下降</li></ul><h2 id="环境表和环境变量"><a href="#环境表和环境变量" class="headerlink" title="环境表和环境变量"></a>环境表和环境变量</h2><p>每个程序都收到一张环境表。与参数表一样，环境表也是一个字符指针数组，全局变量environ则包含了该指针数组的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure><p><img src="7-5.png" alt=""><br>我们称environ为环境指针，通常用<code>getenv</code>和<code>putenv</code>访问特定的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>我们能影响的通常只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程。<br>环境表和环境字符串通常存放在进程存储空间的顶部（栈之上）。</p><h2 id="跨函数跳转"><a href="#跨函数跳转" class="headerlink" title="跨函数跳转"></a>跨函数跳转</h2><p>C语言中<code>goto</code>是无法跨越函数的，而执行这种类型的跳转功能的函数是<code>setjmp</code>和<code>longjmp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>每个进程都有一组资源限制，由getrlimit和setrlimit函数查询和更改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlptr)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程开始&quot;&gt;&lt;a href=&quot;#进程开始&quot; class=&quot;headerlink&quot; title=&quot;进程开始&quot;&gt;&lt;/a&gt;进程开始&lt;/h2&gt;   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。&lt;/p&gt;
&lt;h2 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h2&gt;&lt;h3 id=&quot;终止方式&quot;&gt;&lt;a href=&quot;#终止方式&quot; class=&quot;headerlink&quot; title=&quot;终止方式&quot;&gt;&lt;/a&gt;终止方式&lt;/h3&gt;&lt;p&gt;有8种终止方式，前5种为正常终止，后3种为异常终止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从main返回&lt;/li&gt;
&lt;li&gt;调用exit&lt;/li&gt;
&lt;li&gt;调用_exit或_Exit&lt;/li&gt;
&lt;li&gt;最后一个线程从启动例程返回&lt;/li&gt;
&lt;li&gt;从最后一个线程调用pthread_exit&lt;/li&gt;
&lt;li&gt;调用abort&lt;/li&gt;
&lt;li&gt;遇到一个信号&lt;/li&gt;
&lt;li&gt;最后一个线程对取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="《APUE》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="process" scheme="https://akaqin.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>CS知识点总结</title>
    <link href="https://akaqin.github.io/2019/03/17/CS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://akaqin.github.io/2019/03/17/CS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-17T03:29:09.000Z</published>
    <updated>2020-03-08T07:36:37.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h2><h3 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h3><ol><li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li><li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ol><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ol><li>管道（半双工，只能父子间使用）</li><li>FIFO（命名管道，去除了父子间限制）</li><li>消息队列（消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难）</li><li>信号量（一个计数器，用于为多个进程提供对共享数据对象的访问。）</li><li>共享存储（允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC）</li><li>套接字（与其它通信机制不同的是，它可用于不同机器间的进程通信）</li></ol><a id="more"></a><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>必要条件</strong></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><p><strong>处理方法</strong></p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机操作系统&quot;&gt;&lt;a href=&quot;#计算机操作系统&quot; class=&quot;headerlink&quot; title=&quot;计算机操作系统&quot;&gt;&lt;/a&gt;计算机操作系统&lt;/h2&gt;&lt;h3 id=&quot;进程与线程区别&quot;&gt;&lt;a href=&quot;#进程与线程区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程区别&quot;&gt;&lt;/a&gt;进程与线程区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。&lt;/li&gt;
&lt;li&gt;线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。&lt;/li&gt;
&lt;li&gt;由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。&lt;/li&gt;
&lt;li&gt;线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管道（半双工，只能父子间使用）&lt;/li&gt;
&lt;li&gt;FIFO（命名管道，去除了父子间限制）&lt;/li&gt;
&lt;li&gt;消息队列（消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难）&lt;/li&gt;
&lt;li&gt;信号量（一个计数器，用于为多个进程提供对共享数据对象的访问。）&lt;/li&gt;
&lt;li&gt;共享存储（允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC）&lt;/li&gt;
&lt;li&gt;套接字（与其它通信机制不同的是，它可用于不同机器间的进程通信）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="CS" scheme="https://akaqin.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点整理</title>
    <link href="https://akaqin.github.io/2019/03/01/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://akaqin.github.io/2019/03/01/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2019-03-01T01:36:09.000Z</published>
    <updated>2020-03-08T07:39:43.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InnoDB与MyISAM区别："><a href="#InnoDB与MyISAM区别：" class="headerlink" title="InnoDB与MyISAM区别："></a>InnoDB与MyISAM区别：</h3><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ol><h3 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h3><ol><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li></ol><a id="more"></a><h3 id="varchar和char的区别："><a href="#varchar和char的区别：" class="headerlink" title="varchar和char的区别："></a>varchar和char的区别：</h3><ol><li>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）</li><li>在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．</li><li>varchar最多能存储65535个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535bytes）。65535并不是一个很精确的上限，可以继续缩小这个上限。65535个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计。</li></ol><h3 id="null与最大长度"><a href="#null与最大长度" class="headerlink" title="null与最大长度:"></a>null与最大长度:</h3><ol><li>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要1bit来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位</li><li>如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</li><li>如果数据表只有一个varchar字段且该字段NOT NULL，那么该varchar字段的最大长度为65533个字节，即65535-2=65533byte</li><li>字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;</li><li>字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。</li><li>若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。</li></ol><h3 id="utf8-与-utf8mb4-："><a href="#utf8-与-utf8mb4-：" class="headerlink" title="utf8 与 utf8mb4 ："></a>utf8 与 utf8mb4 ：</h3><ol><li>utf-8中，一个字符最多3字节（汉字3字节，英文字母1字节）。</li><li>utf8_mb4是utf8的超集，一个字符最多4字节，支持补充字符。</li></ol><p>** 3、varchar物理存储**</p><p><strong>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。</strong></p><p><strong>当选择的字符集为latin1，一个字符占用一个byte</strong></p><p><strong>varchar(255)存储一个字符，一共使用2个bytes物理空间存储数据实际数据长度和数据值。</strong></p><p><strong>varchar(256)存储一个字符，使用2 bytes表示实际数据长度，一共需要3 bytes物理存储空间。</strong></p><p><strong>varchar对于不同的RDBMS引擎，有不通的物理存储方式，虽然有统一的逻辑意义。对于mysql的不同存储引擎，其实现方法与数据的物理存放方式也不同。</strong></p><p><strong>4、InnoDB中的varchar</strong></p><p><strong>InnoDB中varchar的物理存储方式与InnoDB使用的innodb_file_format有关。早期的innodb_file_forma使用的Antelope文件格式，支持redundant和compact两种row_format。从5.5开始或者InnoDB1.1，可以使用一种新的file format，Barracuda。Barracuda兼容Redundant，另外还支持dynamic和compressed两种row_format.</strong></p><p><strong>当innodb_file_format=Antelope，ROW_FORMAT=REDUNDANT 或者COMPACT。</strong></p><p><strong>innodb的聚集索引（cluster index）仅仅存储varchar、text、blob字段的前768个字节，多余的字节存储在一个独立的overflow page中，这个列也被称作off-page。768个字节前缀后面紧跟着20字节指针，指向overflow pages的位置。</strong></p><p><strong>另外，在innodb_file_format=Antelope情况下，InnoDB中最多能存储10个大字段（需要使用off-page存储）。innodbd的默认page size为16KB，InnoDB单行的长度不能超过16k/2=8k个字节，（768+20）*10 &lt; 8k。</strong></p><p><strong>当innodb_file_format=Barracuda, ROW_FORMAT=DYNAMIC 或者 COMPRESSED</strong></p><p><strong>innodb中所有的varchar、text、blob字段数据是否完全off-page存储，根据该字段的长度和整行的总长度而定。对off-page存储的列，cluster index中仅仅存储20字节的指针，指向实际的overflow page存储位置。如果单行的长度太大而不能完全适配cluster index page，innodb将会选择最长的列作为off-page存储，直到行的长度能够适配cluster index page。</strong></p><p><strong>5、MyISAM中的varchar</strong></p><p><strong>对于MyISAM引擎，varchar字段所有数据存储在数据行内（in-line）。myisam表的row_format也影响到varchar的物理存储行为。</strong></p><p><strong>MyISAM的row_format可以通过create或者alter sql语句设为fixed和dynamic。另外可以通过myisampack生成row_format=compresse的存储格式。</strong></p><p><strong>当myisam表中不存在text或者blob类型的字段，那么可以把row_format设置为fixed(也可以为dynamic)，否则只能为dynamic。</strong></p><p><strong>当表中存在varchar字段的时候，row_format可以设定为fixed或者dynamic。使用row_format=fixed存储varchar字段数据，浪费存储空间，varchar此时会定长存储。row_format为fixed和dynamic，varchar的物理实现方式也不同（可以查看源代码文件field.h和field.cc），因而myisam的row_format在fixed和dynamic之间发生转换的时候，varchar字段的物理存储方式也将会发生变化。</strong></p><h3 id="隔离级别："><a href="#隔离级别：" class="headerlink" title="隔离级别："></a>隔离级别：</h3><p><strong>一、首先什么是事务？</strong></p><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p><p>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消事务开始时的所有操作。</p><p><strong>二、事务的ACID</strong></p><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><p>1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</p><p>2 、一致性。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p><p>3 、隔离性。一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><p><strong>三、MySQL的四种隔离级别</strong></p><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p><p><strong>Read Uncommitted（读取未提交内容）</strong></p><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><p><strong>Read Committed（读取提交内容）</strong></p><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果。</p><p><strong>Repeatable Read（可重读）</strong></p><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><p><strong>Serializable（可串行化）</strong></p><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。</p><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><p>幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p><p><img src="https:////upload-images.jianshu.io/upload_images/5219651-fdd241489731111a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686/format/webp" alt="img"></p><p><strong>四**</strong>、事务隔离的原理是什么？**</p><p>我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。这里通过分析MySQL中InnoDB引擎的加锁机制，来抛砖引玉，让我们更好的理解，在事务处理中数据库到底做了什么。</p><p><strong>4.1、一次封锁or两段锁？</strong></p><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。</p><p>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</p><p>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</p><blockquote><p><strong>事务                 加锁/解锁处理</strong></p><p>begin；</p><p>insert into test …..     # 加insert对应的锁</p><p>update test set…      # 加update对应的锁</p><p>delete from test ….   # 加delete对应的锁</p><p>commit;                    # 事务提交时，同时释放insert、update、delete对应的锁</p></blockquote><p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p><p><strong>4.2、事务中的加锁方式</strong></p><p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。</p><p>我们在前面已经介绍了MySQL的四种隔离级别：</p><blockquote><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</p><p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p></blockquote><p><strong>Read UnCommitted（读取未提交内容）</strong></p><p>Read Uncommitted这种级别，数据库一般都不会用，而且任何操作都不会加锁，这里就不讨论了。</p><blockquote><p>MySQL中锁的种类：</p><p>MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等,表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。</p><p>行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。这里主要讨论的也就是行锁。</p></blockquote><p><strong>Read Committed（读取提交内容）</strong></p><p>在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read）。</p><p><strong>Repeatable Read（可重读）</strong></p><p>这是MySQL中InnoDB默认的隔离级别。我们姑且分“读”和“写”两个模块来讲解。</p><p><strong>读（快照读）</strong></p><p>读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时。我们前面已经讲过“理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）”。</p><p>讲到这里，我们先来好好地说明下不可重复读和幻读的区别：</p><blockquote><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p><p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p><p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p><p>MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p></blockquote><p>这里继续扩展下悲观锁和乐观锁的知识。</p><blockquote><p>悲观锁：</p><p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><p>乐观锁：</p><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p></blockquote><p>接下来讲解MVCC在MySQL的InnoDB中的实现：</p><blockquote><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p><p>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</p><p>INSERT时，保存当前事务版本号为行的创建版本号。</p><p>DELETE时，保存当前事务版本号为行的删除版本号。</p><p>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</p><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p></blockquote><p>注：“读”与“读”的区别。</p><p>事务的隔离级别其实都是对于读数据的定义，但到了这里，就被拆成了读和写两个模块来讲解。这主要是因为MySQL中的读，和事务隔离级别中的读，是不一样的。</p><p>我们且看，在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><blockquote><p>快照读：就是select</p><p>select * from table ….;</p><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><p>select * from table where ? lock in share mode;</p><p>select * from table where ? for update;</p><p>insert;</p><p>update ;</p><p>delete;</p></blockquote><p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p><p><strong>因为更新数据、插入数据是针对当前数据的，所以不能以快照的历史数据为参考，此处就是这个意思。</strong></p><p><strong>写（”当前读”）</strong></p><p>事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读，而这里说的“写”就是当前读了。</p><p>为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。</p><p>Next-Key锁是行锁和GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下GAP间隙锁。</p><p>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p><p><strong>Serializable</strong></p><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p><p>这里需要注意改变一个观念，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;InnoDB与MyISAM区别：&quot;&gt;&lt;a href=&quot;#InnoDB与MyISAM区别：&quot; class=&quot;headerlink&quot; title=&quot;InnoDB与MyISAM区别：&quot;&gt;&lt;/a&gt;InnoDB与MyISAM区别：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；&lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；&lt;/li&gt;
&lt;li&gt;InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。&lt;/li&gt;
&lt;li&gt;InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；&lt;/li&gt;
&lt;li&gt;Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;如何选择：&quot;&gt;&lt;a href=&quot;#如何选择：&quot; class=&quot;headerlink&quot; title=&quot;如何选择：&quot;&gt;&lt;/a&gt;如何选择：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；&lt;/li&gt;
&lt;li&gt;如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。&lt;/li&gt;
&lt;li&gt;系统奔溃后，MyISAM恢复起来更困难，能否接受；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="https://akaqin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP HashTable 解析</title>
    <link href="https://akaqin.github.io/2019/02/23/PHP%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90HashTable/"/>
    <id>https://akaqin.github.io/2019/02/23/PHP%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90HashTable/</id>
    <published>2019-02-23T08:03:39.000Z</published>
    <updated>2020-03-08T07:52:42.882Z</updated>
    
    <content type="html"><![CDATA[<p>说 HashTable 是PHP的灵魂，一点也不为过。在Zend引擎中，比如变量表、常量表、函数表、数组，以及资源管理、线程安全等，其实现都有HashTable的身影。HashTable 是一种查找性能极高的数据结构，理想情况下其算法复杂度是O(1)。</p><h3 id="PHP-HashTable-概述"><a href="#PHP-HashTable-概述" class="headerlink" title="PHP HashTable 概述"></a>PHP HashTable 概述</h3><ul><li>有两部分组成，Bucket 和 HashTable，而且均为结构体(struct)。</li><li>Bucket 是存储数据的单元，用于保存具体的数据内容；HashTable 用于保存整个哈希表需要的基本信息。</li><li>二者关系可以简单理解为：HashTable = Array(); HashTable[‘arBuckets’] = [Bucket1, Bucket2, Bucket3, …]。</li><li>HashTable 的目的就是通过索引把每个Bucket元素分散到唯一的位置。</li><li>PHP 内核通过HashTable 结构管理Bucket 数组。</li><li>相比普通HashTable，PHP的HashTable同时维护一个双向链表。在HashTable.arBuckets 存储的是包含多个Bucket指针的向量，每个指针又指向一个双向链表(多个bucket组成)。</li></ul><h2 id="HashTable-源码展示"><a href="#HashTable-源码展示" class="headerlink" title="HashTable 源码展示"></a>HashTable 源码展示</h2><p>在Zend/zend_hash.h的line 55~83 中定义了结构体 Bucket 和 HashTable。注意 Bucket 和 HashTable 是别名，分别对应结构体 bucket 和 _hashtable。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">    ulong h;                        <span class="comment">/* Used for numeric indexing */</span></span><br><span class="line">    uint nKeyLength;</span><br><span class="line">    <span class="keyword">void</span> *pData;</span><br><span class="line">    <span class="keyword">void</span> *pDataPtr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListLast</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pLast</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *arKey;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtable</span> &#123;</span></span><br><span class="line">    uint nTableSize;</span><br><span class="line">    uint nTableMask;</span><br><span class="line">    uint nNumOfElements;</span><br><span class="line">    ulong nNextFreeElement;</span><br><span class="line">    Bucket *pInternalPointer;   <span class="comment">/* Used for element traversal */</span></span><br><span class="line">    Bucket *pListHead;</span><br><span class="line">    Bucket *pListTail;</span><br><span class="line">    Bucket **arBuckets;</span><br><span class="line">    <span class="keyword">dtor_func_t</span> pDestructor;</span><br><span class="line">    zend_bool persistent;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> nApplyCount;</span><br><span class="line">    zend_bool bApplyProtection;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    <span class="keyword">int</span> inconsistent;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure><h2 id="Bucket-解析说明"><a href="#Bucket-解析说明" class="headerlink" title="Bucket 解析说明"></a>Bucket 解析说明</h2><p>先分析一下Bucket 结构体成员变量的作用：</p><table><thead><tr><th>成员变量</th><th>说明</th></tr></thead><tbody><tr><td><strong>ulong h;</strong></td><td>ulong 中u表示无符号，保存hash(key) 的值； 或者保存用户指定的整数类型索引值； key是什么？就是当前bucket的索引，存储在最后一个成员arKey中;</td></tr><tr><td><strong>uint nKeyLength;</strong></td><td>保存索引 key 的长度； 索引是字符串时，该值&gt;0，表示索引字符串的长度； 索引是整数时，该值==0；</td></tr><tr><td><strong>void *pData;</strong></td><td>指向要保存的内存块地址，一般是通过malloc之类的系统调用分配出来的 指向Value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr</td></tr><tr><td><strong>void *pDataPtr;</strong></td><td>保存指针数据，当保存的数据是指针类型，不需要malloc分配，就直接保存到pDataPtr中，pData直接指向这里 保存的数据不是指针类型时，pDataPtr=NULL</td></tr><tr><td><strong>struct bucket *pListNext;</strong></td><td>指向双向链表的下一个元素</td></tr><tr><td><strong>struct bucket *pListLast;</strong></td><td>指向双向链表的上一个元素</td></tr><tr><td><strong>struct bucket *pNext;</strong></td><td>指向具有同一个hash值的下一个元素</td></tr><tr><td><strong>struct bucket *pLast;</strong></td><td>指向具有同一个hash值的上一个元素，这里是hash碰撞后的处理方法，拉链法</td></tr><tr><td><strong>const char *arKey;</strong></td><td>注意，这里之前PHP版本是 char arKey[1];  在PHP5.6版本中，不限制索引的长度了； 结构体变量内存申请 sizeof(Bucket *), 无需 加上nKeyLength 长度了。</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><ol><li>pData 和 pDataPtr 的关系，<ul><li>pData 指向的是保存数据的内存块地址，一般通过malloc等分配;</li><li>pDataPtr 如果是指针数据，此值会指向真正的value，同时pData 会指向该值</li><li>疑问 内存块地址，不也是指针吗？和pDataPtr什么区别？？</li></ul></li><li>h 成员保存的是HashTable key 哈希后的值，而非HashTable中的索引值，为什么？<ul><li>索引值和HashTable的容量有关系，如果HashTable扩容，那么这些索引还得重新进行哈希，再进行索引映射</li><li>数字索引直接就可以作为哈希表的索引，数字也无需进行哈希处理</li></ul></li></ol><h2 id="HashTable-解析说明"><a href="#HashTable-解析说明" class="headerlink" title="HashTable 解析说明"></a>HashTable 解析说明</h2><table><thead><tr><th>成员变量</th><th>说明</th></tr></thead><tbody><tr><td><strong>uint nTableSize</strong></td><td>记录 Bucket 数组的大小</td></tr><tr><td><strong>uint nTableMask</strong></td><td>始终等于 nTableSize - 1 用在与哈希值做与运算，获得该哈希值的索引取值。额，哈希值是什么？？是Bucket中的索引值？</td></tr><tr><td><strong>uint nNumOfElements</strong></td><td>HashTable中，Bucket 元素的数量; count() 函数直接返回该值</td></tr><tr><td><strong>ulong nNextFreeElement</strong></td><td>表示数字键数组中，下一个数字索引的位置</td></tr><tr><td><strong>Bucket *pInternalPointer</strong></td><td>For循环时用于记录当前元素的位置 内部指针，指向当前成员，用于遍历元素</td></tr><tr><td><strong>Bucket *pListHead</strong></td><td>指向HashTable的第一个元素，也是数组的第一个元素。reset() 是返回这个值吗？与它是否有关系？</td></tr><tr><td><strong>Bucket *pListTail</strong></td><td>指向HashTable的最后一个元素，也是数组的最后一个元素。end()是返回这个值吗？与它是否有关系？</td></tr><tr><td><strong>Bucket \</strong>arBuckets**</td><td>Bucket组成的双向链表的数组，索引=hash(key) &amp; nTableMask</td></tr><tr><td><strong>dtor_func_t pDestructor</strong></td><td>删除Bucket数组元素使用的析构函数</td></tr><tr><td><strong>zend_bool persistent</strong></td><td>标记内存分配函数 true 使用系统的内存分配函数 false 使用PHP内存分配函数 一般使用PHP的内存分配函数，Zend引擎会管理相应内存，避免泄漏</td></tr><tr><td><strong>unsigned char nApplyCount</strong></td><td>保存当前Bucket被递归访问的次数，防止多次递归。@TODO 什么是多次递归？</td></tr><tr><td><strong>zend_bool bApplyProtection</strong></td><td>HashTable 是否需要递归报数，默认是1，要使用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说 HashTable 是PHP的灵魂，一点也不为过。在Zend引擎中，比如变量表、常量表、函数表、数组，以及资源管理、线程安全等，其实现都有HashTable的身影。HashTable 是一种查找性能极高的数据结构，理想情况下其算法复杂度是O(1)。&lt;/p&gt;
&lt;h3 id=&quot;PHP-HashTable-概述&quot;&gt;&lt;a href=&quot;#PHP-HashTable-概述&quot; class=&quot;headerlink&quot; title=&quot;PHP HashTable 概述&quot;&gt;&lt;/a&gt;PHP HashTable 概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有两部分组成，Bucket 和 HashTable，而且均为结构体(struct)。&lt;/li&gt;
&lt;li&gt;Bucket 是存储数据的单元，用于保存具体的数据内容；HashTable 用于保存整个哈希表需要的基本信息。&lt;/li&gt;
&lt;li&gt;二者关系可以简单理解为：HashTable = Array(); HashTable[‘arBuckets’] = [Bucket1, Bucket2, Bucket3, …]。&lt;/li&gt;
&lt;li&gt;HashTable 的目的就是通过索引把每个Bucket元素分散到唯一的位置。&lt;/li&gt;
&lt;li&gt;PHP 内核通过HashTable 结构管理Bucket 数组。&lt;/li&gt;
&lt;li&gt;相比普通HashTable，PHP的HashTable同时维护一个双向链表。在HashTable.arBuckets 存储的是包含多个Bucket指针的向量，每个指针又指向一个双向链表(多个bucket组成)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HashTable-源码展示&quot;&gt;&lt;a href=&quot;#HashTable-源码展示&quot; class=&quot;headerlink&quot; title=&quot;HashTable 源码展示&quot;&gt;&lt;/a&gt;HashTable 源码展示&lt;/h2&gt;&lt;p&gt;在Zend/zend_hash.h的line 55~83 中定义了结构体 Bucket 和 HashTable。注意 Bucket 和 HashTable 是别名，分别对应结构体 bucket 和 _hashtable。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://akaqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
      <category term="PHP" scheme="https://akaqin.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>ORM和QueryBuilder哪个好</title>
    <link href="https://akaqin.github.io/2019/01/08/ORM%E5%92%8CQueryBuilder%E5%93%AA%E4%B8%AA%E5%A5%BD/"/>
    <id>https://akaqin.github.io/2019/01/08/ORM%E5%92%8CQueryBuilder%E5%93%AA%E4%B8%AA%E5%A5%BD/</id>
    <published>2019-01-08T10:57:21.000Z</published>
    <updated>2020-03-08T07:42:25.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>​    最近准备将跑PHP5的老项目升PHP7，用的是CI2.x的框架，烂的一笔。主要障碍是php7删除了mysqli的相关函数，于是准备自己封装一个DAO层。看了一下主流的 <a href="https://github.com/doctrine/orm/" target="_blank" rel="noopener">doctrine/orm</a> ORM封装，发现用法特别繁琐，要在代码里描述每个表的每个字段：</p><figure class="highlight php7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// src/Product.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>​    感觉特别繁琐，不禁思考一个问题🤔：我们到底要不要用ORM，ORM真的比QueryBilder或原生sql的形式好吗？</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>​    从一开始写原生sql，到后来用TP、CI框架里的QueryBuilder，然后接触了Laravel和它的Eloquent后成为了ORM的狂热爱好者，再后来又开始脱离这些框架或工具自己试着造轮子写东西，经历这些后，我是这样想的：<strong>ORM和其他那些框架一样，就是为了让你从底层操作中解脱出来，去专心做业务逻辑</strong>。</p><p>​    一开始接触Laravel的时候，觉得它好牛逼，用到了好多我不懂的面向对象思想和设计模式。等把它吃透了后才觉得这框架也就那样，集成了很多成熟的工具，大而全，拿来学编程思想很不错；但这也是它的弊端，当我需要开发一些简单优雅的小工具时就有些大材小用了（虽然出了lumen，但感觉也是不尽人意）。</p><p>​    ORM也是一样的道理，有它的利（防注入、简化逻辑、不需要过多的sql知识），也有它的弊（代码量增加、不能精确控制sql的构成）。所以，ORM和QueryBuilder没有绝对的哪个好，而需要考虑具体使用场景：</p><ul><li><p>如果你更注重代码的性能而不是开发的简易性，请使用query builder</p></li><li><p>如果你喜欢OOP，与对象打交道，请使用ORM</p></li><li><p>如果你要批量处理多个实体，最好用query builder</p></li><li><p>如果你是mysql新手，或者程序不是很复杂，就直接用ORM</p></li><li><p>如果表之间的业务关系很复杂，还是用query builder吧</p></li></ul><p>  ​    从更高的层面思考：工具存在的意义就是为了解决实际问题，比较某某工具的好坏没有意义。多学习提升技术，当遇到实际问题时才能想出多种解决方案，并选取最合适的进行实践。这也是我喜欢做工程师的原因，做实事，解决实际问题，世界才会美好～</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;​    最近准备将跑PHP5的老项目升PHP7，用的是CI2.x的框架，烂的一笔。主要障碍是php7删除了mysqli的相关函数，于是准备自己封装一个DAO层。看了一下主流的 &lt;a href=&quot;https://github.com/doctrine/orm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;doctrine/orm&lt;/a&gt; ORM封装，发现用法特别繁琐，要在代码里描述每个表的每个字段：&lt;/p&gt;
&lt;figure class=&quot;highlight php7&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// src/Product.php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Product&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@var&lt;/span&gt; int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@var&lt;/span&gt; string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;($name)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;name = $name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="经验反思" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    
    
      <category term="MySQL" scheme="https://akaqin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于优惠券资金问题的反思</title>
    <link href="https://akaqin.github.io/2018/12/06/%E5%85%B3%E4%BA%8E%E4%BC%98%E6%83%A0%E5%88%B8%E8%B5%84%E9%87%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>https://akaqin.github.io/2018/12/06/%E5%85%B3%E4%BA%8E%E4%BC%98%E6%83%A0%E5%88%B8%E8%B5%84%E9%87%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%8D%E6%80%9D/</id>
    <published>2018-12-06T08:01:03.000Z</published>
    <updated>2020-03-08T07:42:56.753Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>offline脚本漏掉了回滚资金逻辑：<br>这块因为是离线脚本，只是在测试环境手动调用测的能不能跑通，线上因为不方便测就直接对接了。<br>以后这块有改动还是要多review，不能疏忽。</p></li><li><p>cms追加优惠券时忽略了事务一致性问题<br>事务一致性的问题本来一开始整理的时候列到了，把各项目到查了一遍，还是漏掉了一个，惭愧。。<br>后面需要推进事务协调器，撤掉解决这种问题出现的可能。</p></li><li><p>问题及时向上反馈<br>问题一开始出现时，只有我、春光和潘静在查这个问题，因为当时不知道问题2和少了30万预算这两件事的存在，<br>所以我和春光查了两天这个数怎么也对不上，如果早点向上反馈的话知道少了30万预算说不定这个问题早就解决了。。</p></li><li><p>找不到问题原因时的思考思路<br>昨天一天用各种方案算的数都对不上，这时候我们应该把已知并确定正确的信息列出来，和现有的数据做对比，<br>如果发现对不上，大胆的列出所有的可能性，并一一排查验证，排除掉不可能的，剩下的就是正确答案。</p><blockquote><p>比如 现有冻结金额远小于应有冻结金额，那么猜测可能的原因：<br>过期回滚时冻结资金扣多了 （验证后被排除<br>删除回滚时冻结资金扣多了（验证后被排除<br>创建时没有加冻结资金（验证后被排除<br>追加时没有加冻结资金————找到正确答案</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;offline脚本漏掉了回滚资金逻辑：&lt;br&gt;这块因为是离线脚本，只是在测试环境手动调用测的能不能跑通，线上因为不方便测就直接对接了。&lt;br&gt;以后这块有改动还是要多review，不能疏忽。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cms追加优惠券时忽略了事务一致
      
    
    </summary>
    
    
      <category term="经验反思" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    
    
      <category term="架构" scheme="https://akaqin.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>arts-13</title>
    <link href="https://akaqin.github.io/2018/11/12/arts-13/"/>
    <id>https://akaqin.github.io/2018/11/12/arts-13/</id>
    <published>2018-11-12T12:52:53.000Z</published>
    <updated>2020-03-07T12:44:27.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithim"><a href="#Algorithim" class="headerlink" title="Algorithim"></a>Algorithim</h2><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>Approach:1</strong></p><p>Imagine two runners running on a track at different speed. What happens when the track is actually a circle?</p><p>The space complexity can be reduced to O(1)O(1) by considering two pointers at <strong>different speed</strong> - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p><p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.</p><p>Now consider a cyclic list and imagine the slow and fast pointers are two runners racing around a circle track. The fast runner will eventually meet the slow runner. Why? Consider this case (we name it case A) - The fast runner is just one step behind the slow runner. In the next iteration, they both increment one and two steps respectively and meet each other.</p><p>How about other cases? For example, we have not considered cases where the fast runner is two or three steps behind the slow runner yet. This is simple, because in the next or next’s next iteration, this case will be reduced to case A mentioned above.</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">b</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">c</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    a-&gt;val = <span class="number">1</span>;</span><br><span class="line">    a-&gt;next = b;</span><br><span class="line">    b-&gt;next = c;</span><br><span class="line">    c-&gt;next = b;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle(a)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    malloc和calloc都是在堆中申请内从（两者的区别是calloc可以指定数量，并初始化内从的值，性能会比malloc慢一点，但可忽略不计），用完要用free释放掉。</p><p>​    c中没有HashTable或Map之类的结构，只能用这种算法，好处是空间复杂度是O(1)，时间复杂度和前者一样是O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithim&quot;&gt;&lt;a href=&quot;#Algorithim&quot; class=&quot;headerlink&quot; title=&quot;Algorithim&quot;&gt;&lt;/a&gt;Algorithim&lt;/h2&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Can you solve it without using extra space?&lt;/p&gt;
&lt;h3 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Approach:1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Imagine two runners running on a track at different speed. What happens when the track is actually a circle?&lt;/p&gt;
&lt;p&gt;The space complexity can be reduced to O(1)O(1) by considering two pointers at &lt;strong&gt;different speed&lt;/strong&gt; - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.&lt;/p&gt;
&lt;p&gt;If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.&lt;/p&gt;
&lt;p&gt;Now consider a cyclic list and imagine the slow and fast pointers are two runners racing around a circle track. The fast runner will eventually meet the slow runner. Why? Consider this case (we name it case A) - The fast runner is just one step behind the slow runner. In the next iteration, they both increment one and two steps respectively and meet each other.&lt;/p&gt;
&lt;p&gt;How about other cases? For example, we have not considered cases where the fast runner is two or three steps behind the slow runner yet. This is simple, because in the next or next’s next iteration, this case will be reduced to case A mentioned above.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>反思总结：优惠券服务拆分</title>
    <link href="https://akaqin.github.io/2018/11/06/%E4%BC%98%E6%83%A0%E5%88%B8%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/"/>
    <id>https://akaqin.github.io/2018/11/06/%E4%BC%98%E6%83%A0%E5%88%B8%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/</id>
    <published>2018-11-06T10:35:09.000Z</published>
    <updated>2020-03-08T07:42:42.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程中出现的问题："><a href="#过程中出现的问题：" class="headerlink" title="过程中出现的问题："></a>过程中出现的问题：</h2><p><strong>思考问题</strong></p><p>​    安全意识还是不够，不能因为这块是朝沛拆的就不怎么看，导致要上线了才发现回滚逻辑有这么多问题，临上线又重构代码，给测试也带来很多麻烦；想的不够细，有些逻辑靠衍雷提出来才想到，这一点感觉还是得靠多实践去改变。</p><p><strong>买家端无法提供服务</strong></p><p>​    虽然不是我的主要问题，但出问题时看到nginx的error_log：recv() failed (104: Connection reset by peer) while reading response header from upstream，应该能及时联想到是fpm的问题，然后随手ps下看看进程就能及时发现子进程只有5个；使用新机器时先看下机器配置。</p><p><strong>一些要注意的点：</strong></p><p>​    做服务这块一定要多了解业务，多思考可能存在的问题，心思要缜密，考虑全面，想的越多，出问题的概率才越小。尤其是涉及到事务相关的部分要考虑到成功失败的各种情况。</p><p>​    涉及多项目的服务与接口代码上线，要保证各种case都测过没问题了，先把服务上了，再逐个上客户端。尽量避免后期改动服务的情况，一旦服务有改动，就得各项目都测一遍，带来不必不要的成本与风险。</p><p>​    上线后及时的观察有没有各种异常，做好监控。</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过程中出现的问题：&quot;&gt;&lt;a href=&quot;#过程中出现的问题：&quot; class=&quot;headerlink&quot; title=&quot;过程中出现的问题：&quot;&gt;&lt;/a&gt;过程中出现的问题：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;思考问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    安全意识还是不够
      
    
    </summary>
    
    
      <category term="经验反思" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    
    
      <category term="architecture" scheme="https://akaqin.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>《Go语言圣经》笔记整理</title>
    <link href="https://akaqin.github.io/2018/11/01/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://akaqin.github.io/2018/11/01/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2018-11-01T04:08:15.000Z</published>
    <updated>2020-03-08T07:38:37.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Printf-转换动词"><a href="#Printf-转换动词" class="headerlink" title="Printf 转换动词"></a>Printf 转换动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%d十进制整数</span><br><span class="line">%x, %o, %b十六进制，八进制，二进制整数。</span><br><span class="line">%f, %g, %e浮点数: 3.141593 3.141592653589793 3.141593e+00</span><br><span class="line">%t布尔:true或false</span><br><span class="line">%c字符(rune) (Unicode码点)</span><br><span class="line">%s字符串</span><br><span class="line">%q带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39;</span><br><span class="line">%v变量的自然形式(natural format)</span><br><span class="line">%T变量的类型</span><br><span class="line">%%字面上的百分号标志(无操作数)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Printf-转换动词&quot;&gt;&lt;a href=&quot;#Printf-转换动词&quot; class=&quot;headerlink&quot; title=&quot;Printf 转换动词&quot;&gt;&lt;/a&gt;Printf 转换动词&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="《Go语言圣经》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Go" scheme="https://akaqin.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>arts-12</title>
    <link href="https://akaqin.github.io/2018/10/29/arts-12/"/>
    <id>https://akaqin.github.io/2018/10/29/arts-12/</id>
    <published>2018-10-29T02:49:32.000Z</published>
    <updated>2020-03-07T12:44:18.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>Approach 1:Brute Force</strong></p><p>​    暴力破解：从头开始检查每一个可能的子数组，记录其中最长的。要想求一个字符串中最长子字符串的长度，就得先能判断一个字符串是不是不重复的唯一字符串（allUnique函数），而要判断字符串是不是唯一的，除了迭代遍历每一个元素（contains函数），我暂时没想到什么别的好办法（这里是说C语言，Java里有HashSet）。这个算法的时间复杂度是很差的，套了4层for循环，但还是有几个可以优化的点，写在下面的注释里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个字符串是否包含某个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span> *substr, <span class="keyword">int</span> length, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (substr[i] == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一个字符串是否是唯一的（不重复的）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allUnique</span><span class="params">(<span class="keyword">char</span> *substr, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// i从1开始，也就是第二个元素，依次判断第i个字符是否包含在i前面的子字符中</span></span><br><span class="line">        <span class="keyword">if</span> (contains(substr, i, substr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> strLength = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (strLength == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strLength == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// maxLength是当前已求出来的最长子字符串长度，初始值给1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当已知的最大子字符长度大于等于剩下的字符长度时，就没必要循环了，</span></span><br><span class="line">    <span class="comment">// 因为剩下的部分即使都是唯一的也不可能超过当前的最大子字符长度</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; strLength - maxLength; i++) &#123;</span><br><span class="line">        <span class="comment">// j表示要迭代检查的子字符串长度，初始值直接用maxLength，</span></span><br><span class="line">        <span class="comment">// 因为小于maxLength的长度没必要检测</span></span><br><span class="line">        <span class="keyword">int</span> j = maxLength;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; strLength - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allUnique(s + i, j + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) &gt; maxLength) &#123;</span><br><span class="line">                maxLength = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>最近的问题反思</title>
    <link href="https://akaqin.github.io/2018/10/18/%E6%9C%80%E8%BF%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D/"/>
    <id>https://akaqin.github.io/2018/10/18/%E6%9C%80%E8%BF%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D/</id>
    <published>2018-10-18T10:11:07.000Z</published>
    <updated>2020-03-08T07:43:41.375Z</updated>
    
    <content type="html"><![CDATA[<p>关于最近的问题：</p><p>1、要解决问题，首先得学会分析一个问题具体出在哪个环节，越细越好</p><p>2、每个人都有犯错的机会，但是犯同类的错误会降低别人对你的信任，一定要会反思</p><p>3、你对每一个问题的责任心和态度都会有人记在心上，尽量给每个关注问题的人及时的反馈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于最近的问题：&lt;/p&gt;
&lt;p&gt;1、要解决问题，首先得学会分析一个问题具体出在哪个环节，越细越好&lt;/p&gt;
&lt;p&gt;2、每个人都有犯错的机会，但是犯同类的错误会降低别人对你的信任，一定要会反思&lt;/p&gt;
&lt;p&gt;3、你对每一个问题的责任心和态度都会有人记在心上，尽量给每个关注问题的
      
    
    </summary>
    
    
      <category term="经验反思" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    
    
      <category term="work" scheme="https://akaqin.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>arts-11</title>
    <link href="https://akaqin.github.io/2018/10/16/arts-11/"/>
    <id>https://akaqin.github.io/2018/10/16/arts-11/</id>
    <published>2018-10-16T04:18:52.000Z</published>
    <updated>2020-03-07T12:44:14.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Approach:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, x, y, sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">curr</span> = <span class="title">dummyHead</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">        x = p ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = q ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        next-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        curr-&gt;next = next;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span>;</span><br><span class="line">        next-&gt;val = carry;</span><br><span class="line">        curr-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;You are given two &lt;strong&gt;non-empty&lt;/strong&gt; linked lists representing two non-negative integers. The digits are stored in &lt;strong&gt;reverse order&lt;/strong&gt; and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;
&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: 342 + 465 &amp;#x3D; 807.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>工作心得总结</title>
    <link href="https://akaqin.github.io/2018/10/13/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    <id>https://akaqin.github.io/2018/10/13/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/</id>
    <published>2018-10-13T04:09:43.000Z</published>
    <updated>2020-03-08T07:43:09.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间评估"><a href="#时间评估" class="headerlink" title="时间评估"></a>时间评估</h3><p>​    当leader给你一个任务问你多久能完成时，不要简单的看一看就给一个估摸的大概的时间，要培养对工作量评估的能力，这很重要。评估时要做到尽量准确，具体注意以下几点：</p><ol><li>不要想着三个小时的工作,我加加班赶一赶两个小时搞定——在仓促状态下赶工，质量必然会收到影响，你做的每一件事的质量代表着你的个人水平，它直接影响着你在别人心中的看法，而且一旦再出什么额外状况，这个任务就会delay。</li><li>两个小时的工作量，不要想着我给自己估宽松点，估三个小时——该是多少就是多少，这直接影响别人对你的信任，如果同一份工作你给估了一个月，老板去问另一个开发，他只估了半个月，那老板以后可能就不会再找你分配工作。一天八小时工作制，由于各种各样的原因实际可支配的时间其实并没有这么多，那你可以提前说明比如我每天要给别人解决各种各样的问题或者晚上想留出两小时的时间学习，所以每天实际的开发时间只有5h，那一份40h工作量的任务对我来说就需要8day，但一定不要把这些额外事情的时间算到这个任务里。</li><li>评估任务尽量拆解的细一些，想的全面一些。一个需求中复杂的坑和细节尽量一开始就考虑到搞清楚，并留出相应的时间，以避免做到一半发现有坑再delay，承诺过的事情要有契约精神。我知道这很难，但尽量做，其实每个任务实际完成的时间比预期差个一天半天都是正常的，关键是要总结经验，想想这次评估中有哪些不足，让下次的评估可以更准确。如果每次评估都是糊弄了事，你会逐渐丧失时间评估的能力。</li></ol><a id="more"></a><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>​       时间是你最宝贵的财富，所以一定要利用好。要学会主动管理，对于学习上，每天一定要抽出整块的不被打扰的时间用来学习，提升个人技术能力和自身价值，是走技术这条路最最重要的一步，活到老学到老。对于工作上，学会使用任务管理工具（如tower），一些小的零碎的事情，短时间能解决的优先解决，别给自己攒太多压力，然后集中精力去做那些大块的工作。如果一个任务的工作是一周或两周，那就提前拆解好每天要做到什么程度，每晚review一下工作情况，对总体的进度有个把控，如果感觉搞不完要delay就加加班或者提前向上反馈，因为什么什么原因，这个任务要delay多久，并给出解决方案，要么加班，要么整体延期。一定不要等到deadline了才发现做不完，影响整个团队的进度。</p><h3 id="同事之间的交往"><a href="#同事之间的交往" class="headerlink" title="同事之间的交往"></a>同事之间的交往</h3><p>​    大家一起共事都是缘分，一个团队中每个人的技术肯定是有高有低参差不齐的，性格也是多种多样。相处时要做到谦虚和尊敬他人，学会倾听和站在他人的角度思考问题，每个人身上肯定都有比自己强值得学习的地方，要学会发现这些闪光点。当别人来找自己问问题的时候，要注意自己的态度，对事不对人，如果一个人对同一个问题或类似的问题找你问很多遍，你可以说这个问题我给你讲过很多次了，你先自己想一下有没有思路，该怎么解决，想好方案再来找我；但如果他带来的是个新问题还是要耐心解答的，不能因为他老问问题就不理他。</p><h3 id="责任与心态"><a href="#责任与心态" class="headerlink" title="责任与心态"></a>责任与心态</h3><p>​    出现问题时leader询问情况，要先快速定位问题，并给出解决方案，分析利弊；如出的问题跟自己没关系，也可以待命看看有什么能帮的上忙的，帮忙思考下解决方案；问题解决后，思考问题是怎么造成的，以后怎么避免，总结经验；如果是自身的原因主动承担错误，如果是别人的原因，自己也要引以为戒。一定不要出了问题先说这代码是谁谁谁写的，把自己撇的一干二净，这给人感觉很不好，直接决定了你做事的高度。出问题是在所难免的，这并不可怕，很多时候leader也只是问问想搞清楚情况，并没有要责怪谁的意思，关键是不要让范过的错误重复的发生在自己身上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;时间评估&quot;&gt;&lt;a href=&quot;#时间评估&quot; class=&quot;headerlink&quot; title=&quot;时间评估&quot;&gt;&lt;/a&gt;时间评估&lt;/h3&gt;&lt;p&gt;​    当leader给你一个任务问你多久能完成时，不要简单的看一看就给一个估摸的大概的时间，要培养对工作量评估的能力，这很重要。评估时要做到尽量准确，具体注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要想着三个小时的工作,我加加班赶一赶两个小时搞定——在仓促状态下赶工，质量必然会收到影响，你做的每一件事的质量代表着你的个人水平，它直接影响着你在别人心中的看法，而且一旦再出什么额外状况，这个任务就会delay。&lt;/li&gt;
&lt;li&gt;两个小时的工作量，不要想着我给自己估宽松点，估三个小时——该是多少就是多少，这直接影响别人对你的信任，如果同一份工作你给估了一个月，老板去问另一个开发，他只估了半个月，那老板以后可能就不会再找你分配工作。一天八小时工作制，由于各种各样的原因实际可支配的时间其实并没有这么多，那你可以提前说明比如我每天要给别人解决各种各样的问题或者晚上想留出两小时的时间学习，所以每天实际的开发时间只有5h，那一份40h工作量的任务对我来说就需要8day，但一定不要把这些额外事情的时间算到这个任务里。&lt;/li&gt;
&lt;li&gt;评估任务尽量拆解的细一些，想的全面一些。一个需求中复杂的坑和细节尽量一开始就考虑到搞清楚，并留出相应的时间，以避免做到一半发现有坑再delay，承诺过的事情要有契约精神。我知道这很难，但尽量做，其实每个任务实际完成的时间比预期差个一天半天都是正常的，关键是要总结经验，想想这次评估中有哪些不足，让下次的评估可以更准确。如果每次评估都是糊弄了事，你会逐渐丧失时间评估的能力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="经验反思" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%8F%8D%E6%80%9D/"/>
    
    
      <category term="work" scheme="https://akaqin.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>arts-10</title>
    <link href="https://akaqin.github.io/2018/10/07/arts-10/"/>
    <id>https://akaqin.github.io/2018/10/07/arts-10/</id>
    <published>2018-10-07T06:35:26.000Z</published>
    <updated>2020-03-07T12:44:10.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><p><strong>Summary:</strong></p><p>想问题没有思路时可以试着把负责的问题简单化，比如这道题求<code>maxSubArray(int A[], int i, int j)</code>，我们可以简化成求<code>maxSubArray(int A[], int i)</code>，也就是<code>A[0:i ]</code>——以A[0]开头A[i]结尾的最大子集，然后再观察总结，我们得出：</p><blockquote><p>maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i];</p></blockquote><a id="more"></a><p><strong>Approach:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[numsSize];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = temp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        temp[i] = nums[i] + (temp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? temp[i<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &lt; temp[i] ? temp[i] : <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt;, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [-2,1,-3,4,-1,2,1,-5,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: [4,-1,2,1] has the largest sum &amp;#x3D; 6.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have figured out the O(&lt;em&gt;n&lt;/em&gt;) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想问题没有思路时可以试着把负责的问题简单化，比如这道题求&lt;code&gt;maxSubArray(int A[], int i, int j)&lt;/code&gt;，我们可以简化成求&lt;code&gt;maxSubArray(int A[], int i)&lt;/code&gt;，也就是&lt;code&gt;A[0:i ]&lt;/code&gt;——以A[0]开头A[i]结尾的最大子集，然后再观察总结，我们得出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;maxSubArray(A, i) = maxSubArray(A, i - 1) &amp;gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i];&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-9</title>
    <link href="https://akaqin.github.io/2018/10/06/arts-9/"/>
    <id>https://akaqin.github.io/2018/10/06/arts-9/</id>
    <published>2018-10-06T05:52:34.000Z</published>
    <updated>2020-03-07T12:43:55.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em> th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>Approach</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">change</span><span class="params">(<span class="keyword">char</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret_temp = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> flag = ret[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(ret); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == ret[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j += <span class="built_in">sprintf</span>(ret_temp + j, <span class="string">"%d%c"</span>, count, flag);</span><br><span class="line">            flag = ret[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(ret_temp + j, <span class="string">"%d%c"</span>, count, flag);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> ret_temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">5000</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret = change(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.     11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.     21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.     1211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.     111221&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;one 1&amp;quot;&lt;/code&gt; or &lt;code&gt;11&lt;/code&gt;.&lt;br&gt;&lt;code&gt;11&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;two 1s&amp;quot;&lt;/code&gt; or &lt;code&gt;21&lt;/code&gt;.&lt;br&gt;&lt;code&gt;21&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;one 2&lt;/code&gt;, then &lt;code&gt;one 1&amp;quot;&lt;/code&gt; or &lt;code&gt;1211&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given an integer &lt;em&gt;n&lt;/em&gt; where 1 ≤ &lt;em&gt;n&lt;/em&gt; ≤ 30, generate the &lt;em&gt;n&lt;/em&gt; th term of the count-and-say sequence.&lt;/p&gt;
&lt;p&gt;Note: Each term of the sequence of integers will be represented as a string.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>关于Mac升级Mojave后的一些坑</title>
    <link href="https://akaqin.github.io/2018/10/04/%E5%85%B3%E4%BA%8EMac%E5%8D%87%E7%BA%A7Mojave%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>https://akaqin.github.io/2018/10/04/%E5%85%B3%E4%BA%8EMac%E5%8D%87%E7%BA%A7Mojave%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</id>
    <published>2018-10-04T05:58:18.000Z</published>
    <updated>2020-03-07T12:20:26.288Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Git无法使用，原因是每次大版本升级后，CommandLineTools回被卸载，而Git这种命令行工具依赖于CommandLineTools，解决方案是重新安装CommandLineTools。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>gcc编译文件时找不到头文件，报类似于 stdio.h file not found 的错误，具体情况可以看<a href="https://stackoverflow.com/questions/52509602/cant-compile-c-program-on-a-mac-after-upgrade-to-mojave" target="_blank" rel="noopener">StackOverflow</a>上这个提问。解决方案是使用brew安装或升级gcc最新版本，并在你的IDE中配置它，这里给出CLion的<a href="https://www.jetbrains.com/help/clion/how-to-switch-compilers-in-clion.html" target="_blank" rel="noopener">配置教程</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line">brew upgrade gcc</span><br></pre></td></tr></table></figure></li></ol><p>如果你遇到了一些其他问题，欢迎给我留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Git无法使用，原因是每次大版本升级后，CommandLineTools回被卸载，而Git这种命令行工具依赖于CommandLineTools，解决方案是重新安装CommandLineTools。&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="踩坑记录" scheme="https://akaqin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="macOS" scheme="https://akaqin.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>arts-8</title>
    <link href="https://akaqin.github.io/2018/10/03/arts-8/"/>
    <id>https://akaqin.github.io/2018/10/03/arts-8/</id>
    <published>2018-10-03T06:30:47.000Z</published>
    <updated>2020-03-07T12:43:35.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Approach 1: two pointer</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize ==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">            nums[++i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用双指针遍历这个数组，一个指针用来迭代，另一个记录不重复的值的索引。时间复杂度O(n)，空间复杂度O(1)。</p><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>approach 1:two pointer</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Approach-2-Two-Pointers-when-elements-to-remove-are-rare"><a href="#Approach-2-Two-Pointers-when-elements-to-remove-are-rare" class="headerlink" title="Approach 2: Two Pointers - when elements to remove are rare"></a><strong>Approach 2: Two Pointers - when elements to remove are rare</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Intuition</strong></p><p>Now consider cases where the array contains few elements to remove. For example, nums = [1,2,3,5,4], val = 4nums=[1,2,3,5,4],val=4. The previous algorithm will do unnecessary copy operation of the first four elements. Another example is nums = [4,1,2,3,5], val = 4nums=[4,1,2,3,5],val=4. It seems unnecessary to move elements [1,2,3,5][1,2,3,5] one step left as the problem description mentions that the order of elements could be changed.</p><p><strong>Algorithm</strong></p><p>When we encounter nums[i] = valnums[i]=val, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array’s size by 1.</p><p>Note that the last element that was swapped in could be the value you want to remove itself. But don’t worry, in the next iteration we will still check this element.</p><p><strong>Complexity analysis</strong></p><ul><li>Time complexity : O(n)O(n). Both ii and nn traverse at most nn steps. In this approach, the number of assignment operation is equal to the number of elements to remove. So it is more efficient if elements to remove are rare.</li><li>Space complexity : O(1)O(1).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;Given a sorted array &lt;em&gt;nums&lt;/em&gt;, remove the duplicates &lt;a href=&quot;https://en.wikipedia.org/wiki/In-place_algorithm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;in-place&lt;/strong&gt;&lt;/a&gt; such that each element appear only &lt;em&gt;once&lt;/em&gt; and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this by &lt;strong&gt;modifying the input array in-place&lt;/strong&gt; with O(1) extra memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given nums &amp;#x3D; [1,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your function should return length &amp;#x3D; 2, with the first two elements of nums being 1 and 2 respectively.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;It doesn&amp;#39;t matter what you leave beyond the returned length.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>异步网络模型</title>
    <link href="https://akaqin.github.io/2018/09/24/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>https://akaqin.github.io/2018/09/24/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</id>
    <published>2018-09-24T07:33:38.000Z</published>
    <updated>2020-03-08T07:43:18.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步网络模型"><a href="#异步网络模型" class="headerlink" title="异步网络模型"></a>异步网络模型</h1><p>异步网络模型在服务开发中应用非常广泛，相关资料和开源库也非常多。项目中，使用现成的轮子提高了开发效率，除了能使用轮子，还是有必要了解一下轮子的内部构造。</p><p>这篇文章从最基础的5种I/O模型切入，到I/O事件处理模型，再到并发模式，最后以Swoole开源库来做具体分析，逐步深入。文中提到的模型都是一些通用的模型，在《linux高性能服务器编程》中也都有涉及。文章不涉及模型的实现细节，最重要的是去理解各个模型的工作模式以及其优缺点。</p><p>读后感：</p><p>所谓异步：</p><p>1.(fd)阻塞调用 + select/pool, epool  （IO事件通知方式：IO复用）</p><p>2.(fd)非阻塞调用 + SIGIO （IO事件通知方式：SIGIO 信号）</p><a id="more"></a><p>文中涉及接口调用的部分，都是指Linux系统的接口调用。共分为5部分：</p><p>I/O模型</p><p>从基础的系统调用方法出发，给大家从头回顾一下最基本的I/O模型，虽然简单，但是不可或缺的基础；</p><p>事件处理模型</p><p>这部分在同步I/O、异步I/O的基础上分别介绍Reactor模型以及Proactor模型，着重两种模型的构成以及事件处理流程。Reactor模型是我们常见的；不同平台对异步I/O系统接口的支持力度不同，这部分还介绍了一种使用同步I/O来模拟Proactor模型的方法。</p><p>并发模式</p><p>就是多线程、多进程的编程的模式。介绍了两种较为高效的并发模型，半同步／半异步(包括其演变模式)、Follower／Leader模式。</p><p>Swoole异步网络模型分析</p><p>这部分是结合已介绍的事件处理模型、并发模式对Swoole的异步模型进行分析；从分析的过程来看，看似复杂的网络模型，可以拆分为简单的模型单元，只不过我们需要权衡利弊，选取合适业务需求的模型单元进行组合。我们团队基于Swoole 1.8.5版本，做了很多修改，部分模块做了重构，计划在17年6月底将修改后版本开源出去，敬请期待。</p><p>改善性能的方法</p><p>最后一部分是在引入话题，介绍的是几种常用的方法。性能优化是没有终点的，希望大家能贡献一些想法和具体方法。</p><p>I/O模型</p><p>POSIX 规范中定义了同步I/O 和异步I/O的术语，</p><p>同步I/O : 需要进程去真正的去操作I/O；</p><p>异步I/O：内核在I/O操作完成后再通知应用进程操作结果。</p><p>在《UNIX网络编程》中介绍了5中I/O模型：阻塞I/O、非阻塞I/O、I/O复用、SIGIO 、异步I/O；本节对这5种I/O模型进行说明和对比。</p><p>I/O阻塞</p><p>通常把阻塞的文件描述符（file descriptor，fd）称之为阻塞I/O。默认条件下，创建的socket fd是阻塞的，针对阻塞I/O调用系统接口，可能因为等待的事件没有到达而被系统挂起，直到等待的事件触发调用接口才返回，例如，tcp socket的connect调用会阻塞至第三次握手成功（不考虑socket 出错或系统中断），如图1所示。另外socket 的系统API ，如，accept、send、recv等都可能被阻塞。</p><p><img src="https:////note.youdao.com/src/B7FFBB5BC3684E41BFFE7BB61A1BF09E" alt="img"></p><p>​                      图1I/O 阻塞模型示意图</p><p>1</p><p>另外补充一点，网络编程中，通常把可能永远阻塞的系统API调用 称为慢系统调用，典型的如 accept、recv、select等。慢系统调用在阻塞期间可能被信号中断而返回错误，相应的errno 被设置为EINTR，我们需要处理这种错误，解决办法有：</p><p>\1. 重启系统调用</p><p>直接上示例代码吧，以accept为例，被中断后重启accept 。有个例外，若connect 系统调用在阻塞时被中断，是不能直接重启的（与内核socket 的状态有关)，有兴趣的同学可以深入研究一下connect 的内核实现。使用I/O复用等待连接完成，能避免connect不能重启的问题。</p><p>int client_fd = -1;  structsockaddr_inclient_addr;socklen_t child_addrlen;  while (1) {  call_accept:      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {       if (EINTR == errno) {          goto call_accept;       } else {          sw_sysError(“accept fail”);          break;       }    }}</p><p>123456789101112131415</p><p>\2. 信号处理</p><p>利用信号处理，可以选择忽略信号，或者在安装信号时设置SA_RESTART属性。设置属性SA_RESTART，信号处理函数返回后，被安装信号中断的系统调用将自动恢复，示例代码如下。需要知道的是，设置SA_RESTART属性方法并不完全适用，对某些系统调用可能无效，这里只是提供一种解决问题的思路，示例代码如下：</p><p>int client_fd = -1;  structsigactionaction,old_action;action.sa_handler = sig_handler;  sigemptyset(&amp;action.sa_mask);  action.sa_flags = 0;  action.sa_flags |= SA_RESTART;/// 若信号已经被忽略，则不设置sigaction(SIGALRM, NULL, &amp;old_action)；  if (old_action.sa_handler != SIG_IGN) {      sigaction(SIGALRM, &amp;action, NULL)；}while (1) {      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {        sw_sysError(“accept fail”);        break;    }}</p><p>123456789101112131415161718192021</p><p>I/O非阻塞</p><p>把非阻塞的文件描述符称为非阻塞I/O。可以通过设置SOCK_NONBLOCK标记创建非阻塞的socket fd，或者使用fcntl将fd设置为非阻塞。</p><p>对非阻塞fd调用系统接口时，不需要等待事件发生而立即返回，事件没有发生，接口返回-1，此时需要通过errno的值来区分是否出错，有过网络编程的经验的应该都了解这点。不同的接口，立即返回时的errno值不尽相同，如，recv、send、accept errno通常被设置为EAGIN 或者EWOULDBLOCK，connect 则为EINPRO-GRESS 。</p><p>以recv操作非阻塞套接字为例，如图2所示。</p><p><img src="https:////note.youdao.com/src/0DF7FBEB18524D968DA0D4DC4F7ED257" alt="img"></p><p>​                     图2 非阻塞I/O模型示意图</p><p>1</p><p>当我们需要读取，在有数据可读的事件触发时，再调用recv，避免应用层不断去轮询检查是否可读，提高程序的处理效率。通常非阻塞I/O与I/O事件处理机制结合使用。</p><p>I/O复用</p><p>最常用的I/O事件通知机制就是I/O复用(I/O multiplexing)。Linux 环境中使用select/poll/epoll 实现I/O复用，I/O复用接口本身是阻塞的，在应用程序中通过I/O复用接口向内核注册fd所关注的事件，当关注事件触发时，通过I/O复用接口的返回值通知到应用程序，如图3所示,以recv为例。I/O复用接口可以同时监听多个I/O事件以提高事件处理效率。</p><p><img src="https:////note.youdao.com/src/2FE99F76417C4837A098D4D8DA4EDFCF" alt="img"></p><p>​                    图 3I/O复用模型示意图</p><p>1</p><p>关于select/poll/epoll的对比，可以参考[]，epoll使用比较多，但是在并发的模式下，需要关注惊群的影响。</p><p>SIGIO</p><p>除了I/O复用方式通知I/O事件，还可以通过SIGIO信号来通知I/O事件，如图4所示。两者不同的是，在等待数据达到期间，I/O复用是会阻塞应用程序，而SIGIO方式是不会阻塞应用程序的。</p><p><img src="https:////note.youdao.com/src/4EC5DCA3909E4C52910ABD33BC7FD478" alt="img"></p><p>​                     图 4 信号驱动I/O模型示意图</p><p>1</p><p>异步I/O</p><p>POSIX规范定义了一组异步操作I/O的接口，不用关心fd 是阻塞还是非阻塞，异步I/O是由内核接管应用层对fd的I/O操作。异步I/O向应用层通知I/O操作完成的事件，这与前面介绍的I/O 复用模型、SIGIO模型通知事件就绪的方式明显不同。以aio_read 实现异步读取IO数据为例，如图5所示，在等待I/O操作完成期间，不会阻塞应用程序。</p><p><img src="https:////note.youdao.com/src/DDC1E38AE6ED40E6B1302E75DFD4F7F8" alt="img"></p><p>​                      图 5 异步I/O 模型示意图</p><p>1</p><p>I/O模型对比</p><p>前面介绍的5中I/O中，I/O 阻塞、I/O非阻塞、I/O复用、SIGIO 都会在不同程度上阻塞应用程序，而只有异步I/O模型在整个操作期间都不会阻塞应用程序。</p><p>如图6所示，列出了5种I/O模型的比较</p><p><img src="https:////note.youdao.com/src/3F0992AC6EC74A9880DC225FF3F8EE05" alt="img"></p><p>​                   图6 五种I/O 模型比较示意图</p><p>1</p><p>事件处理模型</p><p>网络设计模式中，如何处理各种I/O事件是其非常重要的一部分，Reactor 和Proactor两种事件处理模型应运而生。上章节提到将I/O分为同步I/O 和 异步I/O，可以使用同步I/O实现Reactor模型，使用异步I/O实现Proactor模型。</p><p>本章节将介绍Reactor和Proactor两种模型，最后将介绍一种使用同步I/O模拟Proactor事件处理模型。</p><p>Reactor事件处理模型</p><p>Reactor模型是同步I/O事件处理的一种常见模型，关于Reactor模型结构的资料非常多，一个典型的Reactor模型类图结构如图7所示，</p><p><img src="https:////note.youdao.com/src/CBD29D74325044DAB307FFCFE83D46E2" alt="img"></p><p>​                   图 7 Reactor 模型类结构图</p><p>1</p><p>Reactor的核心思想：将关注的I/O事件注册到多路复用器上，一旦有I/O事件触发，将事件分发到事件处理器中，执行就绪I/O事件对应的处理函数中。模型中有三个重要的组件：</p><ul><li>多路复用器：由操作系统提供接口，Linux提供的I/O复用接口有select、poll、epoll；</li><li>事件分离器：将多路复用器返回的就绪事件分发到事件处理器中；</li><li>事件处理器：处理就绪事件处理函数。</li></ul><p>图7所示，Reactor 类结构中包含有如下角色。</p><ul><li>Handle：标示文件描述符；</li><li>Event Demultiplexer：执行多路事件分解操作，对操作系统内核实现I/O复用接口的封装；用于阻塞等待发生在句柄集合上的一个或多个事件（如select/poll/epoll）；</li><li>Event Handler：事件处理接口；</li><li>Event Handler A(B)：实现应用程序所提供的特定事件处理逻辑；</li><li>Reactor：反应器，定义一个接口，实现以下功能：</li></ul><p>​      a)供应用程序注册和删除关注的事件句柄；      b)运行事件处理循环；      c)等待的就绪事件触发，分发事件到之前注册的回调函数上处理.</p><p>123</p><p>接下来介绍Reactor的工作流程，如图8所示，为Reactor模型工作的简化流程。</p><p><img src="https:////note.youdao.com/src/FA1A0970047647E9BE2DC7AB66721B97" alt="img"></p><p>​                  图8 Reactor模型简化流程示意图</p><p>1</p><ol><li>注册I/O就绪事件处理器；</li><li>事件分离器等待I/O就绪事件；</li><li>I/O事件触发，激活事件分离器，分离器调度对应的事件处理器；</li><li>事件处理器完成I/O操作，处理数据.</li></ol><p>网络设计中，Reactor使用非常广，在开源社区有很许多非常成熟的、跨平台的、Reactor模型的网络库，比较典型如libevent。</p><p>Proactor事件处理模型</p><p>与Reactor不同的是，Proactor使用异步I/O系统接口将I/O操作托管给操作系统，Proactor模型中分发处理异步I/O完成事件，并调用相应的事件处理接口来处理业务逻辑。Proactor类结构如图9所示。</p><p><img src="https:////note.youdao.com/src/541F3DEA29674188AD21BB9C12AB2508" alt="img"></p><p>​                    图9 Proactor模型类结构图</p><p>1</p><p>图9所示，Proactor类结构中包含有如下角色：</p><ul><li>Handle： 用来标识socket连接或是打开文件；</li><li>Async Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li><li>Async Operation：异步操作；</li><li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用；</li><li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li><li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li><li>Completion Handler A(B)：完成事件处理逻辑；实现接口定义特定的应用处理逻辑。</li></ul><p>Proactor模型的简化的工作流程,如图10所示。</p><p><img src="https:////note.youdao.com/src/72BA30C44C334ED28602FDA853052912" alt="img"></p><p>​                 图10 Proactor模型简化工作流程示意图</p><p>1</p><ol><li>发起I/O异步操作，注册I/O完成事件处理器;</li><li>事件分离器等待I/O操作完成事件；</li><li>内核并行执行实际的I/O操作，并将结果数据存入用户自定义缓 冲区；</li><li>内核完成I/O操作，通知事件分离器，事件分离器调度对应的事件处理器；</li><li>事件处理器处理用户自定义缓冲区中的数据。</li></ol><p>Proactor利用异步I/O并行能力，可给应用程序带来更高的效率，但是同时也增加了编程的复杂度。windows对异步I/O提供了非常好的支持，常用Proactor的模型实现服务器；而Linux对异步I/O操作(aio接口)的支持并不是特别理想，而且不能直接处理accept，因此Linux平台上还是以Reactor模型为主。</p><p>Boost asio采用的是Proactor模型，但是Linux上，采用I/O复用的方式来模拟Proactor，另启用线程来完成读写操作和调度。</p><p>同步I/O模拟Proactor</p><p>下面一种使用同步I/O模拟Proactor的方案，原理是：</p><p>主线程执行数据读写操作，读写操作完成后，主线程向工作线程通知I/O操作“完成事件”；</p><p>工作流程如图 11所示。</p><p><img src="https:////note.youdao.com/src/4A797D1DFA4345A6B8CA651380814811" alt="img"></p><p>​                  图11 同步I/O模拟Proactor模型</p><p>1</p><p>简单的描述一下图11 的执行流程：</p><ol><li>主线程往系统I/O复用中注册文件描述符fd上的读就绪事件；</li><li>主线程调用调用系统I/O复用接口等待文件描述符fd上有数据可读；</li><li>当fd上有数据可读时，通知主线程。主线程循环读取fd上的数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后向I/O复用中注册fd上的写就绪事件。主线程进入事件等待循环，等待fd可写。</li></ol><p>并发模式</p><p>在I/O密集型的程序，采用并发方式可以提高CPU的使用率，可采用多进程和多线程两种方式实现并发。当前有高效的两种并发模式，半同步/半异步模式、Follower/Leader模式。</p><p>半同步/半异步模式</p><p>首先区分一个概念，并发模式中的“同步”、“异步”与 I/O模型中的“同步”、“异步”是两个不同的概念：</p><p>并发模式中，“同步”指程序按照代码顺序执行，“异步”指程序依赖事件驱动，如图12 所示并发模式的“同步”执行和“异步”执行的读操作；</p><p>I/O模型中，“同步”、“异步”用来区分I/O操作的方式，是主动通过I/O操作拿到结果，还是由内核异步的返回操作结果。</p><p><img src="https:////note.youdao.com/src/C0FEC4831C074C0CB23329F010B270AD" alt="img"></p><p>​                     图12(a)  同步读操作示意图</p><p>1</p><p><img src="https:////note.youdao.com/src/4CAE98C8589D434B95B3DFA4B94D1028" alt="img"></p><p>​                     图12(b) 异步读操作示意图</p><p>1</p><p>本节从最简单的半同步/半异步模式的工作流程出发，并结合事件处理模型介绍两种演变的模式。</p><p>半同步/半异步工作流程</p><p>半同步/半异步模式的工作流程如图13 所示。</p><p><img src="https:////note.youdao.com/src/C8F33A95D4AA432A94A9D57854FE5977" alt="img"></p><p>​              图13 半同步/半异步模式的工作流程示意图</p><p>1</p><p>其中异步线程处理I/O事件，同步线程处理请求对象，简单的来说：</p><ol><li>异步线程监听到事件后，将其封装为请求对象插入到请求队列中；</li><li>请求队列有新的请求对象，通知同步线程获取请求对象；</li><li>同步线程处理请求对象，实现业务逻辑。</li></ol><p>半同步/半反应堆模式</p><p>考虑将两种事件处理模型，即Reactor和Proactor，与几种I/O模型结合在一起，那么半同步/半异步模式就演变为半同步／半反应堆模式。先看看使用Reactor的方式，如图14 所示。</p><p><img src="https:////note.youdao.com/src/249D671B15CD43F8AC5733EB176EF31A" alt="img"></p><p>​                    图14 半同步／半反应堆模式示意图</p><p>1</p><p>其工作流程为：</p><ol><li>异步线程监听所有fd上的I/O事件，若监听socket接可读，接受新的连接；并监听该连接上的读写事件；</li><li>若连接socket上有读写事件发生，异步线程将该连接socket插入请求队列中；</li><li>同步线程被唤醒，并接管连接socket，从socket上读取请求和发送应答；</li></ol><p>若将Reactor替换为Proactor，那么其工作流程为：</p><ol><li>异步线程完成I/O操作，并I/O操作的结果封装为任务对象，插入请求队列中；</li><li>请求队列通知同步线程处理任务；</li><li>同步线程执行任务处理逻辑。</li></ol><p>一种高效的演变模式</p><p>半同步／半反应堆模式有明显的缺点：</p><ol><li>异步线程和同步线程共享队列，需要保护，存在资源竞争；</li><li>工作线程同一时间只能处理一个任务，任务处理量很大或者任务处理存在一定的阻塞时，任务队列将会堆积，任务的时效性也等不到保证；不能简单地考虑增加工作线程来处理该问题，线程数达到一定的程度，工作线程的切换也将白白消耗大量的CPU资源。</li></ol><p>下面介绍一种改进的方式，如图15 所示，每个工作线程都有自己的事件循环，能同时独立处理多个用户连接。</p><p><img src="https:////note.youdao.com/src/B73C3DDD172F400C9A270FAD1E69048F" alt="img"></p><p>​                图 15 半同步／半反应堆模式的演变模式</p><p>1</p><p>其工作流程为：</p><ol><li>主线程实现连接监听，只处理网络I/O连接事件；</li><li>新的连接socket分发至工作线程中，这个socket上的I/O事件都由该工作线程处理，工作线程都可以处理多个socket 的I/O事件；</li><li>工作线程独立维护自己的事件循环，监听不同连接socket的I/O事件。</li></ol><p>Follower/Leader 模式</p><p>Follower/Leader是多个工作线程轮流进行事件监听、事件分发、处理事件的模式。</p><p>在Follower/Leader模式工作的任何一个时间点，只有一个工作线程处理成为Leader ，负责I/O事件监听，而其他线程都是Follower，并等待成为Leader。</p><p>Follower/Leader模式的工作流概述如下：</p><ol><li>当前Leader Thread1监听到就绪事件后，从Follower 线程集中推选出 Thread 2成为新的Leader；</li><li>新的Leader Thread2 继续事件I/O监听；</li><li>Thread1继续处理I/O就绪事件，执行完后加入到Follower 线程集中，等待成为Leader。</li></ol><p>从上描述，Leader/Follower模式的工作线程存在三种状态，工作线程同一时间只能处于一种状态，这三种状态为：</p><ul><li>Leader：线程处于领导者状态，负责监听I/O事件；</li><li>Processing：线程处理就绪I/O事件；</li><li>Follower：等待成为新的领导者或者可能被当前Leader指定处理就绪事件。</li></ul><p>Leader监听到I/O就绪事件后，有两种处理方式:</p><ol><li>推选出新的Leader后，并转移到Processing处理该I/O就绪事件；</li><li>指定其他Follower 线程处理该I/O就绪事件，此时保持Leader状态不变；</li></ol><p>如图16所示为上面描述的三种状态的转移关系。</p><p><img src="https:////note.youdao.com/src/0300C58B6573442BA8167AC358109B97" alt="img"></p><p>​              图16 Follower/Leader模式状态转移示意图</p><p>1</p><p>如图16所示，处于Processing状态的线程处理完I/O事件后，若当前不存在Leader，就自动提升为Leader，否则转变Follower。</p><p>从以上描述中可知，Follower/Leader模式中不需要在线程间传递数据，线程间也不存在共享资源。但很明显Follower/Leader 仅支持一个事件处理源集，无法做到图15所示的每个工作线程独立监听I/O事件。</p><p>Swoole 网络模型分析</p><p>Swoole为PHP提供I/O扩展功能，支持异步I/O、同步I/O、并发通信，并且为PHP多进程模式提供了并发数据结构和IPC通信机制；Swoole 既可以充当网络I/O服务器，也支持I/O客户端，较大程度为用户简化了网络I/O、多进程／多线程并发编程的工作。</p><p>Swoole作为server时，支持3种运行模式，分别是多进程模式、多线程模式、多进程＋多线程模式；多进程＋多线程模式是其中最为复杂的方式，其他两种方式可以认为是其特例。</p><p>本节结合之前介绍几种事件处理模型、并发模式来分析Swoole server的多进程＋多线程模型，如图17。</p><p><img src="https:////note.youdao.com/src/89BFEDF8F539474881899FE905512DE7" alt="img"></p><p>​             图17 swoole server多进程＋多线程模型结构示意图</p><p>1</p><p>图17所示，整体上可以分为Master Process、Manger Process、Work Process Pool三部分。这三部分的主要功能：</p><ol><li>Master Process：监听服务端口，接收用户连接，收发连接数据，依靠reactor模型驱动；</li><li>Manager Process：Master Process的子进程，负责fork WorkProcess，并监控Work Process的运行状态；</li><li>Work Process Pool：工作进程池，与PHP业务层交互，将客户端数据或者事件（如连接关闭）回调给业务层，并将业务层的响应数据或者操作（如主动关闭连接）交给Master Process处理；工作进程依靠reactor模型驱动。</li></ol><p>Manager Process 监控Work Process进程，本节不做进一步讲解，主要关注Master和Work。</p><p>Master Process</p><p>Master Process 内部包括主线程(Main Thread)和工作线程池(Work Thread Pool),这两部分主要功能分别是：</p><p>主线程: 监听服务端口，接收网络连接，将成功建立的连接分发到线程池中；依赖reactor模型驱动；</p><p>工作线程池: 独立管理连接，收发网络数据；依赖Reactor事件处理驱动。</p><p>顾一下前面介绍的半同步/半异步并发模式，很明显，主进程的工作方式就是图15所示的方式。</p><p>Work Process</p><p>如上所描述，Work Process是Master Process和PHP层之间的媒介：</p><ol><li>Work Process接收来自Master Process的数据，包括网络数据和连接事件，回调至PHP业务层；</li><li>将来自PHP层的数据和连接控制信息发送给Master Process进程，Master Process来处理。</li></ol><p>Work Process同样是依赖Reactor事件模型驱动，其工作方式一个典型的Reactor模式。</p><p>Work Process作为Master Process和PHP层之间的媒介，将数据收发操作和数据处理分离开来，即使PHP层因消息处理将Work进程阻塞一段时间，也不会对其他连接有影响。</p><p>从整体层面来看，Master Process实现对连接socket上数据的I/O操作，这个过程对于Work Process是异步的，结合图11 所描述的同步I/O模拟Proactor模式，两种方式如出一辙，只不过这里使用的是多进程。</p><p>进程间通信</p><p>Work Process是Master Process和PHP层之间的媒介，那么需要看看Work Process 与Master Process之间的通信方式，并在Swoole server 的多进程＋多线程模型进程中，整个过程还是有些复杂，下面说明一下该流程，如图18所示。</p><p><img src="https:////note.youdao.com/src/76B546B115CB4361B342121A82049291" alt="img"></p><p>​                图18 swoole server 多进程多线程通信示意图</p><p>1</p><p>具体流程为：</p><ol><li>Master 进程主线程接收客户端连接，连接建立成功后，分发至工作线程，工作线程通过Unix Socket通知Work进程连接信息；</li><li>Work 进程将连接信息回调至PHP业务层；</li><li>Maser 进程中的工作线程接收客户端请求消息，并通过Unix Socket方式发送到Work进程；</li><li>Work 进程将请求消息回调至PHP业务层；</li><li>PHP业务层构造回复消息，通过Work进程发送，Work进程将回复消息拷贝至共享内存中，并通过Unix Socket通知发送至Master进程的工作线程有数据需要发送；</li><li>工作线程从共享内存中取出需发送的数据，并发送至客户端；</li><li>客户端断开连接，工作线程将连接断开的事件通过UnixSocket发送至Work进程；</li><li>Work进程将连接断开事件回调至PHP业务层.</li></ol><p>需要注意在步骤5中，Work进程通知Master进程有数据需要发送，不是将数据直接发送给Master进程，而是将数据地址(在共享内存中)发送给Master进程。</p><p>改善性能的方法</p><p>性能对于服务器而言是非常敏感和重要的，当前，硬件的发展虽然不是服务器性能的瓶颈，作为软件开发人员还是应该考虑在软件层面来上改善服务性能。好的网络模块，除了稳定性，还有非常多的细节、技巧处理来提升服务性能，感兴趣的同学可以深入了解Ngnix源码的细节，以及陈硕的《Linux多线程服务器编程》。</p><p>数据复制</p><p>如果应用程序不关心数据的内容，就没有必要将数据拷贝到应用缓冲区，可以借助内核接口直接将数据拷贝到内核缓冲区处理，如在提供文件下载服务时，不需要将文件内容先读到应用缓冲区，在调用send接口发送出去，可以直接使用sendfile （零拷贝）接口直接发送出去。</p><p>应用程序的工作模块之间也应该避免数据拷贝，如：</p><ol><li>当两个工作进程之间需要传递数据，可以考虑使用共享内存的方式实现数据共享；</li><li>在流媒体的应用中，对帧数据的非必要拷贝会对程序性能的影响，特备是在嵌入式环境中影响非常明显。通常采用的办法是，给每帧数据分配内存（下面统称为buffer），当需要使用该buffer时，会增加该buffer的引用计数，buffer的引用计数为0时才会释放对应的内存。这种方式适合在进程内数据无拷贝传递，并且不会给释放buffer带来困扰。</li></ol><p>资源池</p><p>在服务运行期间，需要使用系统调用为用户分配资源，通常系统资源的分配都是比较耗时的，如动态创建进程／线程。可以考虑在服务启动时预先分配资源，即创建资源池，当需要资源，从资源池中获取即可，若资源池不够用时，再动态的分配，使用完成后交还到资源池中。这实际上是用空间换取时间，在服务运行期间可以节省非必要的资源创建过程。需要注意的是，使用资源池还需要根据业务和硬件环境对资源池的大小进行限制。</p><p>资源池是一个抽象的概念，常见的包括进程池、线程池、 内存池、连接池；这些资源池的相关资料非常多，这里就不一一介绍了。</p><p>锁/上下文切换</p><p>1.关于锁</p><p>对共享资源的操作是并发程序中经常被提起的一个话题，都知道在业务逻辑上无法保证同步操作共享资源时，需要对共享资源加锁保护，但是锁不仅不能处理任何业务逻辑，而且还存在一定的系统开销。并且对锁的不恰当使用，可能成为服务期性能的瓶颈。</p><p>针对锁的使用有如下建议：</p><ol><li>如果能够在设计层面避免共享资源竞争，就可以避免锁，如图15描述的模式;</li><li>若无法避免对共享资源的竞争，优先考虑使用无锁队列的方式实现共享资源；</li><li>使用锁时，优先考虑使用读写锁；此外，锁的范围也要考虑，尽量较少锁的颗粒度，避免其他线程无谓的等待。</li></ol><p>2.上下文切换</p><p>并发程序需要考虑上下文切换的问题，内核调度线程(进程)执行是存在系统开销的，若线程(进程)调度占用CPU的时间比重过大，那处理业务逻辑占用的CPU时间就会不足。在项目中，线程(进程)数量越多，上下文切换会很频繁，因此是不建议为每个用户连接创建一个线程，如图15所示的并发模式，一个线程可同时处理多个用户连接，是比较合理的解决方案。</p><p>多核的机器上，并发程序的不同线程可以运行在不同的CPU上，只要线程数量不大于CPU数目，上下文切换不会有什么问题，在实际的并发网络模块中，线程(进程)的个数也是根据CPU数目来确定的。在多核机器上，可以设置CPU亲和性，将进程／线程与CPU绑定，提高CPU cache的命中率，建好内存访问损耗。</p><p>有限状态机器</p><p>有限状态机是一种高效的逻辑处理方式，在网络协议处理中应用非常广泛，最典型的是内核协议栈中TCP状态转移。有限状态机中每种类型对应执行逻辑单元的状态，对逻辑事务的处理非常有效。有限状态机包括两种，一种是每个状态都是相互独立的，状态间不存在转移；另一种就是状态间存在转移。有限状态机比较容易理解，下面给出两种有限状态机的示例代码。</p><p>不存在状态转移</p><p>typedefenum _tag_state_enum{      A_STATE,    B_STATE,    C_STATE,    D_STATE}state_enum;voidSTATE_MACHINE_HANDLER(state_enum cur_state){    switch (cur_state){    case A_STATE:         process_A_STATE();         break;    case B_STATE:         process_B_STATE();         break;    case C_STATE:         process_C_STATE();         break;    default:         break;    }    return ;}</p><p>1234567891011121314151617181920212223242526</p><p>存在状态转移</p><p>voidTRANS_STATE_MACHINE_HANDLER(state_enum cur_state){    while (C_STATE != cur_state) {        switch (cur_state) {        case A_STATE:            process_A_STATE();            cur_state = B_STATE;            break;        case B_STATE:            process_B_STATE();            cur_state = C_STATE;            break;        case C_STATE:            process_C_STATE();            cur_state = D_STATE;            break;        default:            return ;      }   }   return ;}</p><p>123456789101112131415161718192021222324252627</p><p>时间轮</p><p>经常会面临一些业务定时超时的需求，用例子来说明吧。</p><p>功能需求：服务器需要维护来自大量客户端的TCP连接（假设单机服务器需要支持的最大TCP连接数在10W级别），如果某连接上60s内没有数据到达，就认为相应的客户端下线。</p><p>先介绍一下两种容易想到的解决方案,</p><p>方案a轮询扫描</p><p>处理过程为：</p><ol><li>维护一个map 记录客户端最近一次的请求时间；</li><li>当client_id对应连接有数据到达时，更新last_update_time；</li><li>启动一个定时器，轮询扫描map 中client_id 对应的last_update_time，若超过 60s，则认为对应的客户端下线。</li></ol><p>轮询扫描，只启动一个定时器，但轮询效率低，特别是服务器维护的连接数很大时，部分连接超时事件得不到及时处理。</p><p>方案b多定时器触发</p><p>处理过程为：</p><ol><li>维护一个map 记录客户端最近一次的请求时间；</li><li>当某client_id 对应连接有数据到达时，更新last_update_time，同时为client_id启用一个定时器，60s后触发;</li><li>当client_id对应的定时器触发后，查看map中client_id对应的last_update_time是否超过60s，若超时则认为对应客户端下线。</li></ol><p>多定时器触发，每次请求都要启动一个定时器，可以想象，消息请求非常频繁是，定时器的数量将会很庞大，消耗大量的系统资源。</p><p>方案c 时间轮方案</p><p>下面介绍一下利用时间轮的方式实现的一种高效、能批量的处理方案，先说一下需要的数据结构：</p><ol><li>创建0~60的数据，构成环形队列time_wheel，current_index维护环形队列的当前游标，如图19所示；</li><li>数组元素是slot 结构，slot是一个set，构成任务集；</li><li>维护一个map，记录client_id 落在哪个slot上。</li></ol><p><img src="https:////note.youdao.com/src/C5981CB237A048868220D6C27354F990" alt="img"></p><p>​                     图19 时间轮环形队列示意图</p><p>1</p><p>执行过程为：</p><ol><li>启用一个定时器，运行间隔1s，更新current_index，指向环形队列下一个元素，0-&gt;1-&gt;2-&gt;3…-&gt;58-&gt;59-&gt;60…0；</li><li>连接上数据到达时，从map中获取client_id所在的slot，在slot的set中删除该client_id；</li><li>将client_id加入到current_index - 1锁标记的slot中；</li><li>更新map中client_id 为current_id-1 。</li></ol><p>与a、b两种方案相比，方案c具有如下优势：</p><ol><li>只需要一个定时器，运行间隔1s，CPU消耗非常少；</li><li>current_index 所标记的slot中的set不为空时，set中的所有client_id对应的客户端均认为下线，即批量超时。</li></ol><p>上面描述的时间轮处理方式会存在1s以内的误差，若考虑实时性，可以提高定时器的运行间隔，另外该方案可以根据实际业务需求扩展到应用中。我们对Swoole的修改中，包括对定时器进行了重构，其中超时定时器采用的就是如上所描述的时间轮方案，并且精度可控。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异步网络模型&quot;&gt;&lt;a href=&quot;#异步网络模型&quot; class=&quot;headerlink&quot; title=&quot;异步网络模型&quot;&gt;&lt;/a&gt;异步网络模型&lt;/h1&gt;&lt;p&gt;异步网络模型在服务开发中应用非常广泛，相关资料和开源库也非常多。项目中，使用现成的轮子提高了开发效率，除了能使用轮子，还是有必要了解一下轮子的内部构造。&lt;/p&gt;
&lt;p&gt;这篇文章从最基础的5种I/O模型切入，到I/O事件处理模型，再到并发模式，最后以Swoole开源库来做具体分析，逐步深入。文中提到的模型都是一些通用的模型，在《linux高性能服务器编程》中也都有涉及。文章不涉及模型的实现细节，最重要的是去理解各个模型的工作模式以及其优缺点。&lt;/p&gt;
&lt;p&gt;读后感：&lt;/p&gt;
&lt;p&gt;所谓异步：&lt;/p&gt;
&lt;p&gt;1.(fd)阻塞调用 + select/pool, epool  （IO事件通知方式：IO复用）&lt;/p&gt;
&lt;p&gt;2.(fd)非阻塞调用 + SIGIO （IO事件通知方式：SIGIO 信号）&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="I/O" scheme="https://akaqin.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>arts-7.md</title>
    <link href="https://akaqin.github.io/2018/09/23/arts-7/"/>
    <id>https://akaqin.github.io/2018/09/23/arts-7/</id>
    <published>2018-09-23T06:57:22.000Z</published>
    <updated>2020-03-07T12:43:30.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    用递归的思想一点一点地合并，时间复杂度是O(n+m)，空间复杂的也是O(n+m) 。写的时候遇到一个以前没有注意到的小坑，就是C语言里是没有elseif这个关键字的，esle和if之间必须有空格，不然会编译失败，</p><h4 id="Approach-2-Iteration"><a href="#Approach-2-Iteration" class="headerlink" title="Approach 2: Iteration"></a>Approach 2: Iteration</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prehead</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">prehead</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            prev-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    迭代l1和l2头上的元素进行比较，每次取出较小的一个放入一个新链表，并更新较小的那个元素所在的链表的指针，使其指向下一个元素，重复上一步骤，直至其中一个链表为空，把另一个链表剩下的部分拼到新链表后面，并返回新链表。</p><p>​    时间复杂度为O(n+m)，因为while循环的次数相当于两个链表的长度之和（忽略剩余的部分），是线性的。</p><p>​    空间复杂度是O(1)，迭代算法只是分配了几个指针，具有恒定的总内存占用量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-6.md</title>
    <link href="https://akaqin.github.io/2018/09/16/arts-6/"/>
    <id>https://akaqin.github.io/2018/09/16/arts-6/</id>
    <published>2018-09-16T01:55:29.000Z</published>
    <updated>2020-03-07T12:43:22.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> limit = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(limit);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cur = s[i];</span><br><span class="line">        <span class="keyword">if</span> ((cur == <span class="string">'('</span>) || (cur == <span class="string">'['</span>) || (cur == <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == limit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[idx++] = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((cur == <span class="string">'&#125;'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'&#123;'</span>)</span><br><span class="line">                || (cur == <span class="string">']'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'['</span>)</span><br><span class="line">                || (cur == <span class="string">')'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'('</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> idx == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"(([]))"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">isValid</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    parentheses := <span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">rune</span>&#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">'('</span> || char == <span class="string">'['</span> || char == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; parentheses[char] == stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题比较简单，解题思路比较单一（也可能是我没看到别的思路），用一个栈去从左到右的读取字符串，遇到左括号就入栈，右括号就判断与前一个是否对应，是的话就出栈，否的话就报错，直至读取完没有遇到错误的话idx的值应该等于0。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt; and &lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt;, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;An input string is valid if:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open brackets must be closed by the same type of brackets.&lt;/li&gt;
&lt;li&gt;Open brackets must be closed in the correct order.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that an empty string is also considered valid.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;()&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;()[]&amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;(]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>指针学习笔记</title>
    <link href="https://akaqin.github.io/2018/09/09/%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://akaqin.github.io/2018/09/09/%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2018-09-09T02:36:27.000Z</published>
    <updated>2020-03-08T07:43:29.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言指针的总结"><a href="#C语言指针的总结" class="headerlink" title="C语言指针的总结"></a>C语言指针的总结</h1><p>原文出自xx_cc</p><p>链接：<a href="https://www.jianshu.com/p/63f3bfb58687" target="_blank" rel="noopener">https://www.jianshu.com/p/63f3bfb58687</a></p><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ol><li>不同类型的变量在内存中占据不同的字节空间。</li><li>内存中存储数据的最小基本单位是字节，每一个字节都有一个内存地址，这个地址是一个十六进制的数。</li><li>声明一个变量，在内存中是从高字节向低字节分配连续的指定字节数的空间。</li><li>任何数据在内存中都是以其二进制的补码形式存储的，低位存储在低字节，高位存储在高字节。</li><li>变量的值：存储在变量中的数据，叫做变量的值。</li><li>变量的地址：一个变量是由一个或者多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址。</li><li>如何取出变量的地址：使用&amp;（取地址运算符）运算符，&amp;变量名；这个表达式的值就是这个变量的地址。使用%p控制度输出变量的地址。</li><li>什么是指针：变量的地址叫做指针，指针就是地址，地址就是指针。</li></ol><p>下面通过一张图可以更直观的理解内存中的地址</p><p><img src="https:////upload-images.jianshu.io/upload_images/1434508-3146d4e4c4362be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p><p>内存中的地址演示图</p><a id="more"></a><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><ol><li>指针是C语言的灵魂。指针变量占据8个字节。</li><li>变量在内存中的存储。<br> 变量的值：存储在变量中的数据，叫做变量的值。<br> 变量的地址：组成这个变量的低字节的地址，就是这个变量的地址。</li><li>取出变量的地址，用&amp;运算符 %p输出变量的地址。</li><li>变量的地址就叫做指针，我们可以使用一个指针变量来存储变量的地址。</li></ol><h5 id="指针变量："><a href="#指针变量：" class="headerlink" title="指针变量："></a>指针变量：</h5><ol><li>指针变量就是专门用来存储 <strong>地址</strong> 的变量，那么我们就说指针变量指向了另外一个变量，存储着另外一个变量的地址。</li><li>指针可以使访问一个变量的方式分为两种。<br> a. 直接访问<br> b. 可以通过指针变量，找到这个指针指向的变量<br> 所以通过指针变量可以间接的访问指针变量指向的另外一个变量。</li><li><strong>如何声明一个专门用来存储地址的指针变量</strong><br> 数据类型  <code>*</code> 指针变量的名称   — <code>int * p1;</code><br> 指针变量的名字叫做p1，这个指针变量的类型是<code>int*</code> 读作int指针。<br> <code>*</code>表示这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量，所以有哪些普通的数据类型，就可以有哪些类型的指针。<br> 声明的时候注意，<code>*</code>的位置 建议  <code>int* p</code>这样提醒我们这是一个<code>int*</code>类型的指针。<br> ** 一个指针变量并不是可以存储任意类型的变量的地址，而是有限定的，只能存储和这个指针类型相同的普通变量的地址。** 所以<code>p</code> 指针变量中只能存储<code>int</code>类型变量的地址。</li><li>指针变量的初始化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; 10;</span><br><span class="line">int *p &#x3D;  &amp;num; 建议int* p &#x3D; &amp;num;这样写</span><br></pre></td></tr></table></figure><p>p指针指向了num变量。因为p指针的值就是num变量的地址，不能直接赋值一个非地址类型的常量数据，也不能直接赋值一个变量给指针。</p><ol><li>p指针自己也有地址， 因为指针变量也是一个变量，&amp;p取到指针p的地址。</li><li>p操作的是p这个指针变量，可以取p得值，也可以为p赋值</li><li><strong>指针变量的使用</strong><br> 可以使用指针间接的操作指针指向的变量。<br> <code>*p</code> 代表 <code>p</code> 指针指向的变量。<br> <code>*p</code> 完全等价于<code>num</code> 即 <code>*p = 100</code> 完全等价于 <code>num = 100</code>。<br> <code>*p = 100;</code> 表示将100赋值给p指针指向的变量，也就是num变量</li></ol><p>使用指针变量的时候注意点<br> <code>int* p1 ,p2, p3 ;</code> 此时<code>p1</code>是<code>int *</code>指针，而<code>p2,p3</code>是<code>int</code>类型数据 如果希望全部都是指针需要 <code>int *p1, * p2, * p3;</code></p><ol><li><strong>野指针</strong><br> 我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量中是有值的，是<strong>垃圾值，随机数</strong>。因为这个时候，这个指针变量有可能指向了一块<strong>随机的空间</strong>，这个空间可能无人使用，也可能别的程序在用，也可能系统在用，这个时候，去访问指针指向的的变量的时候，就会报错。<strong>BAD_ACCESS</strong>坏地址访问错误，像这样的指针我们就叫做野指针。</li><li>NULL值 完全等价于0<br> 为了防止野指针的产生，建议声明一个指针变量后，最好为其初始化，如果没有变量的地址初始化给这个指针变量。那么就初始化一个<strong>NULL</strong>值。NULL值代表指针变量不指向内存中的任何地址，这样就不会出现野指针，<strong>NULL完全等价于0</strong>，所以也可以直接赋值给一个指针变量0。<br> 如果一个指针变量的值是NULL，那么去访问这个指针指向的变量的时候一定会报错。</li><li>多个指针指向同一个变量，修改其中一个所有指针指向的值都会改变。因为多个个指针指向的是同一块地址。即 <code>*</code> 会使指针间接的操作指针指向的变量。</li><li><strong>指针作为函数的参数</strong><br> 如果函数的参数是一个指针，那么就必须要为这个<strong>指针</strong>传递一个和<strong>指针类型相同的普通变量的地址</strong>，这个时候，在函数的内部去访问参数指针的变量的时候，其实访问的就是实参变量</li><li><strong>指针作为函数的参数，可以实现什么效果？</strong><br> 函数的内部可以修改实参变量的值。那么什么时候使用指针作为参数呢？<br> 一般函数只能返回一个数据，那么当函数需要返回<strong>多个数据</strong>的时候就可以使用<strong>指针作为参数</strong>，让<strong>调用者将自己的变量的地址传递给函数内部，函数内部通过指针就可以修改参数</strong>，函数无需将数值传回来，就已经修改了参数的值。其实scanf函数传递的就是指针，<strong>因此当函数需要多个返回值的时候就可以使用指针作为参数。</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从下面代码中就可以看出，我们可以直接在函数中修改两个变量的值。相当于函数有两个返回值。</span><br><span class="line">void  changeValue (int* p1 ,int* p2)&#123;</span><br><span class="line">    *p1 &#x3D; 100;</span><br><span class="line">    *p2 &#x3D; 200;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int num1 &#x3D; 1;</span><br><span class="line">    int num2 &#x3D; 2;</span><br><span class="line">    changeValue(&amp;num1, &amp;num2);</span><br><span class="line">    printf(&quot;num1 &#x3D; %d\n&quot;,num1);</span><br><span class="line">    printf(&quot;num2 &#x3D; %d&quot;,num2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>指针为什么要分类型</strong><br> <strong>指针变量既然是一个变量就要在内存中占用字节空间</strong><br> 指针变量在内存中占据多少字节数？<br> <strong>无论指针是什么类型在内存中都是占据8个字节。</strong><br> 那为什么指针还要分类呢？<br> p指针变量中存储的是num变量的地址，也就是num变量低字节的地址，<strong>通过p指针只能找到这个地址的字节</strong>，这个时候，通过p指针找到这个字节，操作的时候，操作多少个字节是则是根据<strong>指针的类型</strong>来决定的。<br> <strong>所以指针变量的类型决定了通过这个指针找到字节以后，连续操作多少个字节空间。</strong><br> int 指针 连续操作4个字节空间<br> double 指针 连续操作8个字节空间<br> float 指针  连续操作4个字节空间<br> char 指针  连续操作1个字节空间<br> 因此，指针的类型如果不和指向的变量的类型相同的话，那么通过指针就无法正确的操作指向的变量，所以，<strong>指针的变量一定要指向一个和自己类型相同的普通变量才可以。</strong></li></ol><p>   <img src="https:////upload-images.jianshu.io/upload_images/1434508-a35b6912864b9740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="img"></p><p>   指针为什么要分类型？</p><ol start="2"><li><p>多级指针<br> 一个指针变量中存储的是一个一级指针的地址，那么它就是二级指针，一个指针变量中存储的是一个二级指针的地址，那么它就是三级指针。<br> 二级指针：<code>数据类型 ** 指针名</code><br> 二级指针只能存储一级指针变量的地址。<br> 多级指针在开发中很少用到，遇到多级指针耐心分析一定可以理清其中的关系。</p></li><li><p>指针与整数的加减法<br> 指针可以和整数进行加减运算，指针+1并不是在指针地址的基础之上加一个字节的地址，而是在这个<strong>指针地址的基础之上加一个单位变量占用的字节数</strong>，例如：如果指针类型是<code>int *</code> 则+1代表加4个字节地址，以此类推。</p></li><li><p><strong>指针与数组</strong><br> 我们可以使用指针来遍历数组，因为数组的本质其实就是指针，当我们创建数组的时候，系统会在内存中由高地址向低地址分配连续的类型所占的空间字节数 * 数组内元素的个数的字节控件。而数组名则代表了数组的低字节地址，也就是数组的地址。<br> 1). 使用指针遍历数组的第一种方式.<br> int arr[7] = {10,20,30,40,50,60,70}; //在内存中高地址向低地址分配连续的 类型所占的空间字节数 * 数组内元素的个数 7 * 4 = 28 个字节空间<br> int* p1 = arr;    //p1指针指向了数组的第0个元素.<br> for(int i = 0; i &lt; 7; i++)<br> {<br> printf(“%d\n”,*(p1+i));<br> }</p><p>2). 使用指针遍历数组的第二种方式.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(arr+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3). 使用指针遍历数组的第三种方式.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">int* p1 &#x3D; arr;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(p1++));</span><br><span class="line">&#125;</span><br><span class="line">注意的地方,每次循环,p1的值都会变化。</span><br><span class="line">最后1次执行完毕之后,p1指针指向数组外面去了,p1就不再执行数组中的任何元素了。</span><br></pre></td></tr></table></figure><p>注意: 数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变。<br> 所以，我们不能为数组名赋值也不能修改数组名的值，但是可以使用数组名的值。<br> <strong>arr是数组的地址，也是数组中第0个元素的地址，arr+1就是数组中第一个元素的地址，数据名就是一个地址常量，无法改变。</strong></p></li><li><p><strong>数组作为函数的参数的本质</strong><br> 当数组作为函数的参数的时候，在声明这个参数数组的时候，并不是去创建一个数组，而是去创建一个用来存储地址的指针变量，如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组变成了指针，这也就是为什么我们通过sizeof计算参数数组得到的永远都是8，所以以后我们的函数如果带了一个数组参数，建议直接写一个指向数组的第0个元素的指针，在传入数组的长度</p></li><li><p><strong>索引的本质</strong><br> <strong>指针变量后面可以使用中括号，在中括弧中写上下标来访问数据。</strong><br> <code>p[n];</code>前提<code>p</code>是一个指针变量，完全等价于<code>*(p + n);</code><br> 所以<code>arr[0]</code> 就等价于 <code>* [arr + 0]</code>。<br> 操作数组我们虽然使用中括弧下标来操作，实际上内部本质仍然是使用的指针来操作。</p></li><li><p>存储指针的数组<br> 如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组<br> 格式 ：<code>元素类型 数组名[数组长度];</code> <code>int * arr[3];</code><br> arr数组里面存储int指针数据，最多存储3个。</p></li><li><p>指针与指针之间的减法运算<br> 指针与指针之间可以做减法运算，结果是一个long类型的数据，<br> 结果的意义代表两个指针指向的变量之间相差多少个单位变量，绝大多数情况下，我们用在判断数组的两个元素之间相差多少个元素<br> 如果参与减法运算的两个指针不指向同一个数组，结果就会出现问题<br> <strong>结果 = 两个指针的差 / 每一个指针变量对应的普通变量占用的字节数。</strong><br> 并且只能做减法运算，<strong>用在数组当中判断两个元素之间相差多少个元素。</strong></p></li><li><p>指针与指针在之间的比较运算 <code>&lt;, &lt;=, &gt;, &gt;=, ==, !=</code>都可以使用<br> 可以用来判断两个指针指向的变量的字节，谁在高字节，谁在低字节。或者两个指针的地址是不是同一个地址。</p></li><li><p><strong>指针和字符变量</strong><br> <code>char *name = &quot;jack&quot;;</code>表示直接将一个字符串数据初始化给一个字符指针。</p><p><strong>字符指针存储和字符数组存储的区别</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符数组存储：将字符串数据的每一个字符存储到字符数组的元素中，并追加一个 \n 表示结束</span><br><span class="line">char name[5] &#x3D; &quot;jack&quot;;</span><br><span class="line">&#x2F;&#x2F; 直接为字符指针初始化一个字符串数据</span><br><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">1.) 当他们都是局部变量的时候</span><br></pre></td></tr></table></figure><p><strong>字符数组</strong>是申请在栈区的，字符串的每一个字符存储在字符数组的每一个元素中。<br> <strong>指针变量</strong>是声明在栈区的。但是此时字符串数据是以字符数组的形式存储在<strong>常量区</strong>的。此时<strong>指针变量中存储的是字符串在常量区的地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.) 当他们作为全局变量的时候</span><br></pre></td></tr></table></figure><p><strong>字符数组</strong>是存储在常量区的，字符串的每一个字符存储在这个数组中的每一个元素中。<br> <strong>字符指针</strong>也是存储在常量区，字符串也是以字符数组的形式存储在常量区，<strong>指针中存储的是字符串在常量区的地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**以字符数组存储的字符串数据，可以修改字符数组的元素。可变</span><br><span class="line">以字符指针的形式存储字符串数据，这个时候字符指针指向的字符串数据是无法修改的，不可变**</span><br></pre></td></tr></table></figure><ol><li><p><strong>字符串的恒定型</strong><br> 前提：<strong>以字符指针形式存储的字符串</strong><br> 1.) 当我们以字符指针的形式存储字符串的时候，无论如何，字符串数据是存储在常量区的，并且，一旦存储到常量去中去，这个字符串数据就无法更改。</p><p>2.) 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储到常量区中。</p><p>3.) 当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，因为原来的字符串数据是不可更改的，而是重新的创建了一个字符串，把这个新的字符串的地址赋给他。建议使用字符指针来存储字符串数据。优势：长度任意。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">nsme &#x3D; &quot;rose&quot;;</span><br><span class="line">&#x2F;&#x2F; 这样可以 但是并不是把jack改成了rose，而是重新创建了一个&quot;rose&quot;,把rose地址赋值给name</span><br></pre></td></tr></table></figure><ol><li>字符串数组<br> <code>char *names[4] = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};</code><br> names数组的元素的类型是char指针，初始化给元素的字符串数据是存储在常量区的。元素中存储的是<strong>字符串在常量区的地址</strong><br> 因此这是一个存储指针的数组，每一个元素的类型是一个指针，占用得内存为8个字节。</li><li>指向函数的指针。<br> 程序在运行的时候，会将程序加载到内存，内存的代码段中主要存储的就是程序的代码，而程序的代码就包括函数。<strong>既然函数要存储在内存中，那么肯定要用1块空间来存储，那么这个块空间一定有1个地址。</strong><br> 因此我们就可以<strong>声明1个指针用来存储这个函数的地址</strong>，也就是说让这个指针指向这个函数。这样我们就可以使用<strong>指针来间接的调用函数</strong>。<br> 优势: 调用函数有了两种方式。<br> 1.) 直接使用函数名调用<br> 2.) 使用指向函数的指针间接调用.</li><li>指向函数的指针的声明<br> 一个指向函数的指针，并不是任意的函数都可以指向，而是有限定的，要求指向的<strong>函数的返回值类型和参数描述必须要与指针的描述一样</strong>。<br> 声明语法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*指针名)([参数列表]);</span><br><span class="line">void (*pFunction)();</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFunction。</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向没有返回值,并且没有参数的函数。</span><br><span class="line">int (*pFun)(int num1,int num2);</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFun.</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向返回值为int类型 并且有两个整型的参数的函数.</span><br></pre></td></tr></table></figure><ol><li><strong>指向函数的指针的初始化</strong><br><strong>函数的名称就代表函数的地址，因此我们直接将符合条件的函数的名称赋值给这个指针。</strong><br>并且我们有两种方法可以通过指针来调用这个函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int MaxValue (int a, int b)&#123;</span><br><span class="line">       return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;    </span><br><span class="line">       int(*pMaxValue)(int a, int b) &#x3D; MaxValue; &#x2F;&#x2F; 创建一个返回int 并且有两个int型参数的函数指针，并赋值。</span><br><span class="line">       printf(&quot;%d\n&quot;, pMaxValue(5,10)); &#x2F;&#x2F; 通过指针调用函数方法1</span><br><span class="line">       printf(&quot;%d\n&quot;,(*pMaxValue)(6,9)); &#x2F;&#x2F; 通过指针调用函数方法2</span><br><span class="line">       printf(&quot;%d\n&quot;,MaxValue(9, 13)); &#x2F;&#x2F; 调用函数</span><br><span class="line">       printf(&quot;%p\n&quot;,MaxValue); &#x2F;&#x2F; 输出函数的地址</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C语言指针的总结&quot;&gt;&lt;a href=&quot;#C语言指针的总结&quot; class=&quot;headerlink&quot; title=&quot;C语言指针的总结&quot;&gt;&lt;/a&gt;C语言指针的总结&lt;/h1&gt;&lt;p&gt;原文出自xx_cc&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.jianshu.com/p/63f3bfb58687&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/63f3bfb58687&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-变量&quot;&gt;&lt;a href=&quot;#1-变量&quot; class=&quot;headerlink&quot; title=&quot;1. 变量&quot;&gt;&lt;/a&gt;1. 变量&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不同类型的变量在内存中占据不同的字节空间。&lt;/li&gt;
&lt;li&gt;内存中存储数据的最小基本单位是字节，每一个字节都有一个内存地址，这个地址是一个十六进制的数。&lt;/li&gt;
&lt;li&gt;声明一个变量，在内存中是从高字节向低字节分配连续的指定字节数的空间。&lt;/li&gt;
&lt;li&gt;任何数据在内存中都是以其二进制的补码形式存储的，低位存储在低字节，高位存储在高字节。&lt;/li&gt;
&lt;li&gt;变量的值：存储在变量中的数据，叫做变量的值。&lt;/li&gt;
&lt;li&gt;变量的地址：一个变量是由一个或者多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址。&lt;/li&gt;
&lt;li&gt;如何取出变量的地址：使用&amp;amp;（取地址运算符）运算符，&amp;amp;变量名；这个表达式的值就是这个变量的地址。使用%p控制度输出变量的地址。&lt;/li&gt;
&lt;li&gt;什么是指针：变量的地址叫做指针，指针就是地址，地址就是指针。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面通过一张图可以更直观的理解内存中的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:////upload-images.jianshu.io/upload_images/1434508-3146d4e4c4362be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;内存中的地址演示图&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点总结" scheme="https://akaqin.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
      <category term="pointer" scheme="https://akaqin.github.io/tags/pointer/"/>
    
  </entry>
  
  <entry>
    <title>arts-5</title>
    <link href="https://akaqin.github.io/2018/08/12/arts-5/"/>
    <id>https://akaqin.github.io/2018/08/12/arts-5/</id>
    <published>2018-08-12T11:20:52.000Z</published>
    <updated>2020-03-07T12:43:13.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>All given inputs are in lowercase letters <code>a-z</code>.</p><a id="more"></a><p><strong>Solution:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">char</span> **strs, <span class="keyword">int</span> strsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strsSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    先通过把第一个字符串跟每个字符串比较的方式计算出公共前缀的长度</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]); <span class="keyword">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (tempIndex = <span class="number">0</span>; tempIndex &lt; index; tempIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][tempIndex] != strs[i][tempIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        当tempIndex &lt; Index时，可以更新Index来省去多余的计算</span></span><br><span class="line">        <span class="keyword">if</span> (tempIndex &lt; index) &#123;</span><br><span class="line">            index = tempIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算出前缀长度后，字符串数据是存储在常量区的，不能直接更改，所以要为前缀申请内存空间并付值，+1是为了留出'\0'的位置</span></span><br><span class="line">    <span class="keyword">char</span> *prefix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (index + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">strncpy</span>(prefix, strs[<span class="number">0</span>], index);</span><br><span class="line">    prefix[index] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arr[] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = longestCommonPrefix(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Summary:</strong></p><p>这是一个比较容易想到的思路，时间复杂度的是O(n^2)，不算快；空间复杂度是O(1)。可以优化的点有两个：tempIndex小于Index时更新Index，减少不必要的比较；计算出前缀的长度再去为变量申请空间，会比一上来就申请strs[0]大小的空间之后再截断的方式好一些。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">fst := strs[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> carry <span class="keyword">string</span></span><br><span class="line">L0:</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> fst &#123;</span><br><span class="line">t := fst[<span class="number">0</span> : i+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasPrefix(v, t) &#123;</span><br><span class="line"><span class="keyword">break</span> L0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(carry) &#123;</span><br><span class="line">carry = t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> carry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://angular.io/guide/architecture-services" target="_blank" rel="noopener">Angular:Introduction to services and dependency injection</a></p><p>Components consume services; that is, you can inject a service into a component, giving the component access to that service class.</p><p>组件使用服务。换句话说，你可以把某个服务注入到组件中，从而使得这个组件可以访问到该服务。</p><p>Dependency injection (often called DI) is wired into the Angular framework and used everywhere to provide new components with the services or other things they need.</p><p>依赖注入，经常被简称为DI，在Angular中被广泛使用。你几乎可以在任何地方，看见他们为各类组件提供所需的服务。</p><p>The injector maintains a container of dependency instances that it has already created, and reuses them if possible.</p><p>注入器维护着一个容器，这个容器中是各类已经被创建过的依赖的实例。如果可能的话，注入器会优先复用这些实例。</p><p>A provider is a recipe for creating a dependency. For a service, this is typically the service class itself. For any dependency you need in your app, you must register a provider with the app’s injector, so that the injector can use it to create new instances.</p><p>“提供者”是创建依赖时所使用的机制。对于普通服务来说，“提供者”通常就是服务类本身。但对于应用中所需的其他依赖来说，你必须通过“注入器”注册一个“提供者”，以便注入器可以使用该“提供者”创建新的实例。</p><p>When Angular discovers that a component depends on a service, it first checks if the injector already has any existing instances of that service.</p><p>当Angular发现一个组件依赖于某个服务时，它会先去检查“注入器”中是否已经有了这个服务的实例。</p><p>If a requested service instance does not yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</p><p>如果被请求的服务实例不存在，那么“注入器”就会用注册过的“提供者”创建一个新的实例，然后把它加入到“注入器”中，并把这个实例返回给Angular。</p><h2 id="SHARE"><a href="#SHARE" class="headerlink" title="SHARE"></a>SHARE</h2><h3 id="关于-typedef-的一些理解"><a href="#关于-typedef-的一些理解" class="headerlink" title="关于 typedef 的一些理解"></a>关于 typedef 的一些理解</h3><ol><li>表达方式简洁。</li><li>可以使程序参数化，提高程序的可移植性。如果 typedef 声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需要改变 typedef 类型定义就可以了。</li><li>为程序提供更好的说明性——Treeptr 类型显然比一个声明为指向复杂结构的指针更容易让人理解。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &amp;quot;fl&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: There is no common prefix among the input strings.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;All given inputs are in lowercase letters &lt;code&gt;a-z&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-4</title>
    <link href="https://akaqin.github.io/2018/08/04/arts-4/"/>
    <id>https://akaqin.github.io/2018/08/04/arts-4/</id>
    <published>2018-08-04T11:07:58.000Z</published>
    <updated>2020-03-07T12:43:05.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.</li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.</li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">0</span>, value2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += temp) &#123;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        value1 = convert(s[i]);</span><br><span class="line">        value2 = convert(s[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2 &amp;&amp; value2 != <span class="number">0</span>) &#123;</span><br><span class="line">            result += value2 - value1;</span><br><span class="line">            temp = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://www.kernel.org/doc/html/latest/userspace-api/unshare.html" target="_blank" rel="noopener">The Linux Kernel</a></p><p>Most legacy operating system kernels support an abstraction of threads as multiple execution contexts within a process.</p><p>很多老旧的操作系统内核以这样的方式来支持线程：它们把线程抽象成了同一进程内的多个执行上下文。</p><p>These kernels provide special resources and mechanisms to maintain these “threads”.</p><p>这些系统内核提供了特殊的资源和管理机制来支持这类线程。</p><p>The Linux kernel, in a clever and simple manner, does not make distinction between processes and “threads”.</p><p>而Linux内核，则采用了一种聪明而且简单的方式——在内核层面上，它并不区分进程和线程。</p><p>The kernel allows processes to share resources and thus they can achieve legacy “threads” behavior without requiring additional data structures and mechanisms in the kernel.</p><p>Linux内核允许多条进程共享资源。这样做的好处在于，即使内核不再提供额外的数据结构和管理机制，和传统线程类似的行为也能被实现出来。</p><p>The power of implementing threads in this manner comes not only from its simplicity but also from allowing application programmers to work outside the confinement of all-or-nothing shared resources of legacy threads.</p><p>以这样的实现方式来支持线程，不仅简单，而且也可以帮助程序员们摆脱曾经让他们感到烦恼的一个限制：在传统的线程模型中，要么就不能共享资源，要么就得全局共享资源。</p><p>On Linux, at the time of thread creation using the clone system call, applications can selectively choose which resources to share between threads.</p><p>在Linux中，程序在使用clone这个系统指令去创建线程时，可以选择性地指定哪部分资源会被其他线程所共享，而无需将所有资源都共享出去。</p><p>unshare() system call adds a primitive to the Linux thread model that allows threads to selectively ‘unshare’ any resources that were being shared at the time of their creation.</p><p>unshare这个系统指令，为Linux的线程模型增加了一个基本功能：即便一些资源在线程创建时被设置为可共享了，也可以使用unshare指令将这些资源重新收归私有。</p><p>OSI and TCP/IP are the most used models to abstract the computer network.</p><p>OSI和TCP/IP是在抽象计算机网络时最常用的两种模型。</p><p>OSI, the theoretically better abstraction of the network model, failed to be widely adopted due to its complexity.</p><p>OSI，这种在理论上看似更优的网络模型的抽象方式，由于过于复杂而没有被工业界大规模采用。</p><h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINES 5000 <span class="comment">/* max #lines to be sorted */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *lineptr[MAXLINES]; <span class="comment">/* pointers to text lines */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000 <span class="comment">/* size of available space */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE]; <span class="comment">/* storage for alloc */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf; <span class="comment">/* next free position */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">/* return pointer to n characters */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123; <span class="comment">/* it fits */</span> allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n; <span class="comment">/* old p */</span> &#125; <span class="keyword">else</span> <span class="comment">/* not enough room */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span> <span class="comment">/* free storage pointed to by p */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) allocp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getline2</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim - <span class="number">1</span> &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != <span class="string">'\n'</span>; ++i)</span><br><span class="line">        s[i] = c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">        s[i] = c;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort input lines */</span></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">int</span> nlines; <span class="comment">/* number of input lines read */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((nlines = readlines(lineptr, nlines)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        qsort(lineptr, <span class="number">0</span>, nlines - <span class="number">1</span>);</span><br><span class="line">        writelines(lineptr, nlines);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: input too big to sort\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 1000 <span class="comment">/* max length of any input line */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> maxlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, nlines;</span><br><span class="line">    <span class="keyword">char</span> *p, <span class="built_in">line</span>[MAXLEN];</span><br><span class="line">    nlines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = getline2(<span class="built_in">line</span>, MAXLEN)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (nlines &gt;= maxlines || (p = alloc(len)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">line</span>[len - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">/* delete newline */</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p, <span class="built_in">line</span>);</span><br><span class="line">            lineptr[nlines++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> nlines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nlines; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, lineptr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* qsort: sort v[left]...v[right] into increasing order */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="comment">/* do nothing if array contains */</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* fewer than two elements */</span></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);</span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(v[i], v[left]) &lt; <span class="number">0</span>) swap(v, ++last, i);</span><br><span class="line">    swap(v, left, last);</span><br><span class="line">    qsort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    qsort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* swap: interchange v[i] and v[j] */</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    temp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123;</span><br><span class="line">        allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) &#123;</span><br><span class="line">        allocp = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a = alloc(<span class="number">1</span>);</span><br><span class="line">    *(a<span class="number">-1</span>) = <span class="string">'b'</span>;</span><br><span class="line">    *a = <span class="string">'a'</span>;</span><br><span class="line">    *(a+<span class="number">1</span>) = <span class="string">'b'</span>;</span><br><span class="line"><span class="comment">//    *(a+2) = '\0';</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Created by akaQin on 2018&#x2F;8&#x2F;11.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char *strcat(char *s, char *t) &#123;</span><br><span class="line">    char *se &#x3D; s;</span><br><span class="line">&#x2F;&#x2F;    for (; *se; ++se);</span><br><span class="line">        while (*se !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">            se++;</span><br><span class="line">        &#125;</span><br><span class="line">    while ((*se++ &#x3D; *t++) !&#x3D; &#39;\0&#39;);</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char s[] &#x3D; &quot;ab&quot;;</span><br><span class="line"></span><br><span class="line">char t[] &#x3D; &quot;cd&quot;;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    printf(&quot;%s&quot;, strcat(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Roman numerals are represented by seven different symbols: &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Symbol       Value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;For example, two is written as &lt;code&gt;II&lt;/code&gt; in Roman numeral, just two one’s added together. Twelve is written as, &lt;code&gt;XII&lt;/code&gt;, which is simply &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt;. The number twenty seven is written as &lt;code&gt;XXVII&lt;/code&gt;, which is &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;code&gt;IIII&lt;/code&gt;. Instead, the number four is written as &lt;code&gt;IV&lt;/code&gt;. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as &lt;code&gt;IX&lt;/code&gt;. There are six instances where subtraction is used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; can be placed before &lt;code&gt;V&lt;/code&gt; (5) and &lt;code&gt;X&lt;/code&gt; (10) to make 4 and 9.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; can be placed before &lt;code&gt;L&lt;/code&gt; (50) and &lt;code&gt;C&lt;/code&gt; (100) to make 40 and 90.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; can be placed before &lt;code&gt;D&lt;/code&gt; (500) and &lt;code&gt;M&lt;/code&gt; (1000) to make 400 and 900.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-3</title>
    <link href="https://akaqin.github.io/2018/07/29/arts-3/"/>
    <id>https://akaqin.github.io/2018/07/29/arts-3/</id>
    <published>2018-07-29T13:07:26.000Z</published>
    <updated>2020-03-07T12:42:59.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a><strong>Example 2:</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a><strong>Example 3:</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hold = x;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        val = val * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val == hold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.5/en/replication-implementation.html" target="_blank" rel="noopener">MySQL Replication Implementation</a></p><p>Replication is based on the master server keeping track of all changes to its databases (updates, deletes, and so on) in its binary log.</p><p>复制是通过将所有数据库修改操作记录（更新，删除等）到了日志文件中的主服务器实现的。</p><p>The binary log serves as a written record of all events that modify database structure or content (data) from the moment the server was started.</p><p>日志服务器担负着将各类修改记录写入日志文件的职责。从日志服务器被启动的那一刻起，所有修改了数据库结构或者数据的事件，都会被它记录下来。</p><p>Typically, SELECT statements are not recorded because they modify neither database structure nor content.</p><p>一般来说，SELECT语句不会被记录下来，因为他们既不会影响数据库的结构，也不会影响数据库的数据。</p><p>Each slave that connects to the master requests a copy of the binary log.</p><p>每台接上了主服务器的从服务器都会请求一份二进制日志的拷贝文件。</p><p>That is, it pulls the data from the master, rather than the master pushing the data to the slave.</p><p>那就是，“从服务器”从“主服务器”那里将日志拉取回来，而非主服务器向从服务器推送日志。</p><p>The slave also executes the events from the binary log that it receives. This has the effect of repeating the originalchanges just as they were made on the master.</p><p>从服务器会将它收到的二进制日志中所记录的事件再执行一遍，这样就起到了重复这些操作的效果，就好像这些操作在主服务器上被执行时一样。</p><p>Tables are created or their structure modified, and data is inserted, deleted, and updated according to the changes that were originally made on the master.</p><p>根据主服务器对于各类操作的记录，从服务器上的数据表会相应地被创建或修改、而从服务器上的数据也会被相应地插入、删除或更新。</p><h2 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h2><p>逆波兰计算器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP 100 <span class="comment">/* max size of operand or operator */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span> <span class="comment">/* signal that a number was found */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> [])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> NUMBER:</span><br><span class="line">                push(atof(s));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                push(pop() + pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                push(op2 - pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                push(pop() * pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                op2 == <span class="number">0.0</span> ? <span class="built_in">printf</span>(<span class="string">"zero divisor\n"</span>) : push(pop() / op2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: unknown command %s\n"</span>, s);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100 <span class="comment">/* maximum depth of val stack */</span></span></span><br><span class="line"><span class="keyword">int</span> sp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> val[MAXVAL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &lt; MAXVAL) &#123;</span><br><span class="line">        val[sp++] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack full, can't push %g\n"</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val[--sp];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getop: get next character or numeric operand */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, c;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getch()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>) &#123; ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF) &#123;</span><br><span class="line">        ungetch(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 100</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE]; <span class="comment">/* buffer for ungetch */</span></span><br><span class="line"><span class="keyword">int</span> bufp = <span class="number">0</span>; <span class="comment">/* next free position in buf */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">/* get a (possibly pushed-back) character */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bufp &gt; <span class="number">0</span>) ? buf[--bufp] : getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">/* push character back on input */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufp &gt;= BUFSIZE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ungetch: too many characters\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buf[bufp++] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h1&gt;&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;Example-2&quot;&gt;&lt;a href=&quot;#Example-2&quot; class=&quot;headerlink&quot; title=&quot;Example 2:&quot;&gt;&lt;/a&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: -121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;Example-3&quot;&gt;&lt;a href=&quot;#Example-3&quot; class=&quot;headerlink&quot; title=&quot;Example 3:&quot;&gt;&lt;/a&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Reads 01 from right to left. Therefore it is not a palindrome.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-2</title>
    <link href="https://akaqin.github.io/2018/07/09/arts-2/"/>
    <id>https://akaqin.github.io/2018/07/09/arts-2/</id>
    <published>2018-07-09T03:25:45.000Z</published>
    <updated>2020-03-07T12:42:47.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Note:</strong></p><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">minInt32, maxInt32 := <span class="number">-2147483648</span>, <span class="number">2147483647</span></span><br><span class="line">result := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; x != <span class="number">0</span>; x = x/<span class="number">10</span> &#123;</span><br><span class="line">result = (result * <span class="number">10</span>) + x % <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> result &gt; maxInt32 || result &lt; minInt32  &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>​    首先想到的是把int转成字符串或码点数组，但没成功，思考后没有想到别的思路。后来看Discuss使用对10取余，pop&amp;push的方式，感觉豁然开朗，于是自己尝试写下了这种解法，美中不足是maxInt32和minInt32都是手动填写的，go语言里貌似没有现成的常量（也可能是我没找到），但肯定有能计算这个数的表达式，现在还不知道该怎么写，以后回来填坑。</p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>原文：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/index.html" target="_blank" rel="noopener">Act with Prudence</a></p><blockquote><p>*”Whatever you undertake, act with prudence and consider the consequences” Anon*</p></blockquote><p>​    源自耗子叔专栏推荐文章 <a href="https://legacy.gitbook.com/book/97-things-every-x-should-know/97-things-every-programmer-should-know/details" target="_blank" rel="noopener">97 Things Every Programmer Should Know</a> 中的第一篇，这个系列文章每过段时间看总会有新的认知，是难得的程序员用来学习并锻炼英文阅读能力的好文，推荐给大家。</p><p>​    我们在实际项目中经常遇到”doing it right” or “doing it quick”的问题，我的习惯是做事力求完美，但有些时候还是不够谨慎，这是我日后需要注意的。再就是一个项目第一版的质量非常重要，它决定了后面的迭代开发和维护的成本和效率，所以第一版尤其要写的仔细，多思考，即使是一些小的不合适的地方也要立即改正。不过我们也难免遇到因为排期压力妥协，遗留技术债务的情况，这时候一定要记录项目中遗留了哪些坑，还有哪些地方是需要完善的，并尽快处理这些逻辑。拖的越久，越难修复，最可怕的是拖到重构的代价已经超过重写，但为了服务在线还要继续维护，那剩下的只有无尽的痛苦，崩溃。。</p><h1 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h1><p>计算斐波纳切数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fibonacci1(i<span class="number">-2</span>) + fibonacci1(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci2</span><span class="params">(j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= j; i++ &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t1 := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fibonacci1(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"fibonacci1 done: %v \n"</span>, time.Since(t1))</span><br><span class="line"></span><br><span class="line">t2 := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fibonacci2(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"fibonacci2 done: %v \n"</span>, time.Since(t2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    学习的过程中做做这种小练习还是蛮有意思的，上面的代码分别用递归（从大到小）和动态规划（从小到大）的思路进行实现。尤其是第二种从小到大计算的算法，“a, b = b, a+b” 因为我之前没写过python，看到后给我眼前一亮的感觉。写完后发现效率很差，开始用goroutine去优化性能，写的过程中坑还是蛮多的：</p><ul><li><p>对计数器的应用，如果顺序写的不对会导致wg.Done执行多次把数计成负的报一个panic异常；</p></li><li><p>还有在for循环中用goroutine 调用闭包时，这个单独的变量i是被所有 的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了i并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，所以当这些goroutine开始读取i的值时，它们所看到的值已经是slice的最后一个元素了。 显式地添加这个参数，我们能够确保使用的i是当go语句执行时的“当前”那个i。</p></li></ul><p>  写完后会发现第二种解法会比第一种快很多很多。</p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://laravel-china.org/topics/9991/20-laravel-eloquent-necessary-practical-skills" target="_blank" rel="noopener">20 个 Laravel Eloquent 必备的实用技巧</a></p><p>​    一些你可能还不知道的Larvel实用技巧，学习了～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h1&gt;&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: -123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: -321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts-1</title>
    <link href="https://akaqin.github.io/2018/06/26/arts-1/"/>
    <id>https://akaqin.github.io/2018/06/26/arts-1/</id>
    <published>2018-06-26T08:52:41.000Z</published>
    <updated>2020-03-07T12:42:34.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> nums[k1+<span class="number">1</span>:] &#123;</span><br><span class="line">            <span class="keyword">if</span> v1 + v2 == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="keyword">int</span>&#123;k1, k1 + k2 + <span class="number">1</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach 2"></a>Approach 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> j, ok := m[target-v]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li>Time complexity : O(n^2)O(n2). For each element, we try to find its complement by looping through the rest of array which takes O(n)O(n) time. Therefore, the time complexity is O(n^2)O(n2).</li><li>Space complexity : O(1)O(1).</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>​    Approach 1 is the simplest and low-grade arithmetic which I came up with first.Due to it is my first time to solving problem on leetcode, I have no other ideas.I found the approach 2 in Solution tag, it has a much faster time complexity than the other one and it’s an extension of my thinking.</p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>​    由于我的英语实在太渣了，暂时没找到啥合适的英文文章做反思总结，所以第一周的Review先用中文的代替，下周开始一定替换成英文。</p><blockquote><p><a href="https://studygolang.com/articles/2216" target="_blank" rel="noopener">为什么 Go 语言把类型放在后面？</a></p></blockquote><p>​    相信大家在学go语言的时候，尤其是有c语言基础的人，一定会有和我一样的疑问，go作为一门类c语言，其他地方都和c很像，唯独类型为什么要放在变量名后面？这么奇葩？后来看到耗子叔的解释，犹如醍醐灌顶，不能认同更多：</p><blockquote><p>Go的语法并不奇葩，Go的作者也是C的重度使用者甚至C的作者，当你觉得它奇葩，通常来说是自己没有理解，凡事都问几个为什么，你会明白更多。</p></blockquote><p>​    看了上面引用的文章，对Go语言为什么要把类型放在后面有了初步的理解：C语言的写法在声明一些比较复杂的函数，尤其是带有指针的参数时，会变得非常难懂，容易引起混淆。由于我没有C的基础，感觉理解的还不够透彻，打算等学完C再来看一遍，相信一定会有更深刻的理解。</p><h1 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h1><p>​    用一个二叉树实现插入排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">value       <span class="keyword">int</span></span><br><span class="line">left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> root *tree</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">root = add(root, v)</span><br><span class="line">&#125;</span><br><span class="line">appendValues(values[:<span class="number">0</span>], root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="keyword">int</span>, t *tree)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">values = appendValues(values, t.left)</span><br><span class="line">values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">values = appendValues(values, t.right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="keyword">int</span>)</span> *<span class="title">tree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">t = <span class="built_in">new</span>(tree)</span><br><span class="line">t.value = value</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">t.left = add(t.left, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.right = add(t.right, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h1&gt;&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given nums &amp;#x3D; [2, 7, 11, 15], target &amp;#x3D; 9,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Because nums[0] + nums[1] &amp;#x3D; 2 + 7 &amp;#x3D; 9,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [0, 1].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;h3 id=&quot;Approach-1&quot;&gt;&lt;a href=&quot;#Approach-1&quot; class=&quot;headerlink&quot; title=&quot;Approach 1&quot;&gt;&lt;/a&gt;Approach 1&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;twoSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, target &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k1, v1 := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; nums &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k2, v2 := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; nums[k1+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; v1 + v2 == target &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;#123;k1, k1 + k2 + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>arts</title>
    <link href="https://akaqin.github.io/2018/06/26/arts/"/>
    <id>https://akaqin.github.io/2018/06/26/arts/</id>
    <published>2018-06-26T08:43:13.000Z</published>
    <updated>2020-03-07T12:44:38.575Z</updated>
    
    <content type="html"><![CDATA[<p>ARTS is a learning activity initiated by <a href="https://weibo.com/haoel?profile_ftype=1&is_all=1#_0" target="_blank" rel="noopener">Chen Hao</a></p><blockquote><p>A: Algorithm example which I learned on <a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a>;</p><p>R: Review an English blog or essay;</p><p>T: Technical skills which I learned;</p><p>S: Share something which I learn from a classic computer book;</p></blockquote><p>In the next year, I will write a ARTS note every week;</p><p>If you have suggestions or inspiration， welcome to communicate with me</p><a id="more"></a><p>e-mail: <a href="mailto:qinlong@akaqin.me">qinlong@akaqin.me</a></p><p>June 24, 2018</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ARTS is a learning activity initiated by &lt;a href=&quot;https://weibo.com/haoel?profile_ftype=1&amp;is_all=1#_0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chen Hao&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A: Algorithm example which I learned on &lt;a href=&quot;https://leetcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt;R: Review an English blog or essay;&lt;/p&gt;
&lt;p&gt;T: Technical skills which I learned;&lt;/p&gt;
&lt;p&gt;S: Share something which I learn from a classic computer book;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the next year, I will write a ARTS note every week;&lt;/p&gt;
&lt;p&gt;If you have suggestions or inspiration， welcome to communicate with me&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://akaqin.github.io/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》第1章</title>
    <link href="https://akaqin.github.io/2018/06/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC1%E7%AB%A0/"/>
    <id>https://akaqin.github.io/2018/06/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC1%E7%AB%A0/</id>
    <published>2018-06-23T07:33:38.000Z</published>
    <updated>2020-04-14T01:23:03.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    hello程序的生命周期是从一个源程序开始的。源程序是一个由值0和1组成的位（又称比特）序列，8个位组成一组，称为字节。每个字节必保湿程序中的某些特殊文本字符。大部分计算机系统使用ASCII标准来表示文本字符，这种方式实际上就是一个唯一的单字节大小的整数值来表示每个字符（入下图）。</p><p><img src="http://pfjta0ejx.bkt.clouddn.com/hello-ASCII.png" alt="ASCII"></p><p>​    hello.c程序是以字节序列的方式存储在文本文件中的。每个字节都有一个整数值，对应某些字符。这种表示方法说明了一个节本思想：系统中所有信息——包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传输的数据，都是由一串比特表示的，区别不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p><h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>​    hello程序的生命周期是从一个高级C语言开始的，因为这种形式被人读懂。然而为了在系统上运行，每条C语句被其他程序转化为一系列低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存起来。下面是GCC编译驱动器把源文件翻译成可执行文件的四个阶段。</p><p><img src="http://pfjta0ejx.bkt.clouddn.com/compile-system.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机系统漫游&quot;&gt;&lt;a href=&quot;#计算机系统漫游&quot; class=&quot;headerlink&quot; title=&quot;计算机系统漫游&quot;&gt;&lt;/a&gt;计算机系统漫游&lt;/h1&gt;&lt;h2 id=&quot;信息就是位-上下文&quot;&gt;&lt;a href=&quot;#信息就是位-上下文&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="《CSAPP》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8ACSAPP%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CS" scheme="https://akaqin.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>《Linux私房菜》学习笔记</title>
    <link href="https://akaqin.github.io/2018/03/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://akaqin.github.io/2018/03/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2018-03-24T03:14:08.000Z</published>
    <updated>2020-03-08T07:52:34.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="Linux中，Ctrl组合键"><a href="#Linux中，Ctrl组合键" class="headerlink" title="Linux中，Ctrl组合键"></a>Linux中，Ctrl组合键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+c 结束正在运行的程序</span><br><span class="line"></span><br><span class="line">Ctrl+d 结束输入或退出shell</span><br><span class="line"></span><br><span class="line">Ctrl+s 暂停屏幕输出【锁住终端】</span><br><span class="line"></span><br><span class="line">Ctrl+q 恢复屏幕输出【解锁终端】</span><br><span class="line"></span><br><span class="line">Ctrl+l 清屏，【是字母L的小写】等同于Clear</span><br><span class="line"></span><br><span class="line">Ctrl+a 切换到命令行开始</span><br><span class="line"></span><br><span class="line">trl+e 切换到命令行末尾</span><br><span class="line"></span><br><span class="line">Ctrl+u 清除剪切光标之前的内容</span><br><span class="line"></span><br><span class="line">Ctrl+k 清除剪切光标及光标之后的内容</span><br><span class="line"></span><br><span class="line">Ctrl+y 在光标处粘贴剪切的内容</span><br><span class="line"></span><br><span class="line">Ctrl+r 查找历史命令【输入关键字，就能调出以前执行过的命令】</span><br><span class="line"></span><br><span class="line">Ctrl+t 调换光标所在处与其之前字符位置，并把光标移到下个字符</span><br><span class="line"></span><br><span class="line">Ctrl+x+u 撤销操作</span><br></pre></td></tr></table></figure><h2 id="第四章、基础操作入门"><a href="#第四章、基础操作入门" class="headerlink" title="第四章、基础操作入门"></a>第四章、基础操作入门</h2><h3 id="关机或重启"><a href="#关机或重启" class="headerlink" title="关机或重启"></a>关机或重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据同步写入磁盘：</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line">关机：</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line">重启：</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日期和时间：date</span><br><span class="line">日历：cal</span><br><span class="line">计算器：bc</span><br></pre></td></tr></table></figure><h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Tab]:命令补全或文件补齐</span><br><span class="line">[Ctrl]-c:中断目前程序</span><br><span class="line">[Ctrl]-d:（键盘输入结束，End Of File，EOF 或 End Of Input），相当于输入exit</span><br><span class="line">[shift]+&#123;[PageUP]|[Page Down]&#125;:翻页</span><br></pre></td></tr></table></figure><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">man page</span><br><span class="line">info page</span><br></pre></td></tr></table></figure><h2 id="第五章、文件权限与目录配置"><a href="#第五章、文件权限与目录配置" class="headerlink" title="第五章、文件权限与目录配置"></a>第五章、文件权限与目录配置</h2><h3 id="修改文件或目录属组"><a href="#修改文件或目录属组" class="headerlink" title="修改文件或目录属组"></a>修改文件或目录属组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] group dirname&#x2F;filename   </span><br><span class="line">chown [-R] user dirname&#x2F;filename    </span><br><span class="line">chown [-R] user:group dirname&#x2F;filename</span><br></pre></td></tr></table></figure><h3 id="修改文件或目录权限"><a href="#修改文件或目录权限" class="headerlink" title="修改文件或目录权限"></a>修改文件或目录权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] [ugoa][+-&#x3D;][rwx] dirname&#x2F;filename</span><br><span class="line">chmod [-R] [xyz] dirname&#x2F;filename (xyz为0-7的数字)</span><br></pre></td></tr></table></figure><h3 id="操作与权限的关系"><a href="#操作与权限的关系" class="headerlink" title="操作与权限的关系"></a>操作与权限的关系</h3><p> <img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/DB45115B20484E5D93435C808DEA4B6C/31" alt="image"></p><h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><ul><li>正规文件（regular file)：第一个字符为[-],包括纯文本文档（ASCII），二进制文件（binary），数据格式文件（data）；</li><li>目录（directory）：第一个字符为[d]；</li><li>连接档（link）：第一个字符为[l]；</li><li>设备与装置文件（device）：通常都集中在/dev目录下，分为区块(block)设备档[b]和字符(character)设备文件[c];</li><li>资料接口文件（sockets）：第一个字符为[s]；</li><li>数据传输文件（FIFO，pipe）：第一个字符为[p];<h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3></li><li>/（root，根目录）：与开机系统有关；</li><li>/usr(unix software recourse):与软件安装／执行有关</li><li>/var(variable):与系统运作过程有关；</li><li>/bin:很多配置文件和指令的目录；</li><li>/boot:开机用到的文件；</li><li>/dev:装置与接口设备；</li><li>/etc:系统主要配置文件；</li><li>/lib:系统函数库；</li><li>/media:可移除装置，如光盘，软盘，DVD；</li><li>/opt:第三方协力软件目录；</li><li>/run:早起的FHS规定系统开机后所产生的各项信息放置目录;</li><li>/sbin:设定系统环境的指令;</li><li>/srv:一些网络服务启动后，需要取用的数据目录;</li><li>/tmp:临时文件目录;</li><li>/home:家目录;</li><li>/lost+found:系统发生错误时，遗失片段放置目录；</li></ul><h2 id="第六章、文件与目录管理"><a href="#第六章、文件与目录管理" class="headerlink" title="第六章、文件与目录管理"></a>第六章、文件与目录管理</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#显示当前目录</span><br><span class="line">pwd [-P]    </span><br><span class="line">-P:显示真实路径，而非链接（link）路径</span><br><span class="line"></span><br><span class="line">#建立新目录</span><br><span class="line">mkdir 【-mp] dirname    </span><br><span class="line">-m:配置文件权限</span><br><span class="line">-p：递归建立</span><br><span class="line"></span><br><span class="line">#删除空目录</span><br><span class="line">rmdir [-p] dirname  </span><br><span class="line">-p：连同上层的空目录一起删除</span><br></pre></td></tr></table></figure><h3 id="执行文件所在路径的变量-PATH"><a href="#执行文件所在路径的变量-PATH" class="headerlink" title="执行文件所在路径的变量$PATH"></a>执行文件所在路径的变量$PATH</h3><p>只有在$PATH中的指令才可以在任意地方执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH  #查看</span><br><span class="line"></span><br><span class="line">PATH&#x3D;&quot;$PATH:&#x2F;root&quot;  #把&#x2F;root加入到$PATH中</span><br></pre></td></tr></table></figure><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">ls [-aAdfFhilnrRSt] filename&#x2F;dirname    </span><br><span class="line">ls [--color&#x3D;&#123;never,auto,always&#125;] filename&#x2F;dirname</span><br><span class="line">ls [--full-time] filename&#x2F;dirname</span><br><span class="line">-a : 全部文件，包括隐藏文件（.开头)</span><br><span class="line">-d : 仅列出目录本身，而不是目录内文件</span><br><span class="line">-l : 长数据串输出，包含文件属性、权限等数据</span><br><span class="line"></span><br><span class="line">#复制</span><br><span class="line">cp [-adfilprsu] 来源文件(source) 目标文件(destination)  </span><br><span class="line">cp [options] source1 source2 source3 .... directory</span><br><span class="line">-a : 相当于-dr --preserve&#x3D;all的意思</span><br><span class="line">-d : 若源文件为链接文件属性(link file),则复制链接文件属性，而非文件本身</span><br><span class="line">-f : 强制（force),若文件已存在，删除后再尝试一次</span><br><span class="line">-i ：若目标文件已存在，覆盖前先询问</span><br><span class="line">-l : 建立硬连接，而非复制文件本身</span><br><span class="line">-p : 连同属性（权限，用户，时间）一起复制，而非使用默认属性</span><br><span class="line">-r : 递归</span><br><span class="line">-s ：软链</span><br><span class="line">-u : destination 比 source旧才更新，或destination不存在才复制</span><br><span class="line"></span><br><span class="line">#移除</span><br><span class="line">rm [-fir] filename&#x2F;dirname</span><br><span class="line">-f : force,忽略不存在的文件，不报错</span><br><span class="line">-i : 互动模式，删前确认</span><br><span class="line">-r ：递归</span><br><span class="line"></span><br><span class="line">#移动</span><br><span class="line">mv [-fiu] source destination</span><br><span class="line">mv [options] source1 source2 source3 ... directory</span><br><span class="line">-f : force</span><br><span class="line">-i : 若目标文件已存在，询问是否覆盖</span><br><span class="line">-u : 若目标已存在，且source比较新，才会更新</span><br></pre></td></tr></table></figure><h3 id="取得路径和文件名"><a href="#取得路径和文件名" class="headerlink" title="取得路径和文件名"></a>取得路径和文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#路径</span><br><span class="line">basename &#x2F;a&#x2F;b&#x2F;c     #c</span><br><span class="line">#文件名</span><br><span class="line">dirname &#x2F;a&#x2F;b&#x2F;c      #&#x2F;a&#x2F;b</span><br></pre></td></tr></table></figure><h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul><li>cat(con++cat++enate)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br><span class="line">-n : 打印行号</span><br></pre></td></tr></table></figure></li><li>tac(反向的cat)</li><li>nl</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] filename</span><br></pre></td></tr></table></figure><ul><li>more(一页一页翻动)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">more filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：查找</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">b：往回翻页</span><br></pre></td></tr></table></figure><ul><li><p>less（一页一页反动）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">less filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：向下查找</span><br><span class="line">?字符串：向上查找</span><br><span class="line">n：重复前一个搜寻</span><br><span class="line">N：反向重复前一个搜寻</span><br><span class="line">g：去第一行</span><br><span class="line">G：去最后一行</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">[pagedown]:下一页</span><br><span class="line">[pageup]:上一页</span><br></pre></td></tr></table></figure></li><li><p>head（取出前面几行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] file</span><br><span class="line">head [-n +number] file  #取反，后n行不显示</span><br></pre></td></tr></table></figure></li><li><p>tail（取后面几行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] [-f] file</span><br><span class="line">head [-n -number] file  #取反，前n行不显示</span><br><span class="line">-f：动态输出</span><br></pre></td></tr></table></figure></li><li><p>od（非纯文本文档）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od [-t TYPE] file</span><br></pre></td></tr></table></figure><h3 id="新建文档或修改文件时间"><a href="#新建文档或修改文件时间" class="headerlink" title="新建文档或修改文件时间"></a>新建文档或修改文件时间</h3><ul><li>mtime（modification time）：文件内容变更时间(ls默认时间)</li><li>ctime（status time）：文件状态（权限、属性）变更时间</li><li>atime（access time）：文件读取时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acdmt] file #建立一个新文件或更新文件的mtime和atime</span><br></pre></td></tr></table></figure><h3 id="默认权限和隐藏权限"><a href="#默认权限和隐藏权限" class="headerlink" title="默认权限和隐藏权限"></a>默认权限和隐藏权限</h3><ul><li>文件预设权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask</span><br></pre></td></tr></table></figure></li><li>文件隐藏属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-&#x3D;][ASacdistu] file&#x2F;dir    #配置文件或目录隐藏属性</span><br><span class="line">lsattr [-adR] file&#x2F;dir  #查看隐藏属性</span><br></pre></td></tr></table></figure></li><li>文件特殊权限：SUID，SGID，SBIT</li><li>观察文件类型：fie</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><h3 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h3><ul><li>which（寻找【指令文件】）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [-a] command</span><br></pre></td></tr></table></figure></li><li>whereis(在特定目录搜寻系统文件，不实用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] file&#x2F;dir</span><br></pre></td></tr></table></figure></li><li>locate/updatedb（依靠db快速查询）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate [-ir] keyword</span><br><span class="line">updatedb    #locate是靠db快速查询，所以查询较新文件时需要手动updatedb</span><br></pre></td></tr></table></figure>find(强大，但比较吃硬盘，影响速度)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">1.time(-atime,-ctime,-mtime)</span><br><span class="line">    -mtime n : n天前（一天内）被改动过的文件</span><br><span class="line">    -mtime +n : n天前（不含n本身）被改动过的文件</span><br><span class="line">    -mtime -n : n天内（含n本身）被改动过的文件</span><br><span class="line">2.属组相关参数</span><br><span class="line">    -uid n</span><br><span class="line">    -gid n</span><br><span class="line">    -user name</span><br><span class="line">    -group name</span><br><span class="line">    -nouser</span><br><span class="line">    -nogroup</span><br><span class="line">3.权限及名称</span><br><span class="line">    -name filename</span><br><span class="line">    -size [+-]SIZE:c代表byte，k代表kb</span><br><span class="line">    -type TYPE ： [f,b,c,d,l,s,p]</span><br><span class="line">    -perm mode</span><br><span class="line">    -perm -mode</span><br><span class="line">    -perm &#x2F;mode</span><br><span class="line">4.额外参数</span><br><span class="line">    -exec command : command见下图</span><br><span class="line">    -print</span><br><span class="line">    -a : and的意思，用于连接两个条件，如find &#x2F;etc -size +50k -a -size -60k</span><br><span class="line">    ! : 取反的意思，如find &#x2F;etc -size +50k -a ! -user root</span><br></pre></td></tr></table></figure><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/85FEA75CCD8E4D0CAA94260B98089A1E/431" alt="image"></li></ul><h2 id="第七章、Linux-磁盘与文件系统管理"><a href="#第七章、Linux-磁盘与文件系统管理" class="headerlink" title="第七章、Linux 磁盘与文件系统管理"></a>第七章、Linux 磁盘与文件系统管理</h2><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>操作系统的文件数据除了文件实际内容外，还有非常多的属性（权限，属组，时间参数）。文件系统会将这两部分数据存放在不同的区块，权限与属性放到inode中，实际数据放到data block中。另外，还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括inode和block总量、使用量、剩余量等。</p><ul><li>superblock：记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在block号码；</li><li>block：实际记录文件的内容，若文件太大时，会占用多个block；</li></ul><p>每个inode与block都有编号，每个文件都会占用一个inode，inode内则有文件数据放置的block号码。这种数据存取方法我们称为索引式文件系统（indexed allocation）（下图）。<br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/EE38F1F9F8A54CB185593EC9E07B2AAA/489" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/561C779757124369BE8A8F997D760FBE/501" alt="image"><br>上图为闪存用的FAT格式，没有inode存在，所以FAT没有办法将这个文件的所有block再一开始就读取出来。每个block号码都记录再前一个block当中。如果同一个文件数据写入的block分散的太过厉害，无法在磁盘转一圈就读到所有数据，就需要多转好几圈。<br>碎片整理的原因就是文件写入的block过于分散，读取文件的效率会变得很差，这时候可以透过 碎片整理将同一个文件的blcok汇整到一起，这样读取会比较容易。Ext2是索引式文件系统，不需要整理。</p><h3 id="Linux的EXT2文件系统（inode）"><a href="#Linux的EXT2文件系统（inode）" class="headerlink" title="Linux的EXT2文件系统（inode）"></a>Linux的EXT2文件系统（inode）</h3><p>文件系统一开始就将inode与block规划好了，除非重新格式化（或者利用resize2fs等指令变更文件系统大小），否则inode与block固定后就不再变动。</p><h3 id="7-2-文件系统的简单操作"><a href="#7-2-文件系统的简单操作" class="headerlink" title="7.2 文件系统的简单操作"></a>7.2 文件系统的简单操作</h3><h4 id="7-2-1-磁盘与目录的容量"><a href="#7-2-1-磁盘与目录的容量" class="headerlink" title="7.2.1 磁盘与目录的容量"></a>7.2.1 磁盘与目录的容量</h4><p>df:列出文件系统的整体磁盘使用量；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux学习笔记&quot;&gt;&lt;a href=&quot;#Linux学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux学习笔记&quot;&gt;&lt;/a&gt;Linux学习笔记&lt;/h1&gt;&lt;h2 id=&quot;Linux中，Ctrl组合键&quot;&gt;&lt;a href=&quot;#Linux中，Ctrl
      
    
    </summary>
    
    
      <category term="《Linux私房菜》笔记" scheme="https://akaqin.github.io/categories/%E3%80%8ALinux%E7%A7%81%E6%88%BF%E8%8F%9C%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://akaqin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C语言编程心得</title>
    <link href="https://akaqin.github.io/2018/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    <id>https://akaqin.github.io/2018/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</id>
    <published>2018-02-23T09:01:38.000Z</published>
    <updated>2020-03-08T07:36:45.119Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p></li><li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p></li><li><p>声明变量后一定要记得赋初识值，尤其是数组</p></li><li><p>变量就近声明</p></li><li><p>文件内使用的函数要习惯声明static</p></li><li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放&lt;
      
    
    </summary>
    
    
      <category term="经验总结" scheme="https://akaqin.github.io/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://akaqin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>first post</title>
    <link href="https://akaqin.github.io/2017/02/23/first-post/"/>
    <id>https://akaqin.github.io/2017/02/23/first-post/</id>
    <published>2017-02-23T07:26:11.000Z</published>
    <updated>2020-03-07T12:22:32.934Z</updated>
    
    <content type="html"><![CDATA[<p>I love you, Joyce!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I love you, Joyce!&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
