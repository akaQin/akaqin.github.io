<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akaQin&#39;s Blog</title>
  
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-02T13:22:27.762Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Arron Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>strlen与sizeof区别</title>
    <link href="http://yoursite.com/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-02T13:18:44.000Z</published>
    <updated>2020-03-02T13:22:27.762Z</updated>
    
    <content type="html"><![CDATA[<ul><li>strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度</li><li>strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度&lt;/li&gt;
&lt;li&gt;strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第八章——进程控制</title>
    <link href="http://yoursite.com/2020/03/02/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/03/02/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-03-02T13:01:18.000Z</published>
    <updated>2020-03-03T01:09:10.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><ul><li>每个进程都有一个非负整型表示的唯一进程ID</li><li>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。</li><li>进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。</li><li>init读取与系统有关的初始化文件，并将系统引导到一个状态。</li><li>init进程不会终止，它是一个普通的用户进程，以超级用户特权运行；交换进程是内核中的系统进程。</li></ul><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><ul><li>调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1</li><li>子进程和父进程继续执行fork之后的指令；子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段</li><li>fork时用到<code>写时复制（Copy-On-Write）</code>技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”</li><li>fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法</li><li>文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。<br><img src="8-2.png" alt=""></li></ul><a id="more"></a><h4 id="子进程从父进程继承"><a href="#子进程从父进程继承" class="headerlink" title="子进程从父进程继承"></a>子进程从父进程继承</h4><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>信号屏蔽和安排</li><li>对任一打开间描述符的执行时关闭（close-on-exec）标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li>资源限制</li></ul><h4 id="父进程与子进程的区别"><a href="#父进程与子进程的区别" class="headerlink" title="父进程与子进程的区别"></a>父进程与子进程的区别</h4><ul><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空集<ul><li>fork失败的两个主要原因：</li></ul></li><li>系统中已经有了太多的进程</li><li>该用户ID的进程总数超过了系统的限制</li></ul><h3 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h3><ul><li>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。</li><li>vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。</li><li>vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中任意一个时，父进程会恢复运行。</li></ul><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><ul><li>进程的5种正常终止方式：<ul><li>在main函数内执行return语句。等效于调用exit</li><li>调用exit函数。由ISO C定义，其操作包括调用各终止处理程序，关闭所有标准I/O流等</li><li>调用_exit或_Exit函数。ISO C定义_Exit，目的是提供一种无需运行终止处理程序和信号处理程序的方法。对标准I/O流是否进行冲洗，这取决于实现。</li><li>进程的最后一个线程在启动例程中执行return语句。</li><li>进程的最后一个线程调用pthread_exit函数。</li></ul></li><li>进程的3种异常终止方式：<ul><li>调用abort，它产生SIGABRT信号</li><li>当进程接收到某种信号时</li><li>最后一个线程对“取消”请求做出响应。</li></ul></li><li>不管进程如何终止，最后内核都会为相应进程关闭所有打开描述符，释放它所使用的存储器等。所以大多数exit的现代实现不再关闭流</li></ul><h4 id="终止进程如何通知父进程它是如何终止的？"><a href="#终止进程如何通知父进程它是如何终止的？" class="headerlink" title="终止进程如何通知父进程它是如何终止的？"></a>终止进程如何通知父进程它是如何终止的？</h4><p>对于三个终止函数（exit、_exit和_Exit），将其<code>退出状态</code>作为参数传递给函数。对于异常终止情况，内核（不是进程本身）产生一个指示其终止原因的<code>终止状态</code>。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态。</p><h4 id="父进程在子进程之前终止会怎样？"><a href="#父进程在子进程之前终止会怎样？" class="headerlink" title="父进程在子进程之前终止会怎样？"></a>父进程在子进程之前终止会怎样？</h4><p>对于父进程已经终止的所有进程，它们的父进程都改变为init进程（称为由init进程收养）。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，如果是正要终止进程的子进程，则将该进程的父进程ID改为1。</p><h4 id="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"><a href="#如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？" class="headerlink" title="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"></a>如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？</h4><p>如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。包括进程ID、终止状态和CPU时间总量。</p><h4 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h4><p>内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵尸进程。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵尸进程。</p><h4 id="一个由init进程收养的进程终止后会不会变成僵尸进程？"><a href="#一个由init进程收养的进程终止后会不会变成僵尸进程？" class="headerlink" title="一个由init进程收养的进程终止后会不会变成僵尸进程？"></a>一个由init进程收养的进程终止后会不会变成僵尸进程？</h4><p>不会的。因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。</p><h3 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h4><ul><li>成功返回进程id，出错返回0或-1</li><li>statloc是一个整型指针，保存终止进程的终止状态，当它是一个空指针时，则不保存</li></ul><h4 id="调用wait或waitpid会发生什么？"><a href="#调用wait或waitpid会发生什么？" class="headerlink" title="调用wait或waitpid会发生什么？"></a>调用wait或waitpid会发生什么？</h4><ul><li>如果所有子进程都还在运行，则阻塞</li><li>如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回</li><li>如果它没有任何子进程，则立即出错返回</li></ul><h4 id="两个函数的区别"><a href="#两个函数的区别" class="headerlink" title="两个函数的区别"></a>两个函数的区别</h4><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞</li><li>waitpid并不等待其调用之后的第一个子进程终止，它有若干选项，可以控制它所等待的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程标识&quot;&gt;&lt;a href=&quot;#进程标识&quot; class=&quot;headerlink&quot; title=&quot;进程标识&quot;&gt;&lt;/a&gt;进程标识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个进程都有一个非负整型表示的唯一进程ID&lt;/li&gt;
&lt;li&gt;ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。&lt;/li&gt;
&lt;li&gt;进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。&lt;/li&gt;
&lt;li&gt;init读取与系统有关的初始化文件，并将系统引导到一个状态。&lt;/li&gt;
&lt;li&gt;init进程不会终止，它是一个普通的用户进程，以超级用户特权运行；交换进程是内核中的系统进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;fork函数&quot;&gt;&lt;a href=&quot;#fork函数&quot; class=&quot;headerlink&quot; title=&quot;fork函数&quot;&gt;&lt;/a&gt;fork函数&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;函数说明&quot;&gt;&lt;a href=&quot;#函数说明&quot; class=&quot;headerlink&quot; title=&quot;函数说明&quot;&gt;&lt;/a&gt;函数说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1&lt;/li&gt;
&lt;li&gt;子进程和父进程继续执行fork之后的指令；子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段&lt;/li&gt;
&lt;li&gt;fork时用到&lt;code&gt;写时复制（Copy-On-Write）&lt;/code&gt;技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”&lt;/li&gt;
&lt;li&gt;fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法&lt;/li&gt;
&lt;li&gt;文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。&lt;br&gt;&lt;img src=&quot;8-2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="http://yoursite.com/tags/APUE/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <link href="http://yoursite.com/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/"/>
    <id>http://yoursite.com/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</id>
    <published>2020-02-23T09:03:12.000Z</published>
    <updated>2020-02-23T09:46:38.283Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>malloc</code>和<code>calloc</code>分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用<code>mmap</code>或<code>sbrk</code>系统调用</li><li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此<code>mmap()</code>保证返回的新内存始终为零</li><li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li><li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从<code>mmap()</code>返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;calloc&lt;/code&gt;分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用&lt;code&gt;mmap&lt;/code&gt;或&lt;code&gt;sbrk&lt;/code&gt;系统调用&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C语言编程心得</title>
    <link href="http://yoursite.com/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</id>
    <published>2020-02-23T09:01:38.000Z</published>
    <updated>2020-02-23T09:04:45.491Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p></li><li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p></li><li><p>声明变量后一定要记得赋初识值，尤其是数组</p></li><li><p>变量就近声明</p></li><li><p>文件内使用的函数要习惯声明static</p></li><li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第七章——进程环境</title>
    <link href="http://yoursite.com/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</id>
    <published>2020-02-23T08:03:39.000Z</published>
    <updated>2020-03-02T13:01:55.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程开始"><a href="#进程开始" class="headerlink" title="进程开始"></a>进程开始</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure><p>   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>   有8种终止方式，前5种为正常终止：</p><ol><li>从main返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit<br>异常终止有3种：</li><li>调用abort</li><li>遇到一个信号</li><li>最后一个线程对取消请求做出响应</li></ol><h3 id="终止处理程序"><a href="#终止处理程序" class="headerlink" title="终止处理程序"></a>终止处理程序</h3><ul><li>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br> 调用顺序与登记顺序相反，登记多次也会调用多次。<br> 如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</li></ul><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a><code>exit</code>函数</h3><ul><li><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</li><li>内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。<br> <img src="7-2.png" alt=""><a id="more"></a><h3 id="环境变量与环境表"><a href="#环境变量与环境表" class="headerlink" title="环境变量与环境表"></a>环境变量与环境表</h3></li><li>通常用<code>getenv</code>和<code>putenv</code>访问特定的环境变量</li><li>我们能影响的通常只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程</li><li>环境表和环境字符串通常存放在进程存储空间的顶部（栈之上）<br> <img src="7-5.png" alt=""></li></ul><h3 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><ul><li>正文段。由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使频繁执行的程序在存储器中也只需要由一个副本。正文段通常是只读的，以防止程序由于意外而修改其指令。</li><li>初始化数据段，通常称为数据段。包含了明确赋初值的变量。例如C程序中任何函数之外的声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxcount = <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li><li>未初始化数据段，也称为bss（block started by symbol）段。程序开始执行前，内核将此段数据初始化为0或空指针。例如函数外的声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li><li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li><li>堆。通常用于进行动态存储分配。</li><li>未初始化数据段的内容并不存储在磁盘文件中，内核在程序运行前将它们设置为0.存放在磁盘文件中的段只有正文段和初始化数据段。<br> <img src="7-6.png" alt=""></li></ul><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul><li>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</li><li>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。</li><li>这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时或每个共享库函数第一次被调用时。</li><li>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑。</li></ul><h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><ul><li><code>malloc</code>分配指定字节数的存储区。其中的初始值不确定。</li><li><code>calloc</code>分配的每一位都初始化为0。</li><li><code>realloc</code>增加或减少分配区长度。新增区域内初始值不确定</li><li>这些分配例程通常通过<code>sbrk</code>系统调用实现</li><li><a href="../为什么calloc会比malloc-memset快">为什么calloc会比malloc+memset快</a></li><li>大部分<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。</li><li>大多数实现所分配的存储空间比要求的要大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。</li></ul><h3 id="内存分配时常见错误"><a href="#内存分配时常见错误" class="headerlink" title="内存分配时常见错误"></a>内存分配时常见错误</h3><ul><li>在动态分配的缓冲区前后进行写操作，破坏管理记录信息或用于其他动态分配的对象。</li><li>释放一个已经释放了的块</li><li>调用free时的指针不是三个alloc函数的返回值</li><li>调用malloc不调用free，造成内存泄漏。进程地址空间长度会慢慢增加，直至没有空闲空间。此时由于过度的换页开销，会导致性能下降。</li></ul><h3 id="setjump与longjump"><a href="#setjump与longjump" class="headerlink" title="setjump与longjump"></a>setjump与longjump</h3><ul><li>C语言中goto是无法跨域函数的，而执行这种类型的跳转功能的函数是setjmp和longjmp。</li></ul><h3 id="getrlimit和setrlimit"><a href="#getrlimit和setrlimit" class="headerlink" title="getrlimit和setrlimit"></a>getrlimit和setrlimit</h3><ul><li>每个进程都有一组资源限制，由getrlimit和setrlimit函数查询和更改。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程开始&quot;&gt;&lt;a href=&quot;#进程开始&quot; class=&quot;headerlink&quot; title=&quot;进程开始&quot;&gt;&lt;/a&gt;进程开始&lt;/h3&gt;   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。&lt;/p&gt;
&lt;h3 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h3&gt;&lt;p&gt;   有8种终止方式，前5种为正常终止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从main返回&lt;/li&gt;
&lt;li&gt;调用exit&lt;/li&gt;
&lt;li&gt;调用_exit或_Exit&lt;/li&gt;
&lt;li&gt;最后一个线程从启动例程返回&lt;/li&gt;
&lt;li&gt;从最后一个线程调用pthread_exit&lt;br&gt;异常终止有3种：&lt;/li&gt;
&lt;li&gt;调用abort&lt;/li&gt;
&lt;li&gt;遇到一个信号&lt;/li&gt;
&lt;li&gt;最后一个线程对取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;终止处理程序&quot;&gt;&lt;a href=&quot;#终止处理程序&quot; class=&quot;headerlink&quot; title=&quot;终止处理程序&quot;&gt;&lt;/a&gt;终止处理程序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个进程可以通过&lt;code&gt;atexit&lt;/code&gt;函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有&lt;code&gt;exit&lt;/code&gt;自动调用。&lt;br&gt; 调用顺序与登记顺序相反，登记多次也会调用多次。&lt;br&gt; 如若程序调用&lt;code&gt;exec&lt;/code&gt;函数族中任一函数，则将清除所有已安装的终止处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;exit函数&quot;&gt;&lt;a href=&quot;#exit函数&quot; class=&quot;headerlink&quot; title=&quot;exit函数&quot;&gt;&lt;/a&gt;&lt;code&gt;exit&lt;/code&gt;函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_exit&lt;/code&gt;和&lt;code&gt;_Exit&lt;/code&gt;立即进入内核，&lt;code&gt;exit&lt;/code&gt;首先调用各终止处理程序，然后通过&lt;code&gt;fclose&lt;/code&gt;关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。&lt;/li&gt;
&lt;li&gt;内核使程序执行的唯一方法是调用一个&lt;code&gt;exec&lt;/code&gt;函数。进程自愿终止的唯一方法是显示或隐式地（通过调用&lt;code&gt;exit&lt;/code&gt;）调用&lt;code&gt;_exit&lt;/code&gt;或&lt;code&gt;_Exit&lt;/code&gt;。进程也可非自愿地由一个信号使其终止。&lt;br&gt; &lt;img src=&quot;7-2.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="http://yoursite.com/tags/APUE/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>first post</title>
    <link href="http://yoursite.com/2020/02/23/first-post/"/>
    <id>http://yoursite.com/2020/02/23/first-post/</id>
    <published>2020-02-23T07:26:11.000Z</published>
    <updated>2020-02-23T07:26:29.021Z</updated>
    
    <content type="html"><![CDATA[<p>I love you, Joyce!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I love you, Joyce!&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
