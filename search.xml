<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>strlen与sizeof区别</title>
    <url>/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度</li>
<li>strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>第八章——进程控制</title>
    <url>/2020/03/02/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><ul>
<li>每个进程都有一个非负整型表示的唯一进程ID</li>
<li>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。</li>
<li>进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。</li>
<li>init读取与系统有关的初始化文件，并将系统引导到一个状态。</li>
<li>init进程不会终止，它是一个普通的用户进程，以超级用户特权运行；交换进程是内核中的系统进程。</li>
</ul>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1</li>
<li>子进程和父进程继续执行fork之后的指令；子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段</li>
<li>fork时用到<code>写时复制（Copy-On-Write）</code>技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”</li>
<li>fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法</li>
<li>文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。<br><img src="8-2.png" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <url>/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</url>
    <content><![CDATA[<ol>
<li><code>malloc</code>和<code>calloc</code>分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用<code>mmap</code>或<code>sbrk</code>系统调用</li>
<li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此<code>mmap()</code>保证返回的新内存始终为零</li>
<li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li>
<li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从<code>mmap()</code>返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>C语言编程心得</title>
    <url>/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p>
</li>
<li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p>
</li>
<li><p>声明变量后一定要记得赋初识值，尤其是数组</p>
</li>
<li><p>变量就近声明</p>
</li>
<li><p>文件内使用的函数要习惯声明static</p>
</li>
<li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>第七章——进程环境</title>
    <url>/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="进程开始"><a href="#进程开始" class="headerlink" title="进程开始"></a>进程开始</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure>
<p>   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>   有8种终止方式，前5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从启动例程返回</li>
<li>从最后一个线程调用pthread_exit<br>异常终止有3种：</li>
<li>调用abort</li>
<li>遇到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="终止处理程序"><a href="#终止处理程序" class="headerlink" title="终止处理程序"></a>终止处理程序</h3><ul>
<li>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br> 调用顺序与登记顺序相反，登记多次也会调用多次。<br> 如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</li>
</ul>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a><code>exit</code>函数</h3><ul>
<li><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</li>
<li>内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。<br> <img src="7-2.png" alt=""><a id="more"></a>
<h3 id="环境变量与环境表"><a href="#环境变量与环境表" class="headerlink" title="环境变量与环境表"></a>环境变量与环境表</h3></li>
<li>通常用<code>getenv</code>和<code>putenv</code>访问特定的环境变量</li>
<li>我们能影响的通常只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程</li>
<li>环境表和环境字符串通常存放在进程存储空间的顶部（栈之上）<br> <img src="7-5.png" alt=""></li>
</ul>
<h3 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><ul>
<li>正文段。由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使频繁执行的程序在存储器中也只需要由一个副本。正文段通常是只读的，以防止程序由于意外而修改其指令。</li>
<li>初始化数据段，通常称为数据段。包含了明确赋初值的变量。例如C程序中任何函数之外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxcount = <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li>未初始化数据段，也称为bss（block started by symbol）段。程序开始执行前，内核将此段数据初始化为0或空指针。例如函数外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常用于进行动态存储分配。</li>
<li>未初始化数据段的内容并不存储在磁盘文件中，内核在程序运行前将它们设置为0.存放在磁盘文件中的段只有正文段和初始化数据段。<br> <img src="7-6.png" alt=""></li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul>
<li>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</li>
<li>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。</li>
<li>这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时或每个共享库函数第一次被调用时。</li>
<li>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑。</li>
</ul>
<h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><ul>
<li><code>malloc</code>分配指定字节数的存储区。其中的初始值不确定。</li>
<li><code>calloc</code>分配的每一位都初始化为0。</li>
<li><code>realloc</code>增加或减少分配区长度。新增区域内初始值不确定</li>
<li>这些分配例程通常通过<code>sbrk</code>系统调用实现</li>
<li><a href="../为什么calloc会比malloc-memset快">为什么calloc会比malloc+memset快</a></li>
<li>大部分<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。</li>
<li>大多数实现所分配的存储空间比要求的要大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。</li>
</ul>
<h3 id="内存分配时常见错误"><a href="#内存分配时常见错误" class="headerlink" title="内存分配时常见错误"></a>内存分配时常见错误</h3><ul>
<li>在动态分配的缓冲区前后进行写操作，破坏管理记录信息或用于其他动态分配的对象。</li>
<li>释放一个已经释放了的块</li>
<li>调用free时的指针不是三个alloc函数的返回值</li>
<li>调用malloc不调用free，造成内存泄漏。进程地址空间长度会慢慢增加，直至没有空闲空间。此时由于过度的换页开销，会导致性能下降。</li>
</ul>
<h3 id="setjump与longjump"><a href="#setjump与longjump" class="headerlink" title="setjump与longjump"></a>setjump与longjump</h3><ul>
<li>C语言中goto是无法跨域函数的，而执行这种类型的跳转功能的函数是setjmp和longjmp。</li>
</ul>
<h3 id="getrlimit和setrlimit"><a href="#getrlimit和setrlimit" class="headerlink" title="getrlimit和setrlimit"></a>getrlimit和setrlimit</h3><ul>
<li>每个进程都有一组资源限制，由getrlimit和setrlimit函数查询和更改。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>first post</title>
    <url>/2020/02/23/first-post/</url>
    <content><![CDATA[<p>I love you, Joyce!</p>
]]></content>
  </entry>
</search>
