<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《UNIX环境高级编程》第十章——信号</title>
    <url>/2020/03/13/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>信号是软件中断。它提供了一种处理异步事件的方法。每个信号都有一个名字，以SIG开头。在头文件&lt;signal.h&gt;中，信号名都被定义为正整数常量（信号编号）。<br>不存在编号为0的信号。kill函数对信号编号0有特殊的作用。POSIX.1将此中信号编号值称为空信号。<br>信号出现时，内核按下列三种方式之一进行处理：</p>
<ul>
<li>忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号决不能被忽略，它们是SIGKILL和SIGSTOP。原因是它们想内核提供了使进程终止或停止的可靠方法。</li>
<li>捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个可执行用户希望对这种事件进行的处理的用户函数。</li>
<li>执行系统默认动作。对大多数信号的系统默认动作是终止该进程。<br><img src="10-1.png" alt=""></li>
</ul>
<a id="more"></a>

<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void (*signal(int signo, void (*func)(int)))(int);</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, Sigfunc *)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGUSR1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err_dump(<span class="string">"received signal %d\n"</span>, signo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：在UNIX系统中，杀死（kill）这个术语是不恰当的。kill（1）命令和kill（2）函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号</em></p>
<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。<br>当进程执行一个新程序后，信号捕捉函数的地址很可能在所执行的新程序文件中已无意义。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果信号处理程序返回（例如没有调用exit或longjmp），则继续执行在捕捉到信号时进程正在执行的正常指令序列。</p>
<p>Single UNIX Specifiation 说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是异步信号安全的。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。</p>
<h2 id="可靠信号术语和语义"><a href="#可靠信号术语和语义" class="headerlink" title="可靠信号术语和语义"></a>可靠信号术语和语义</h2><p>首先，当造成信号事件的发生时，为进程<code>产生</code>一个信号（或向一个进程发送一个信号）。事件可以是硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用kill函数。当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。</p>
<p>当对信号采取了这种动作时，我们说向进程<code>递送</code>了一个信号。在信号<code>产生（generation）</code>和<code>递送（delivery）</code>之间的时间间隔内，称信号是<code>未决的（pending）</code>。</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不是在产生该信号时），才决定对它的处理方式。</p>
<p>POSIX.1允许系统递送该信号一次或多次。如果多次则排队。但除非支持POSIX.1实时扩展，否则大多数UNIX并不排队，而是只递送这种信号一次。</p>
<p>每个进程都一个信号屏蔽字（singal mask），它规定了当前要阻塞递送该进程的信号集。</p>
<h2 id="函数kill-和-raise"><a href="#函数kill-和-raise" class="headerlink" title="函数kill 和 raise"></a>函数kill 和 raise</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>
<p>kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。</p>
<h2 id="函数alarm-和-pause"><a href="#函数alarm-和-pause" class="headerlink" title="函数alarm 和 pause"></a>函数alarm 和 pause</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    /\* nothing to <span class="keyword">do</span>, just <span class="keyword">return</span> to wake up the pause \*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sleep1(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册信号处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置闹钟</span></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    <span class="comment">//暂停</span></span><br><span class="line">    pause();</span><br><span class="line">    <span class="comment">//关掉闹钟</span></span><br><span class="line">    <span class="keyword">return</span> alarm(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep1存在3个问题：</p>
<ol>
<li>如果调用alarm前设置了闹钟，则它被sleep1函数中的第一次alarm调用擦除。更正方法：检查第一次调用的返回值，如果小于本次调用的参数值，则只应等待超时例如过大于本次参数，则在sleep1函数返回前，重置此闹钟，使其再次发生超时。</li>
<li>该程序修改了对SIGALRM的配置。如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正方法：保存signal函数的返回值，在返回前重置原配置。</li>
<li>在第一次调用alarm和pause之间有一个竞争条件。在一个繁忙的系统中，可能alarm在调用pause之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用pause后，如果没有捕捉到其他信号，调用者将永远被挂起。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">        alarm(seconds);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alarm(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep2通过longjmp的方式解决了sleep1中的竞争条件问题，但带来了另外一个问题：它涉及与其他信号的交互。如果SIGALRM中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"signal(SIGINT) error"</span>);</span><br><span class="line">    unslept = sleep2(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sleep2 returned: %u\n"</span>, unslept);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Tune these loops to <span class="built_in">run</span> <span class="keyword">for</span> more than <span class="number">5</span> seconds</span><br><span class="line">     \* on whatever system <span class="keyword">this</span> test program is <span class="built_in">run</span>.</span><br><span class="line">     \*/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nsig_int starting\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">300000</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4000</span>; j++)</span><br><span class="line">            k += i * j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig_int finished\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">^C</span><br><span class="line">sig_int starting</span><br><span class="line">sig_int finished</span><br><span class="line">sleep2 returned: 2</span><br></pre></td></tr></table></figure>

<p>从中可见sleep2函数所引起的longjmp使另一个信号处理程序sig_int提早终止，即使它未完成也会如此。</p>
<p><em>sleep1 和 sleep2 函数的这两个实例告诉我们在涉及信号时需要有精细而周到的考虑。</em></p>
<p>除了用来实现sleep函数外，alarm还常用语对可能阻塞的操作设置时间上线值。例如，程序中有一个读低速设备的可能阻塞的操作，我们希望超过一定时间量后就停止执行该操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, <span class="built_in">line</span>, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="built_in">line</span>, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    /\* nothing to <span class="keyword">do</span>, just <span class="keyword">return</span> to interrupt the <span class="built_in">read</span> \*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种程序有两个问题：</p>
<ol>
<li>第一次调用alarm与read之间存在竞争条件。大多数解决方案是把闹钟的时长设置久一点。</li>
<li>如果系统调用是自动重启的，则当alarm信号处理程序返回时，read并不被中断。这种情况下，设置时间限制不起作用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR) &#123;</span><br><span class="line">        err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env_alrm) != <span class="number">0</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"read timeout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, <span class="built_in">line</span>, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="built_in">line</span>, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的程序不管系统是否重新启动被中断的系统调用都能正常工作，但仍旧存在与其他信号处理程序交互的问题。</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>一个能表示多个信号的数据类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(sigset *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(sigset *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(sigset_st *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数-sigprocmask"><a href="#函数-sigprocmask" class="headerlink" title="函数 sigprocmask"></a>函数 sigprocmask</h3><p>一个进程信号屏蔽字规定了当前阻塞而不能递送该进程的信号集。调用函数 sigprocmask 可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。</p>
<h3 id="函数-sigpending"><a href="#函数-sigpending" class="headerlink" title="函数 sigpending"></a>函数 sigpending</h3><p>sigpending返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> newmask, oldmask, pendmask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, sig_quit) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"can't catch SIGQUIT"</span>);</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Block SIGQUIT <span class="keyword">and</span> save current signal mask.</span><br><span class="line">     \*/</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);    /\* SIGQUIT here will remain pending \*/</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigpending(&amp;pendmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"sigpending error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigismember(&amp;pendmask, SIGQUIT))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nSIGQUIT pending\n"</span>);</span><br><span class="line"></span><br><span class="line">    /\*</span><br><span class="line">     \* Restore signal mask which unblocks SIGQUIT.</span><br><span class="line">     \*/</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGQUIT unblocked\n"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);    /\* SIGQUIT here will <span class="built_in">terminate</span> with core file \*/</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"caught SIGQUIT\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"can't reset SIGQUIT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-sigaction"><a href="#函数-sigaction" class="headerlink" title="函数 sigaction"></a>函数 sigaction</h3><p>它的功能是检查或（并）修改与指定信号相关联的处理动作。它取代了UNIX早期版本的signal函数。</p>
<h3 id="函数-sigsetjmp-与-siglongjmp"><a href="#函数-sigsetjmp-与-siglongjmp" class="headerlink" title="函数 sigsetjmp 与 siglongjmp"></a>函数 sigsetjmp 与 siglongjmp</h3><p>它们比setjmp与longjmp多了一个参数，用来保存当前信号的屏蔽字，用于在调用siglongjmp时恢复。</p>
<h3 id="函数-sigsuspend"><a href="#函数-sigsuspend" class="headerlink" title="函数 sigsuspend"></a>函数 sigsuspend</h3><p>它在一个原子操作中先恢复信号屏蔽字，再使进程休眠。解决了信号丢失的问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">pause();</span><br><span class="line"><span class="comment">//当信号放生在sigprocmask与pause之间时，信号就丢失了，进程将永远阻塞</span></span><br></pre></td></tr></table></figure>
<p>另一种应用是等待一个信号处理程序设置一个全局变量，以此实现父、子进程之间的同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../apue.3e/include/apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> sigflag; <span class="comment">/* set nonzero by sig handler * /</span></span><br><span class="line"><span class="comment">static sigset_t newmask, oldmask, zeromask;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void sig_usr(int signo)    /* one signal handler for SIGUSR1 and SIGUSR2 * /</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    sigflag = 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void TELL_WAIT(void) &#123;</span></span><br><span class="line"><span class="comment">    if (signal(SIGUSR1, sig_usr) == SIG_ERR)</span></span><br><span class="line"><span class="comment">        err_sys("signal(SIGUSR1) error");</span></span><br><span class="line"><span class="comment">    if (signal(SIGUSR2, sig_usr) == SIG_ERR)</span></span><br><span class="line"><span class="comment">        err_sys("signal(SIGUSR2) error");</span></span><br><span class="line"><span class="comment">    sigemptyset(&amp;zeromask);</span></span><br><span class="line"><span class="comment">    sigemptyset(&amp;newmask);</span></span><br><span class="line"><span class="comment">    sigaddset(&amp;newmask, SIGUSR1);</span></span><br><span class="line"><span class="comment">    sigaddset(&amp;newmask, SIGUSR2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TELL_PARENT</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    kill(pid, SIGUSR2);        <span class="comment">/* tell parent we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAIT_PARENT</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;zeromask);    <span class="comment">/* and wait for parent */</span></span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TELL_CHILD</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    kill(pid, SIGUSR1);            <span class="comment">/* tell child we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAIT_CHILD</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;zeromask);    <span class="comment">/* and wait for child */</span></span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果等待信号发生时希望去休眠，则使用sigsuspend函数非常合适，但如果在等待信号期间希望调用其他系统函数，在单线程环境下没有妥善的解决办法。如果不使用线程，我们能尽力做到最好的是：当信号发生时，在信号捕捉程序中对一个全局变量置1。</strong></p>
]]></content>
      <categories>
        <category>《APUE》笔记</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX环境高级编程》第九章——进程关系</title>
    <url>/2020/03/08/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关，可以是基于字符的终端、仿真基于字符终端的图形终端，或者运行窗口系统的图形终端。</p>
<h3 id="BSD终端登录"><a href="#BSD终端登录" class="headerlink" title="BSD终端登录"></a>BSD终端登录</h3><p>系统管理者创建通常名为/etc/ttys的文件，其中每个终端设备都有一行，说明设备名和传到getty程序的参数。当系统自举时，内核创建进程ID为1的进程，也就是init进程。<br>init进程使系统进入多用户模式。init读取文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则exec getty程序。<br><img src="9-1.png" alt=""></p>
<a id="more"></a>

<p>getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。<br>一旦设备被打开，则文件描述符0、1、2就被设置到该设备，然后getty输出“login：”之类的信息，等待用户键入用户名。<br>   <img src="9-2.png" alt=""></p>
<p>因为init进程具有超级用户特权，所以图9-2中的所有进程都有超级用户特权。图9-2中的下面三个进程ID相同，exec不会改变进程ID，父进程ID都为1。</p>
<p>如果用户正确登录，login将完成下列工作：</p>
<ul>
<li>将当前工作目录改为该用户的起始目录（chdir）。</li>
<li>调用chown更改该终端的所有权，使登录用户成为它的所有者。</li>
<li>将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用 setgid 及 initgroups 设置进程的组ID。</li>
<li>用 login 得到的所有信息初始化环境：起始目录（HOME）、shell（SHELL）、用户名（USER和LOGNAME）以及一个系统默认路径（PATH）。</li>
<li>login 进程更改为登录用户的用户ID（setuid）并调用该用户登录的shell，其方式类似于：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"-sh"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li>其他任务（打印日期消息文件、检查新邮件等）</li>
</ul>
<p>至此，登录用户的登录shell开始运行。其父进程ID是init进程，所以此登录shell终止时，init会等到通知（接到SIGCHLD信号），它会对该终端重复全部上述过程。登录shell的文件描述符0、1和2设置为终端设备。<br>   <img src="9-3.png" alt=""></p>
<h3 id="Mac-OS-X-终端登录"><a href="#Mac-OS-X-终端登录" class="headerlink" title="Mac OS X 终端登录"></a>Mac OS X 终端登录</h3><p>Mac OS X部分地基于FreeBSD，所以其终端登录进程与BSD基本一致，不同之处在于：</p>
<ul>
<li>init的工作是由launchd完成的。</li>
<li>一开始提供的就是图形终端</li>
</ul>
<h3 id="Linux-终端登录"><a href="#Linux-终端登录" class="headerlink" title="Linux 终端登录"></a>Linux 终端登录</h3><p>Linux的终端登录过程非常类似于BSD。Linux login命令是从4.3BSD login命令派生出来的。登录过程的主要区别在于说明终端配置的方式。</p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和由网络登录至系统两者之间的主要（物理上的）区别是：网络登录时，在终端和计算机之间的连接不再是点到点的。在网络登录情况下，login仅仅是一种可用的服务，这与其他网络服务（如FTP、SMTP）的性质相同。<br>所有登录都经由内核的网络接口驱动程序（如以太网驱动程序），而且事先并不知道会有多少这样的登录。因此必须等待一个网络请求的到达，而不是使一个进程等待每一个可能的登录。</p>
<h3 id="BSD网络登录"><a href="#BSD网络登录" class="headerlink" title="BSD网络登录"></a>BSD网络登录</h3><p>在BSD中，有一个inetd进程，它等待大多数网络连接。作为系统启动的一部分，init调用一个shell，使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后生成的子进程exec适当的程序。</p>
<p><img src="9-4.png" alt=""></p>
<p><img src="9-5.png" alt=""></p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID之外，还属于一个进程组。进程组是一个或多个进程的集合。<br>通常，它们是同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID——它是一个正整数，并可存放在pid_t数据类型中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。<br>进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命<br>周期。某个进程组的最后一个进程可以终止，也可以转移到另一个进程组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话（session）是一个或多个进程组的集合。<br><img src="9-6.png" alt=""><br>进程调用setsid函数建立一个新会话。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体发生以下3件事：</p>
<ol>
<li>该进程变成新会话的会话首进程（session leader）。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端。如果调用setsid之前由，那么这种联系也被切断。</li>
</ol>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性：</p>
<ul>
<li>一个会话可以有一个控制终端（controlling terminal）。这通常是终端设备（在终端登录情况下）或伪终端设备（在网络登录情况下）。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程（controlling process）。</li>
<li>一个会话中的几个进程组可被分成一个前台进程组（foreground process group）以及一个或多个后台进程组（background process group）。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li>
<li>无论何时键入终端的中断键（通常是Delete或Ctrl+C），都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键（通常是Ctrl+\）,都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（会话首进程）。<br><img src="9-7.png" alt=""></li>
</ul>
<h2 id="获取、设置前台进程组ID，获取会话首进程的会话ID（会话首进程的进程组ID）"><a href="#获取、设置前台进程组ID，获取会话首进程的会话ID（会话首进程的进程组ID）" class="headerlink" title="获取、设置前台进程组ID，获取会话首进程的会话ID（会话首进程的进程组ID）"></a>获取、设置前台进程组ID，获取会话首进程的会话ID（会话首进程的进程组ID）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetsid</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行。<br>用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合。<br><img src="9-9.png" alt=""></p>
<h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><p><img src="9.9.1.png" alt=""><br>在不支持作业控制的shell中，管道中的最后一个进程是shell的子进程，管道中的其他进程是最后一个进程的子进程。从中可以看出，shell fork一个它自身的副本，然后此副本再为管道中的每条命令各fork一个进程。<br><img src="9-10.png" alt=""><br>有作业控制时，后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号SIGTTIN。<br><img src="9.9.2.png" alt=""><br><img src="9.9.3.png" alt=""></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。另一种描述可以是：一个进程组不是孤儿进程组的条件是——该组中有一个进程，其父进程属于同一会话的另一个组中。如果进程组不是孤儿进程组，那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。<br><img src="9-11.png" alt=""><br>因为在父进程终止后，进程组包含一个停止的进程，进程组称为孤儿进程组，POSIX。1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号（SIGHUP），接着又向其发送继续信号（SIGCONT）。<br>在处理了挂断信号后，子进程继续。对挂断信号的系统默认动作是终止该进程。</p>
<h2 id="FreeBSD实现"><a href="#FreeBSD实现" class="headerlink" title="FreeBSD实现"></a>FreeBSD实现</h2><p><img src="9-13.png" alt=""><br>每个会话都分配一个session结构。在调用setsid时，在内核分配一个心得session结构。</p>
]]></content>
      <categories>
        <category>《APUE》笔记</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>vnode与inode区别</title>
    <url>/2020/03/08/vnode%E4%B8%8Einode%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="vnode与inode的区别"><a href="#vnode与inode的区别" class="headerlink" title="vnode与inode的区别"></a>vnode与inode的区别</h1><blockquote>
<p>文章整理自  <a href="https://www.freebsd.org/cgi/man.cgi?query=vnode" target="_blank" rel="noopener">FreeBSD docs</a> 和  <a href="https://stackoverflow.com/questions/27345342/inode-vs-vnode-difference" target="_blank" rel="noopener">StackOverflow</a></p>
</blockquote>
<h2 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h2><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>vnode —— 文件或目录的内部表示</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/vnode.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul>
<li>vnode是UNIX中所有文件活动的焦点。</li>
<li>vnode节点由<code>struct vnode</code>声明。</li>
<li>每个活动文件、当前目录、挂载文件、文本文件和根目录都分配了一个vnode节点。</li>
<li>vnode最初是为FreeBSD创建的，因为需要使用的不同类型的文件系统（例如UFS、NFS等）激增。</li>
<li>Vnode旨在为所有可能的文件系统提供抽象，以便OS可以与它们进行对接，从而让内核方法不必兼容每个特定的文件系统；内核只需要知道如何与Vnode进行交互。</li>
<li>Vnode抽象在内存中，可以与UFS、ext4等文件系统进行交互；而inode存储在磁盘上，只能用于特定的文件系统。</li>
<li>inode节点包含文件大小、拥有者、指向地址块的指针等元数据。</li>
<li>vnode仅包含在文件生命周期中不会改变的一些属性，因此如果想获得更多信息请使用inode作为参考。</li>
</ul>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>File System</tag>
      </tags>
  </entry>
  <entry>
    <title>strlen与sizeof区别</title>
    <url>/2020/03/02/strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度</li>
<li>strlen需要进行一次函数调用，而对于sizeof，缓冲区长度在编译时计算，是固定的</li>
</ul>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX环境高级编程》第八章——进程控制</title>
    <url>/2020/03/02/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><ul>
<li>每个进程都有一个非负整型表示的唯一进程ID</li>
<li>ID为0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。</li>
<li>进程ID 1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件是/etc/init或/sbin/init。此进程负责在自举内核后启动一个UNIX系统。</li>
<li>init读取与系统有关的初始化文件，并将系统引导到一个状态。</li>
<li>init进程不会终止，它是一个普通的用户进程，以超级用户特权运行；交换进程是内核中的系统进程。</li>
</ul>
<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><ul>
<li>调用一次，返回两次。子进程返回0，父进程返回子进程ID，出错返回-1</li>
<li>子进程和父进程继续执行fork之后的指令；子进程获得父进程数据空间、堆、栈的副本；子进程和父进程共享正文段</li>
<li>fork时用到<code>写时复制（Copy-On-Write）</code>技术，这些区域由父进程和子进程共享，内核将他们的访问权限改为只读，当任一进程尝试修改时，内核只为修改区域的那块内存制作一个副本，通常是虚拟内存中的一“页”</li>
<li>fork后先执行哪个进程是不确定的，取决于内核所使用的调度算法</li>
<li>文件共享。父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项（包括文件偏移量）。<br><img src="8-2.png" alt=""></li>
</ul>
<a id="more"></a>

<h3 id="子进程从父进程继承"><a href="#子进程从父进程继承" class="headerlink" title="子进程从父进程继承"></a>子进程从父进程继承</h3><ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开间描述符的执行时关闭（close-on-exec）标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<h3 id="父进程与子进程的区别"><a href="#父进程与子进程的区别" class="headerlink" title="父进程与子进程的区别"></a>父进程与子进程的区别</h3><ul>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>这两个进程的父进程ID不同</li>
<li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集<ul>
<li>fork失败的两个主要原因：</li>
</ul>
</li>
<li>系统中已经有了太多的进程</li>
<li>该用户ID的进程总数超过了系统的限制</li>
</ul>
<h2 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h2><ul>
<li>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。</li>
<li>vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。</li>
<li>vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中任意一个时，父进程会恢复运行。</li>
</ul>
<h2 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h2><ul>
<li>进程的5种正常终止方式：<ul>
<li>在main函数内执行return语句。等效于调用exit</li>
<li>调用exit函数。由ISO C定义，其操作包括调用各终止处理程序，关闭所有标准I/O流等</li>
<li>调用_exit或_Exit函数。ISO C定义_Exit，目的是提供一种无需运行终止处理程序和信号处理程序的方法。对标准I/O流是否进行冲洗，这取决于实现。</li>
<li>进程的最后一个线程在启动例程中执行return语句。</li>
<li>进程的最后一个线程调用pthread_exit函数。</li>
</ul>
</li>
<li>进程的3种异常终止方式：<ul>
<li>调用abort，它产生SIGABRT信号</li>
<li>当进程接收到某种信号时</li>
<li>最后一个线程对“取消”请求做出响应。</li>
</ul>
</li>
<li>不管进程如何终止，最后内核都会为相应进程关闭所有打开描述符，释放它所使用的存储器等。所以大多数exit的现代实现不再关闭流</li>
</ul>
<h3 id="终止进程如何通知父进程它是如何终止的？"><a href="#终止进程如何通知父进程它是如何终止的？" class="headerlink" title="终止进程如何通知父进程它是如何终止的？"></a>终止进程如何通知父进程它是如何终止的？</h3><p>对于三个终止函数（exit、_exit和_Exit），将其<code>退出状态</code>作为参数传递给函数。对于异常终止情况，内核（不是进程本身）产生一个指示其终止原因的<code>终止状态</code>。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态。</p>
<h3 id="父进程在子进程之前终止会怎样？"><a href="#父进程在子进程之前终止会怎样？" class="headerlink" title="父进程在子进程之前终止会怎样？"></a>父进程在子进程之前终止会怎样？</h3><p>对于父进程已经终止的所有进程，它们的父进程都改变为init进程（称为由init进程收养）。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，如果是正要终止进程的子进程，则将该进程的父进程ID改为1。</p>
<h3 id="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"><a href="#如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？" class="headerlink" title="如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？"></a>如果子进程在父进程之前终止，父进程如何获得子进程的终止状态？</h3><p>如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。包括进程ID、终止状态和CPU时间总量。</p>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵尸进程。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵尸进程。</p>
<h3 id="一个由init进程收养的进程终止后会不会变成僵尸进程？"><a href="#一个由init进程收养的进程终止后会不会变成僵尸进程？" class="headerlink" title="一个由init进程收养的进程终止后会不会变成僵尸进程？"></a>一个由init进程收养的进程终止后会不会变成僵尸进程？</h3><p>不会的。因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。</p>
<h2 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h3><ul>
<li>成功返回进程id，出错返回0或-1</li>
<li>statloc是一个整型指针，保存终止进程的终止状态，当它是一个空指针时，则不保存</li>
</ul>
<h3 id="调用wait或waitpid会发生什么？"><a href="#调用wait或waitpid会发生什么？" class="headerlink" title="调用wait或waitpid会发生什么？"></a>调用wait或waitpid会发生什么？</h3><ul>
<li>如果所有子进程都还在运行，则阻塞</li>
<li>如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程，则立即出错返回</li>
</ul>
<h3 id="两个函数的区别"><a href="#两个函数的区别" class="headerlink" title="两个函数的区别"></a>两个函数的区别</h3><ul>
<li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞</li>
<li>waitpid并不等待其调用之后的第一个子进程终止，它有若干选项，可以控制它所等待的进程</li>
</ul>
<h3 id="其他相关函数"><a href="#其他相关函数" class="headerlink" title="其他相关函数"></a>其他相关函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>与waitpid相似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *resage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>这两个函数提供的功能比wait、waitpid和waitid要多一个，与附加参数有关。该参数允许内核返回由终止进程及其所有子进程所使用的资源概况。</li>
</ul>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><ul>
<li>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件。</li>
<li>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。</li>
<li>如果一个进程要等待其父进程终止，则可使用下列形式的循环：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>) &#123;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种形式的循环称为<code>轮询（polling）</code>，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试</li>
<li>为了避免竞争条件和轮询，在多个进程之间需要某种形式的信号发送和接收的方法。包括信号机制和进程间通信（IPC）</li>
</ul>
<h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><h3 id="函数说明-2"><a href="#函数说明-2" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//此处省略参数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，从main函数开始执行。</li>
<li>exec不创建新进程，进程ID不变。</li>
<li>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</li>
<li>7个函数的关系：<br><img src="8-15.png" alt=""></li>
</ul>
<h2 id="更改用户ID、组ID"><a href="#更改用户ID、组ID" class="headerlink" title="更改用户ID、组ID"></a>更改用户ID、组ID</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="8-19.png" alt=""></p>
]]></content>
      <categories>
        <category>《APUE》笔记</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <url>/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</url>
    <content><![CDATA[<ol>
<li><code>malloc</code>和<code>calloc</code>分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用<code>mmap</code>或<code>sbrk</code>系统调用</li>
<li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此<code>mmap()</code>保证返回的新内存始终为零</li>
<li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li>
<li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从<code>mmap()</code>返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li>
</ol>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX环境高级编程》第七章——进程环境</title>
    <url>/2020/02/23/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="进程开始"><a href="#进程开始" class="headerlink" title="进程开始"></a>进程开始</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure>
<p>   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>   有8种终止方式，前5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从启动例程返回</li>
<li>从最后一个线程调用pthread_exit<br>异常终止有3种：</li>
<li>调用abort</li>
<li>遇到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="终止处理程序"><a href="#终止处理程序" class="headerlink" title="终止处理程序"></a>终止处理程序</h3><ul>
<li>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br> 调用顺序与登记顺序相反，登记多次也会调用多次。<br> 如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</li>
</ul>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a><code>exit</code>函数</h3><ul>
<li><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</li>
<li>内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。<br> <img src="7-2.png" alt=""><a id="more"></a>
<h3 id="环境变量与环境表"><a href="#环境变量与环境表" class="headerlink" title="环境变量与环境表"></a>环境变量与环境表</h3></li>
<li>通常用<code>getenv</code>和<code>putenv</code>访问特定的环境变量</li>
<li>我们能影响的通常只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程</li>
<li>环境表和环境字符串通常存放在进程存储空间的顶部（栈之上）<br> <img src="7-5.png" alt=""></li>
</ul>
<h3 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><ul>
<li>正文段。由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使频繁执行的程序在存储器中也只需要由一个副本。正文段通常是只读的，以防止程序由于意外而修改其指令。</li>
<li>初始化数据段，通常称为数据段。包含了明确赋初值的变量。例如C程序中任何函数之外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxcount = <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li>未初始化数据段，也称为bss（block started by symbol）段。程序开始执行前，内核将此段数据初始化为0或空指针。例如函数外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常用于进行动态存储分配。</li>
<li>未初始化数据段的内容并不存储在磁盘文件中，内核在程序运行前将它们设置为0.存放在磁盘文件中的段只有正文段和初始化数据段。<br> <img src="7-6.png" alt=""></li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul>
<li>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</li>
<li>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。</li>
<li>这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时或每个共享库函数第一次被调用时。</li>
<li>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑。</li>
</ul>
<h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><ul>
<li><code>malloc</code>分配指定字节数的存储区。其中的初始值不确定。</li>
<li><code>calloc</code>分配的每一位都初始化为0。</li>
<li><code>realloc</code>增加或减少分配区长度。新增区域内初始值不确定</li>
<li>这些分配例程通常通过<code>sbrk</code>系统调用实现</li>
<li><a href="../为什么calloc会比malloc-memset快">为什么calloc会比malloc+memset快</a></li>
<li>大部分<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。</li>
<li>大多数实现所分配的存储空间比要求的要大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。</li>
</ul>
<h3 id="内存分配时常见错误"><a href="#内存分配时常见错误" class="headerlink" title="内存分配时常见错误"></a>内存分配时常见错误</h3><ul>
<li>在动态分配的缓冲区前后进行写操作，破坏管理记录信息或用于其他动态分配的对象。</li>
<li>释放一个已经释放了的块</li>
<li>调用free时的指针不是三个alloc函数的返回值</li>
<li>调用malloc不调用free，造成内存泄漏。进程地址空间长度会慢慢增加，直至没有空闲空间。此时由于过度的换页开销，会导致性能下降。</li>
</ul>
<h3 id="setjump与longjump"><a href="#setjump与longjump" class="headerlink" title="setjump与longjump"></a>setjump与longjump</h3><ul>
<li>C语言中goto是无法跨域函数的，而执行这种类型的跳转功能的函数是setjmp和longjmp。</li>
</ul>
<h3 id="getrlimit和setrlimit"><a href="#getrlimit和setrlimit" class="headerlink" title="getrlimit和setrlimit"></a>getrlimit和setrlimit</h3><ul>
<li>每个进程都有一组资源限制，由getrlimit和setrlimit函数查询和更改。</li>
</ul>
]]></content>
      <categories>
        <category>《APUE》笔记</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>CS知识点总结</title>
    <url>/2019/03/17/CS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h2><h3 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h3><ol>
<li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ol>
<li>管道（半双工，只能父子间使用）</li>
<li>FIFO（命名管道，去除了父子间限制）</li>
<li>消息队列（消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难）</li>
<li>信号量（一个计数器，用于为多个进程提供对共享数据对象的访问。）</li>
<li>共享存储（允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC）</li>
<li>套接字（与其它通信机制不同的是，它可用于不同机器间的进程通信）</li>
</ol>
<a id="more"></a>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>必要条件</strong></p>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<p><strong>处理方法</strong></p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识点整理</title>
    <url>/2019/03/01/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="InnoDB与MyISAM区别："><a href="#InnoDB与MyISAM区别：" class="headerlink" title="InnoDB与MyISAM区别："></a>InnoDB与MyISAM区别：</h3><ol>
<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ol>
<h3 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h3><ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
</ol>
<a id="more"></a>

<h3 id="varchar和char的区别："><a href="#varchar和char的区别：" class="headerlink" title="varchar和char的区别："></a>varchar和char的区别：</h3><ol>
<li>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）</li>
<li>在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．</li>
<li>varchar最多能存储65535个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535bytes）。65535并不是一个很精确的上限，可以继续缩小这个上限。65535个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计。</li>
</ol>
<h3 id="null与最大长度"><a href="#null与最大长度" class="headerlink" title="null与最大长度:"></a>null与最大长度:</h3><ol>
<li>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要1bit来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位</li>
<li>如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</li>
<li>如果数据表只有一个varchar字段且该字段NOT NULL，那么该varchar字段的最大长度为65533个字节，即65535-2=65533byte</li>
<li>字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;</li>
<li>字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。</li>
<li>若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。</li>
</ol>
<h3 id="utf8-与-utf8mb4-："><a href="#utf8-与-utf8mb4-：" class="headerlink" title="utf8 与 utf8mb4 ："></a>utf8 与 utf8mb4 ：</h3><ol>
<li>utf-8中，一个字符最多3字节（汉字3字节，英文字母1字节）。</li>
<li>utf8_mb4是utf8的超集，一个字符最多4字节，支持补充字符。</li>
</ol>
<p>** 3、varchar物理存储**</p>
<p><strong>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。</strong></p>
<p><strong>当选择的字符集为latin1，一个字符占用一个byte</strong></p>
<p><strong>varchar(255)存储一个字符，一共使用2个bytes物理空间存储数据实际数据长度和数据值。</strong></p>
<p><strong>varchar(256)存储一个字符，使用2 bytes表示实际数据长度，一共需要3 bytes物理存储空间。</strong></p>
<p><strong>varchar对于不同的RDBMS引擎，有不通的物理存储方式，虽然有统一的逻辑意义。对于mysql的不同存储引擎，其实现方法与数据的物理存放方式也不同。</strong></p>
<p><strong>4、InnoDB中的varchar</strong></p>
<p><strong>InnoDB中varchar的物理存储方式与InnoDB使用的innodb_file_format有关。早期的innodb_file_forma使用的Antelope文件格式，支持redundant和compact两种row_format。从5.5开始或者InnoDB1.1，可以使用一种新的file format，Barracuda。Barracuda兼容Redundant，另外还支持dynamic和compressed两种row_format.</strong></p>
<p><strong>当innodb_file_format=Antelope，ROW_FORMAT=REDUNDANT 或者COMPACT。</strong></p>
<p><strong>innodb的聚集索引（cluster index）仅仅存储varchar、text、blob字段的前768个字节，多余的字节存储在一个独立的overflow page中，这个列也被称作off-page。768个字节前缀后面紧跟着20字节指针，指向overflow pages的位置。</strong></p>
<p><strong>另外，在innodb_file_format=Antelope情况下，InnoDB中最多能存储10个大字段（需要使用off-page存储）。innodbd的默认page size为16KB，InnoDB单行的长度不能超过16k/2=8k个字节，（768+20）*10 &lt; 8k。</strong></p>
<p><strong>当innodb_file_format=Barracuda, ROW_FORMAT=DYNAMIC 或者 COMPRESSED</strong></p>
<p><strong>innodb中所有的varchar、text、blob字段数据是否完全off-page存储，根据该字段的长度和整行的总长度而定。对off-page存储的列，cluster index中仅仅存储20字节的指针，指向实际的overflow page存储位置。如果单行的长度太大而不能完全适配cluster index page，innodb将会选择最长的列作为off-page存储，直到行的长度能够适配cluster index page。</strong></p>
<p><strong>5、MyISAM中的varchar</strong></p>
<p><strong>对于MyISAM引擎，varchar字段所有数据存储在数据行内（in-line）。myisam表的row_format也影响到varchar的物理存储行为。</strong></p>
<p><strong>MyISAM的row_format可以通过create或者alter sql语句设为fixed和dynamic。另外可以通过myisampack生成row_format=compresse的存储格式。</strong></p>
<p><strong>当myisam表中不存在text或者blob类型的字段，那么可以把row_format设置为fixed(也可以为dynamic)，否则只能为dynamic。</strong></p>
<p><strong>当表中存在varchar字段的时候，row_format可以设定为fixed或者dynamic。使用row_format=fixed存储varchar字段数据，浪费存储空间，varchar此时会定长存储。row_format为fixed和dynamic，varchar的物理实现方式也不同（可以查看源代码文件field.h和field.cc），因而myisam的row_format在fixed和dynamic之间发生转换的时候，varchar字段的物理存储方式也将会发生变化。</strong></p>
<h3 id="隔离级别："><a href="#隔离级别：" class="headerlink" title="隔离级别："></a>隔离级别：</h3><p><strong>一、首先什么是事务？</strong></p>
<p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<p>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消事务开始时的所有操作。</p>
<p><strong>二、事务的ACID</strong></p>
<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>
<p>1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</p>
<p>2 、一致性。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>
<p>3 、隔离性。一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p>
<p><strong>三、MySQL的四种隔离级别</strong></p>
<p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>
<p><strong>Read Uncommitted（读取未提交内容）</strong></p>
<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<p><strong>Read Committed（读取提交内容）</strong></p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果。</p>
<p><strong>Repeatable Read（可重读）</strong></p>
<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<p><strong>Serializable（可串行化）</strong></p>
<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。</p>
<p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5219651-fdd241489731111a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686/format/webp" alt="img"></p>
<p><strong>四**</strong>、事务隔离的原理是什么？**</p>
<p>我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。这里通过分析MySQL中InnoDB引擎的加锁机制，来抛砖引玉，让我们更好的理解，在事务处理中数据库到底做了什么。</p>
<p><strong>4.1、一次封锁or两段锁？</strong></p>
<p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p>
<p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。</p>
<p>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</p>
<p>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</p>
<blockquote>
<p><strong>事务                 加锁/解锁处理</strong></p>
<p>begin；</p>
<p>insert into test …..     # 加insert对应的锁</p>
<p>update test set…      # 加update对应的锁</p>
<p>delete from test ….   # 加delete对应的锁</p>
<p>commit;                    # 事务提交时，同时释放insert、update、delete对应的锁</p>
</blockquote>
<p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p>
<p><strong>4.2、事务中的加锁方式</strong></p>
<p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。</p>
<p>我们在前面已经介绍了MySQL的四种隔离级别：</p>
<blockquote>
<p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p>
<p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</p>
<p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p>
<p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p>
</blockquote>
<p><strong>Read UnCommitted（读取未提交内容）</strong></p>
<p>Read Uncommitted这种级别，数据库一般都不会用，而且任何操作都不会加锁，这里就不讨论了。</p>
<blockquote>
<p>MySQL中锁的种类：</p>
<p>MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等,表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。</p>
<p>行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。这里主要讨论的也就是行锁。</p>
</blockquote>
<p><strong>Read Committed（读取提交内容）</strong></p>
<p>在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read）。</p>
<p><strong>Repeatable Read（可重读）</strong></p>
<p>这是MySQL中InnoDB默认的隔离级别。我们姑且分“读”和“写”两个模块来讲解。</p>
<p><strong>读（快照读）</strong></p>
<p>读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时。我们前面已经讲过“理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）”。</p>
<p>讲到这里，我们先来好好地说明下不可重复读和幻读的区别：</p>
<blockquote>
<p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p>
<p>MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p>
</blockquote>
<p>这里继续扩展下悲观锁和乐观锁的知识。</p>
<blockquote>
<p>悲观锁：</p>
<p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
<p>乐观锁：</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p>
</blockquote>
<p>接下来讲解MVCC在MySQL的InnoDB中的实现：</p>
<blockquote>
<p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p>
<p>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</p>
<p>INSERT时，保存当前事务版本号为行的创建版本号。</p>
<p>DELETE时，保存当前事务版本号为行的删除版本号。</p>
<p>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</p>
<p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
</blockquote>
<p>注：“读”与“读”的区别。</p>
<p>事务的隔离级别其实都是对于读数据的定义，但到了这里，就被拆成了读和写两个模块来讲解。这主要是因为MySQL中的读，和事务隔离级别中的读，是不一样的。</p>
<p>我们且看，在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p>
<p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<blockquote>
<p>快照读：就是select</p>
<p>select * from table ….;</p>
<p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p>
<p>select * from table where ? lock in share mode;</p>
<p>select * from table where ? for update;</p>
<p>insert;</p>
<p>update ;</p>
<p>delete;</p>
</blockquote>
<p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p>
<p><strong>因为更新数据、插入数据是针对当前数据的，所以不能以快照的历史数据为参考，此处就是这个意思。</strong></p>
<p><strong>写（”当前读”）</strong></p>
<p>事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读，而这里说的“写”就是当前读了。</p>
<p>为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。</p>
<p>Next-Key锁是行锁和GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下GAP间隙锁。</p>
<p>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>
<p><strong>Serializable</strong></p>
<p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p>
<p>这里需要注意改变一个观念，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的</p>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP HashTable 解析</title>
    <url>/2019/02/23/PHP%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90HashTable/</url>
    <content><![CDATA[<p>说 HashTable 是PHP的灵魂，一点也不为过。在Zend引擎中，比如变量表、常量表、函数表、数组，以及资源管理、线程安全等，其实现都有HashTable的身影。HashTable 是一种查找性能极高的数据结构，理想情况下其算法复杂度是O(1)。</p>
<h3 id="PHP-HashTable-概述"><a href="#PHP-HashTable-概述" class="headerlink" title="PHP HashTable 概述"></a>PHP HashTable 概述</h3><ul>
<li>有两部分组成，Bucket 和 HashTable，而且均为结构体(struct)。</li>
<li>Bucket 是存储数据的单元，用于保存具体的数据内容；HashTable 用于保存整个哈希表需要的基本信息。</li>
<li>二者关系可以简单理解为：HashTable = Array(); HashTable[‘arBuckets’] = [Bucket1, Bucket2, Bucket3, …]。</li>
<li>HashTable 的目的就是通过索引把每个Bucket元素分散到唯一的位置。</li>
<li>PHP 内核通过HashTable 结构管理Bucket 数组。</li>
<li>相比普通HashTable，PHP的HashTable同时维护一个双向链表。在HashTable.arBuckets 存储的是包含多个Bucket指针的向量，每个指针又指向一个双向链表(多个bucket组成)。</li>
</ul>
<h2 id="HashTable-源码展示"><a href="#HashTable-源码展示" class="headerlink" title="HashTable 源码展示"></a>HashTable 源码展示</h2><p>在Zend/zend_hash.h的line 55~83 中定义了结构体 Bucket 和 HashTable。注意 Bucket 和 HashTable 是别名，分别对应结构体 bucket 和 _hashtable。</p>
<a id="more"></a>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">    ulong h;                        <span class="comment">/* Used for numeric indexing */</span></span><br><span class="line">    uint nKeyLength;</span><br><span class="line">    <span class="keyword">void</span> *pData;</span><br><span class="line">    <span class="keyword">void</span> *pDataPtr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListLast</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pLast</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *arKey;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtable</span> &#123;</span></span><br><span class="line">    uint nTableSize;</span><br><span class="line">    uint nTableMask;</span><br><span class="line">    uint nNumOfElements;</span><br><span class="line">    ulong nNextFreeElement;</span><br><span class="line">    Bucket *pInternalPointer;   <span class="comment">/* Used for element traversal */</span></span><br><span class="line">    Bucket *pListHead;</span><br><span class="line">    Bucket *pListTail;</span><br><span class="line">    Bucket **arBuckets;</span><br><span class="line">    <span class="keyword">dtor_func_t</span> pDestructor;</span><br><span class="line">    zend_bool persistent;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> nApplyCount;</span><br><span class="line">    zend_bool bApplyProtection;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    <span class="keyword">int</span> inconsistent;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>





<h2 id="Bucket-解析说明"><a href="#Bucket-解析说明" class="headerlink" title="Bucket 解析说明"></a>Bucket 解析说明</h2><p>先分析一下Bucket 结构体成员变量的作用：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ulong h;</strong></td>
<td>ulong 中u表示无符号，保存hash(key) 的值； 或者保存用户指定的整数类型索引值； key是什么？就是当前bucket的索引，存储在最后一个成员arKey中;</td>
</tr>
<tr>
<td><strong>uint nKeyLength;</strong></td>
<td>保存索引 key 的长度； 索引是字符串时，该值&gt;0，表示索引字符串的长度； 索引是整数时，该值==0；</td>
</tr>
<tr>
<td><strong>void *pData;</strong></td>
<td>指向要保存的内存块地址，一般是通过malloc之类的系统调用分配出来的 指向Value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr</td>
</tr>
<tr>
<td><strong>void *pDataPtr;</strong></td>
<td>保存指针数据，当保存的数据是指针类型，不需要malloc分配，就直接保存到pDataPtr中，pData直接指向这里 保存的数据不是指针类型时，pDataPtr=NULL</td>
</tr>
<tr>
<td><strong>struct bucket *pListNext;</strong></td>
<td>指向双向链表的下一个元素</td>
</tr>
<tr>
<td><strong>struct bucket *pListLast;</strong></td>
<td>指向双向链表的上一个元素</td>
</tr>
<tr>
<td><strong>struct bucket *pNext;</strong></td>
<td>指向具有同一个hash值的下一个元素</td>
</tr>
<tr>
<td><strong>struct bucket *pLast;</strong></td>
<td>指向具有同一个hash值的上一个元素，这里是hash碰撞后的处理方法，拉链法</td>
</tr>
<tr>
<td><strong>const char *arKey;</strong></td>
<td>注意，这里之前PHP版本是 char arKey[1];  在PHP5.6版本中，不限制索引的长度了； 结构体变量内存申请 sizeof(Bucket *), 无需 加上nKeyLength 长度了。</td>
</tr>
</tbody></table>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h3><ol>
<li>pData 和 pDataPtr 的关系，<ul>
<li>pData 指向的是保存数据的内存块地址，一般通过malloc等分配;</li>
<li>pDataPtr 如果是指针数据，此值会指向真正的value，同时pData 会指向该值</li>
<li>疑问 内存块地址，不也是指针吗？和pDataPtr什么区别？？</li>
</ul>
</li>
<li>h 成员保存的是HashTable key 哈希后的值，而非HashTable中的索引值，为什么？<ul>
<li>索引值和HashTable的容量有关系，如果HashTable扩容，那么这些索引还得重新进行哈希，再进行索引映射</li>
<li>数字索引直接就可以作为哈希表的索引，数字也无需进行哈希处理</li>
</ul>
</li>
</ol>
<h2 id="HashTable-解析说明"><a href="#HashTable-解析说明" class="headerlink" title="HashTable 解析说明"></a>HashTable 解析说明</h2><table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>uint nTableSize</strong></td>
<td>记录 Bucket 数组的大小</td>
</tr>
<tr>
<td><strong>uint nTableMask</strong></td>
<td>始终等于 nTableSize - 1 用在与哈希值做与运算，获得该哈希值的索引取值。额，哈希值是什么？？是Bucket中的索引值？</td>
</tr>
<tr>
<td><strong>uint nNumOfElements</strong></td>
<td>HashTable中，Bucket 元素的数量; count() 函数直接返回该值</td>
</tr>
<tr>
<td><strong>ulong nNextFreeElement</strong></td>
<td>表示数字键数组中，下一个数字索引的位置</td>
</tr>
<tr>
<td><strong>Bucket *pInternalPointer</strong></td>
<td>For循环时用于记录当前元素的位置 内部指针，指向当前成员，用于遍历元素</td>
</tr>
<tr>
<td><strong>Bucket *pListHead</strong></td>
<td>指向HashTable的第一个元素，也是数组的第一个元素。reset() 是返回这个值吗？与它是否有关系？</td>
</tr>
<tr>
<td><strong>Bucket *pListTail</strong></td>
<td>指向HashTable的最后一个元素，也是数组的最后一个元素。end()是返回这个值吗？与它是否有关系？</td>
</tr>
<tr>
<td><strong>Bucket \</strong>arBuckets**</td>
<td>Bucket组成的双向链表的数组，索引=hash(key) &amp; nTableMask</td>
</tr>
<tr>
<td><strong>dtor_func_t pDestructor</strong></td>
<td>删除Bucket数组元素使用的析构函数</td>
</tr>
<tr>
<td><strong>zend_bool persistent</strong></td>
<td>标记内存分配函数 true 使用系统的内存分配函数 false 使用PHP内存分配函数 一般使用PHP的内存分配函数，Zend引擎会管理相应内存，避免泄漏</td>
</tr>
<tr>
<td><strong>unsigned char nApplyCount</strong></td>
<td>保存当前Bucket被递归访问的次数，防止多次递归。@TODO 什么是多次递归？</td>
</tr>
<tr>
<td><strong>zend_bool bApplyProtection</strong></td>
<td>HashTable 是否需要递归报数，默认是1，要使用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>ORM和QueryBuilder哪个好</title>
    <url>/2019/01/08/ORM%E5%92%8CQueryBuilder%E5%93%AA%E4%B8%AA%E5%A5%BD/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>​    最近准备将跑PHP5的老项目升PHP7，用的是CI2.x的框架，烂的一笔。主要障碍是php7删除了mysqli的相关函数，于是准备自己封装一个DAO层。看了一下主流的 <a href="https://github.com/doctrine/orm/" target="_blank" rel="noopener">doctrine/orm</a> ORM封装，发现用法特别繁琐，要在代码里描述每个表的每个字段：</p>
<figure class="highlight php7"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// src/Product.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>​    感觉特别繁琐，不禁思考一个问题🤔：我们到底要不要用ORM，ORM真的比QueryBilder或原生sql的形式好吗？</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>​    从一开始写原生sql，到后来用TP、CI框架里的QueryBuilder，然后接触了Laravel和它的Eloquent后成为了ORM的狂热爱好者，再后来又开始脱离这些框架或工具自己试着造轮子写东西，经历这些后，我是这样想的：<strong>ORM和其他那些框架一样，就是为了让你从底层操作中解脱出来，去专心做业务逻辑</strong>。</p>
<p>​    一开始接触Laravel的时候，觉得它好牛逼，用到了好多我不懂的面向对象思想和设计模式。等把它吃透了后才觉得这框架也就那样，集成了很多成熟的工具，大而全，拿来学编程思想很不错；但这也是它的弊端，当我需要开发一些简单优雅的小工具时就有些大材小用了（虽然出了lumen，但感觉也是不尽人意）。</p>
<p>​    ORM也是一样的道理，有它的利（防注入、简化逻辑、不需要过多的sql知识），也有它的弊（代码量增加、不能精确控制sql的构成）。所以，ORM和QueryBuilder没有绝对的哪个好，而需要考虑具体使用场景：</p>
<ul>
<li><p>如果你更注重代码的性能而不是开发的简易性，请使用query builder</p>
</li>
<li><p>如果你喜欢OOP，与对象打交道，请使用ORM</p>
</li>
<li><p>如果你要批量处理多个实体，最好用query builder</p>
</li>
<li><p>如果你是mysql新手，或者程序不是很复杂，就直接用ORM</p>
</li>
<li><p>如果表之间的业务关系很复杂，还是用query builder吧</p>
</li>
</ul>
<p>  ​    从更高的层面思考：工具存在的意义就是为了解决实际问题，比较某某工具的好坏没有意义。多学习提升技术，当遇到实际问题时才能想出多种解决方案，并选取最合适的进行实践。这也是我喜欢做工程师的原因，做实事，解决实际问题，世界才会美好～</p>
]]></content>
      <categories>
        <category>经验反思</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于优惠券资金问题的反思</title>
    <url>/2018/12/06/%E5%85%B3%E4%BA%8E%E4%BC%98%E6%83%A0%E5%88%B8%E8%B5%84%E9%87%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<ul>
<li><p>offline脚本漏掉了回滚资金逻辑：<br>这块因为是离线脚本，只是在测试环境手动调用测的能不能跑通，线上因为不方便测就直接对接了。<br>以后这块有改动还是要多review，不能疏忽。</p>
</li>
<li><p>cms追加优惠券时忽略了事务一致性问题<br>事务一致性的问题本来一开始整理的时候列到了，把各项目到查了一遍，还是漏掉了一个，惭愧。。<br>后面需要推进事务协调器，撤掉解决这种问题出现的可能。</p>
</li>
<li><p>问题及时向上反馈<br>问题一开始出现时，只有我、春光和潘静在查这个问题，因为当时不知道问题2和少了30万预算这两件事的存在，<br>所以我和春光查了两天这个数怎么也对不上，如果早点向上反馈的话知道少了30万预算说不定这个问题早就解决了。。</p>
</li>
<li><p>找不到问题原因时的思考思路<br>昨天一天用各种方案算的数都对不上，这时候我们应该把已知并确定正确的信息列出来，和现有的数据做对比，<br>如果发现对不上，大胆的列出所有的可能性，并一一排查验证，排除掉不可能的，剩下的就是正确答案。</p>
<blockquote>
<p>比如 现有冻结金额远小于应有冻结金额，那么猜测可能的原因：<br>过期回滚时冻结资金扣多了 （验证后被排除<br>删除回滚时冻结资金扣多了（验证后被排除<br>创建时没有加冻结资金（验证后被排除<br>追加时没有加冻结资金————找到正确答案</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>经验反思</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-13</title>
    <url>/2018/11/12/arts-13/</url>
    <content><![CDATA[<h2 id="Algorithim"><a href="#Algorithim" class="headerlink" title="Algorithim"></a>Algorithim</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>Approach:1</strong></p>
<p>Imagine two runners running on a track at different speed. What happens when the track is actually a circle?</p>
<p>The space complexity can be reduced to O(1)O(1) by considering two pointers at <strong>different speed</strong> - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p>
<p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.</p>
<p>Now consider a cyclic list and imagine the slow and fast pointers are two runners racing around a circle track. The fast runner will eventually meet the slow runner. Why? Consider this case (we name it case A) - The fast runner is just one step behind the slow runner. In the next iteration, they both increment one and two steps respectively and meet each other.</p>
<p>How about other cases? For example, we have not considered cases where the fast runner is two or three steps behind the slow runner yet. This is simple, because in the next or next’s next iteration, this case will be reduced to case A mentioned above.</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">b</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">c</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    a-&gt;val = <span class="number">1</span>;</span><br><span class="line">    a-&gt;next = b;</span><br><span class="line">    b-&gt;next = c;</span><br><span class="line">    c-&gt;next = b;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle(a)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​    malloc和calloc都是在堆中申请内从（两者的区别是calloc可以指定数量，并初始化内从的值，性能会比malloc慢一点，但可忽略不计），用完要用free释放掉。</p>
<p>​    c中没有HashTable或Map之类的结构，只能用这种算法，好处是空间复杂度是O(1)，时间复杂度和前者一样是O(n)</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>反思总结：优惠券服务拆分</title>
    <url>/2018/11/06/%E4%BC%98%E6%83%A0%E5%88%B8%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="过程中出现的问题："><a href="#过程中出现的问题：" class="headerlink" title="过程中出现的问题："></a>过程中出现的问题：</h2><p><strong>思考问题</strong></p>
<p>​    安全意识还是不够，不能因为这块是朝沛拆的就不怎么看，导致要上线了才发现回滚逻辑有这么多问题，临上线又重构代码，给测试也带来很多麻烦；想的不够细，有些逻辑靠衍雷提出来才想到，这一点感觉还是得靠多实践去改变。</p>
<p><strong>买家端无法提供服务</strong></p>
<p>​    虽然不是我的主要问题，但出问题时看到nginx的error_log：recv() failed (104: Connection reset by peer) while reading response header from upstream，应该能及时联想到是fpm的问题，然后随手ps下看看进程就能及时发现子进程只有5个；使用新机器时先看下机器配置。</p>
<p><strong>一些要注意的点：</strong></p>
<p>​    做服务这块一定要多了解业务，多思考可能存在的问题，心思要缜密，考虑全面，想的越多，出问题的概率才越小。尤其是涉及到事务相关的部分要考虑到成功失败的各种情况。</p>
<p>​    涉及多项目的服务与接口代码上线，要保证各种case都测过没问题了，先把服务上了，再逐个上客户端。尽量避免后期改动服务的情况，一旦服务有改动，就得各项目都测一遍，带来不必不要的成本与风险。</p>
<p>​    上线后及时的观察有没有各种异常，做好监控。</p>
<p>​</p>
]]></content>
      <categories>
        <category>经验反思</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>《Go语言圣经》笔记整理</title>
    <url>/2018/11/01/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="Printf-转换动词"><a href="#Printf-转换动词" class="headerlink" title="Printf 转换动词"></a>Printf 转换动词</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%d			十进制整数</span><br><span class="line">%x, %o, %b	十六进制，八进制，二进制整数。</span><br><span class="line">%f, %g, %e	浮点数: 3.141593 3.141592653589793 3.141593e+00</span><br><span class="line">%t			布尔:true或false</span><br><span class="line">%c			字符(rune) (Unicode码点)</span><br><span class="line">%s			字符串</span><br><span class="line">%q			带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39;</span><br><span class="line">%v			变量的自然形式(natural format)</span><br><span class="line">%T			变量的类型</span><br><span class="line">%%			字面上的百分号标志(无操作数)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>《Go语言圣经》笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-12</title>
    <url>/2018/10/29/arts-12/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>Approach 1:Brute Force</strong></p>
<p>​    暴力破解：从头开始检查每一个可能的子数组，记录其中最长的。要想求一个字符串中最长子字符串的长度，就得先能判断一个字符串是不是不重复的唯一字符串（allUnique函数），而要判断字符串是不是唯一的，除了迭代遍历每一个元素（contains函数），我暂时没想到什么别的好办法（这里是说C语言，Java里有HashSet）。这个算法的时间复杂度是很差的，套了4层for循环，但还是有几个可以优化的点，写在下面的注释里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一个字符串是否包含某个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span> *substr, <span class="keyword">int</span> length, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (substr[i] == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一个字符串是否是唯一的（不重复的）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allUnique</span><span class="params">(<span class="keyword">char</span> *substr, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// i从1开始，也就是第二个元素，依次判断第i个字符是否包含在i前面的子字符中</span></span><br><span class="line">        <span class="keyword">if</span> (contains(substr, i, substr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> strLength = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (strLength == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strLength == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// maxLength是当前已求出来的最长子字符串长度，初始值给1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当已知的最大子字符长度大于等于剩下的字符长度时，就没必要循环了，</span></span><br><span class="line">    <span class="comment">// 因为剩下的部分即使都是唯一的也不可能超过当前的最大子字符长度</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; strLength - maxLength; i++) &#123;</span><br><span class="line">        <span class="comment">// j表示要迭代检查的子字符串长度，初始值直接用maxLength，</span></span><br><span class="line">        <span class="comment">// 因为小于maxLength的长度没必要检测</span></span><br><span class="line">        <span class="keyword">int</span> j = maxLength;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; strLength - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allUnique(s + i, j + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) &gt; maxLength) &#123;</span><br><span class="line">                maxLength = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的问题反思</title>
    <url>/2018/10/18/%E6%9C%80%E8%BF%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>关于最近的问题：</p>
<p>1、要解决问题，首先得学会分析一个问题具体出在哪个环节，越细越好</p>
<p>2、每个人都有犯错的机会，但是犯同类的错误会降低别人对你的信任，一定要会反思</p>
<p>3、你对每一个问题的责任心和态度都会有人记在心上，尽量给每个关注问题的人及时的反馈</p>
]]></content>
      <categories>
        <category>经验反思</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-11</title>
    <url>/2018/10/16/arts-11/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Approach:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, x, y, sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">curr</span> = <span class="title">dummyHead</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">        x = p ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        y = q ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        next-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        curr-&gt;next = next;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span>;</span><br><span class="line">        next-&gt;val = carry;</span><br><span class="line">        curr-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>工作心得总结</title>
    <url>/2018/10/13/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="时间评估"><a href="#时间评估" class="headerlink" title="时间评估"></a>时间评估</h3><p>​    当leader给你一个任务问你多久能完成时，不要简单的看一看就给一个估摸的大概的时间，要培养对工作量评估的能力，这很重要。评估时要做到尽量准确，具体注意以下几点：</p>
<ol>
<li>不要想着三个小时的工作,我加加班赶一赶两个小时搞定——在仓促状态下赶工，质量必然会收到影响，你做的每一件事的质量代表着你的个人水平，它直接影响着你在别人心中的看法，而且一旦再出什么额外状况，这个任务就会delay。</li>
<li>两个小时的工作量，不要想着我给自己估宽松点，估三个小时——该是多少就是多少，这直接影响别人对你的信任，如果同一份工作你给估了一个月，老板去问另一个开发，他只估了半个月，那老板以后可能就不会再找你分配工作。一天八小时工作制，由于各种各样的原因实际可支配的时间其实并没有这么多，那你可以提前说明比如我每天要给别人解决各种各样的问题或者晚上想留出两小时的时间学习，所以每天实际的开发时间只有5h，那一份40h工作量的任务对我来说就需要8day，但一定不要把这些额外事情的时间算到这个任务里。</li>
<li>评估任务尽量拆解的细一些，想的全面一些。一个需求中复杂的坑和细节尽量一开始就考虑到搞清楚，并留出相应的时间，以避免做到一半发现有坑再delay，承诺过的事情要有契约精神。我知道这很难，但尽量做，其实每个任务实际完成的时间比预期差个一天半天都是正常的，关键是要总结经验，想想这次评估中有哪些不足，让下次的评估可以更准确。如果每次评估都是糊弄了事，你会逐渐丧失时间评估的能力。</li>
</ol>
<a id="more"></a>

<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>​       时间是你最宝贵的财富，所以一定要利用好。要学会主动管理，对于学习上，每天一定要抽出整块的不被打扰的时间用来学习，提升个人技术能力和自身价值，是走技术这条路最最重要的一步，活到老学到老。对于工作上，学会使用任务管理工具（如tower），一些小的零碎的事情，短时间能解决的优先解决，别给自己攒太多压力，然后集中精力去做那些大块的工作。如果一个任务的工作是一周或两周，那就提前拆解好每天要做到什么程度，每晚review一下工作情况，对总体的进度有个把控，如果感觉搞不完要delay就加加班或者提前向上反馈，因为什么什么原因，这个任务要delay多久，并给出解决方案，要么加班，要么整体延期。一定不要等到deadline了才发现做不完，影响整个团队的进度。</p>
<h3 id="同事之间的交往"><a href="#同事之间的交往" class="headerlink" title="同事之间的交往"></a>同事之间的交往</h3><p>​    大家一起共事都是缘分，一个团队中每个人的技术肯定是有高有低参差不齐的，性格也是多种多样。相处时要做到谦虚和尊敬他人，学会倾听和站在他人的角度思考问题，每个人身上肯定都有比自己强值得学习的地方，要学会发现这些闪光点。当别人来找自己问问题的时候，要注意自己的态度，对事不对人，如果一个人对同一个问题或类似的问题找你问很多遍，你可以说这个问题我给你讲过很多次了，你先自己想一下有没有思路，该怎么解决，想好方案再来找我；但如果他带来的是个新问题还是要耐心解答的，不能因为他老问问题就不理他。</p>
<h3 id="责任与心态"><a href="#责任与心态" class="headerlink" title="责任与心态"></a>责任与心态</h3><p>​    出现问题时leader询问情况，要先快速定位问题，并给出解决方案，分析利弊；如出的问题跟自己没关系，也可以待命看看有什么能帮的上忙的，帮忙思考下解决方案；问题解决后，思考问题是怎么造成的，以后怎么避免，总结经验；如果是自身的原因主动承担错误，如果是别人的原因，自己也要引以为戒。一定不要出了问题先说这代码是谁谁谁写的，把自己撇的一干二净，这给人感觉很不好，直接决定了你做事的高度。出问题是在所难免的，这并不可怕，很多时候leader也只是问问想搞清楚情况，并没有要责怪谁的意思，关键是不要让范过的错误重复的发生在自己身上。</p>
]]></content>
      <categories>
        <category>经验反思</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-10</title>
    <url>/2018/10/07/arts-10/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<p><strong>Summary:</strong></p>
<p>想问题没有思路时可以试着把负责的问题简单化，比如这道题求<code>maxSubArray(int A[], int i, int j)</code>，我们可以简化成求<code>maxSubArray(int A[], int i)</code>，也就是<code>A[0:i ]</code>——以A[0]开头A[i]结尾的最大子集，然后再观察总结，我们得出：</p>
<blockquote>
<p>maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i];</p>
</blockquote>
<a id="more"></a>

<p><strong>Approach:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[numsSize];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = temp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        temp[i] = nums[i] + (temp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? temp[i<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &lt; temp[i] ? temp[i] : <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-9</title>
    <url>/2018/10/06/arts-9/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>

<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em> th term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<a id="more"></a>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Approach</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">change</span><span class="params">(<span class="keyword">char</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret_temp = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> flag = ret[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(ret); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == ret[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j += <span class="built_in">sprintf</span>(ret_temp + j, <span class="string">"%d%c"</span>, count, flag);</span><br><span class="line">            flag = ret[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(ret_temp + j, <span class="string">"%d%c"</span>, count, flag);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> ret_temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">5000</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret = change(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mac升级Mojave后的一些坑</title>
    <url>/2018/10/04/%E5%85%B3%E4%BA%8EMac%E5%8D%87%E7%BA%A7Mojave%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<ol>
<li><p>Git无法使用，原因是每次大版本升级后，CommandLineTools回被卸载，而Git这种命令行工具依赖于CommandLineTools，解决方案是重新安装CommandLineTools。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc编译文件时找不到头文件，报类似于 stdio.h file not found 的错误，具体情况可以看<a href="https://stackoverflow.com/questions/52509602/cant-compile-c-program-on-a-mac-after-upgrade-to-mojave" target="_blank" rel="noopener">StackOverflow</a>上这个提问。解决方案是使用brew安装或升级gcc最新版本，并在你的IDE中配置它，这里给出CLion的<a href="https://www.jetbrains.com/help/clion/how-to-switch-compilers-in-clion.html" target="_blank" rel="noopener">配置教程</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line">brew upgrade gcc</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>如果你遇到了一些其他问题，欢迎给我留言讨论。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-8</title>
    <url>/2018/10/03/arts-8/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Approach 1: two pointer</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize ==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">            nums[++i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用双指针遍历这个数组，一个指针用来迭代，另一个记录不重复的值的索引。时间复杂度O(n)，空间复杂度O(1)。</p>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>approach 1:two pointer</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Approach-2-Two-Pointers-when-elements-to-remove-are-rare"><a href="#Approach-2-Two-Pointers-when-elements-to-remove-are-rare" class="headerlink" title="Approach 2: Two Pointers - when elements to remove are rare"></a><strong>Approach 2: Two Pointers - when elements to remove are rare</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Intuition</strong></p>
<p>Now consider cases where the array contains few elements to remove. For example, nums = [1,2,3,5,4], val = 4nums=[1,2,3,5,4],val=4. The previous algorithm will do unnecessary copy operation of the first four elements. Another example is nums = [4,1,2,3,5], val = 4nums=[4,1,2,3,5],val=4. It seems unnecessary to move elements [1,2,3,5][1,2,3,5] one step left as the problem description mentions that the order of elements could be changed.</p>
<p><strong>Algorithm</strong></p>
<p>When we encounter nums[i] = valnums[i]=val, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array’s size by 1.</p>
<p>Note that the last element that was swapped in could be the value you want to remove itself. But don’t worry, in the next iteration we will still check this element.</p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n)O(n). Both ii and nn traverse at most nn steps. In this approach, the number of assignment operation is equal to the number of elements to remove. So it is more efficient if elements to remove are rare.</li>
<li>Space complexity : O(1)O(1).</li>
</ul>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>异步网络模型</title>
    <url>/2018/09/24/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="异步网络模型"><a href="#异步网络模型" class="headerlink" title="异步网络模型"></a>异步网络模型</h1><p>异步网络模型在服务开发中应用非常广泛，相关资料和开源库也非常多。项目中，使用现成的轮子提高了开发效率，除了能使用轮子，还是有必要了解一下轮子的内部构造。</p>
<p>这篇文章从最基础的5种I/O模型切入，到I/O事件处理模型，再到并发模式，最后以Swoole开源库来做具体分析，逐步深入。文中提到的模型都是一些通用的模型，在《linux高性能服务器编程》中也都有涉及。文章不涉及模型的实现细节，最重要的是去理解各个模型的工作模式以及其优缺点。</p>
<p>读后感：</p>
<p>所谓异步：</p>
<p>1.(fd)阻塞调用 + select/pool, epool  （IO事件通知方式：IO复用）</p>
<p>2.(fd)非阻塞调用 + SIGIO （IO事件通知方式：SIGIO 信号）</p>
<a id="more"></a>


<p>文中涉及接口调用的部分，都是指Linux系统的接口调用。共分为5部分：</p>
<p>I/O模型</p>
<p>从基础的系统调用方法出发，给大家从头回顾一下最基本的I/O模型，虽然简单，但是不可或缺的基础；</p>
<p>事件处理模型</p>
<p>这部分在同步I/O、异步I/O的基础上分别介绍Reactor模型以及Proactor模型，着重两种模型的构成以及事件处理流程。Reactor模型是我们常见的；不同平台对异步I/O系统接口的支持力度不同，这部分还介绍了一种使用同步I/O来模拟Proactor模型的方法。</p>
<p>并发模式</p>
<p>就是多线程、多进程的编程的模式。介绍了两种较为高效的并发模型，半同步／半异步(包括其演变模式)、Follower／Leader模式。</p>
<p>Swoole异步网络模型分析</p>
<p>这部分是结合已介绍的事件处理模型、并发模式对Swoole的异步模型进行分析；从分析的过程来看，看似复杂的网络模型，可以拆分为简单的模型单元，只不过我们需要权衡利弊，选取合适业务需求的模型单元进行组合。我们团队基于Swoole 1.8.5版本，做了很多修改，部分模块做了重构，计划在17年6月底将修改后版本开源出去，敬请期待。</p>
<p>改善性能的方法</p>
<p>最后一部分是在引入话题，介绍的是几种常用的方法。性能优化是没有终点的，希望大家能贡献一些想法和具体方法。</p>
<p>I/O模型</p>
<p>POSIX 规范中定义了同步I/O 和异步I/O的术语，</p>
<p>同步I/O : 需要进程去真正的去操作I/O；</p>
<p>异步I/O：内核在I/O操作完成后再通知应用进程操作结果。</p>
<p>在《UNIX网络编程》中介绍了5中I/O模型：阻塞I/O、非阻塞I/O、I/O复用、SIGIO 、异步I/O；本节对这5种I/O模型进行说明和对比。</p>
<p>I/O阻塞</p>
<p>通常把阻塞的文件描述符（file descriptor，fd）称之为阻塞I/O。默认条件下，创建的socket fd是阻塞的，针对阻塞I/O调用系统接口，可能因为等待的事件没有到达而被系统挂起，直到等待的事件触发调用接口才返回，例如，tcp socket的connect调用会阻塞至第三次握手成功（不考虑socket 出错或系统中断），如图1所示。另外socket 的系统API ，如，accept、send、recv等都可能被阻塞。</p>
<p><img src="https:////note.youdao.com/src/B7FFBB5BC3684E41BFFE7BB61A1BF09E" alt="img"></p>
<p>​                      图1I/O 阻塞模型示意图</p>
<p>1</p>
<p>另外补充一点，网络编程中，通常把可能永远阻塞的系统API调用 称为慢系统调用，典型的如 accept、recv、select等。慢系统调用在阻塞期间可能被信号中断而返回错误，相应的errno 被设置为EINTR，我们需要处理这种错误，解决办法有：</p>
<p>\1. 重启系统调用</p>
<p>直接上示例代码吧，以accept为例，被中断后重启accept 。有个例外，若connect 系统调用在阻塞时被中断，是不能直接重启的（与内核socket 的状态有关)，有兴趣的同学可以深入研究一下connect 的内核实现。使用I/O复用等待连接完成，能避免connect不能重启的问题。</p>
<p>int client_fd = -1;  structsockaddr_inclient_addr;socklen_t child_addrlen;  while (1) {  call_accept:      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {       if (EINTR == errno) {          goto call_accept;       } else {          sw_sysError(“accept fail”);          break;       }    }}</p>
<p>123456789101112131415</p>
<p>\2. 信号处理</p>
<p>利用信号处理，可以选择忽略信号，或者在安装信号时设置SA_RESTART属性。设置属性SA_RESTART，信号处理函数返回后，被安装信号中断的系统调用将自动恢复，示例代码如下。需要知道的是，设置SA_RESTART属性方法并不完全适用，对某些系统调用可能无效，这里只是提供一种解决问题的思路，示例代码如下：</p>
<p>int client_fd = -1;  structsigactionaction,old_action;action.sa_handler = sig_handler;  sigemptyset(&amp;action.sa_mask);  action.sa_flags = 0;  action.sa_flags |= SA_RESTART;/// 若信号已经被忽略，则不设置sigaction(SIGALRM, NULL, &amp;old_action)；  if (old_action.sa_handler != SIG_IGN) {      sigaction(SIGALRM, &amp;action, NULL)；}while (1) {      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {        sw_sysError(“accept fail”);        break;    }}</p>
<p>123456789101112131415161718192021</p>
<p>I/O非阻塞</p>
<p>把非阻塞的文件描述符称为非阻塞I/O。可以通过设置SOCK_NONBLOCK标记创建非阻塞的socket fd，或者使用fcntl将fd设置为非阻塞。</p>
<p>对非阻塞fd调用系统接口时，不需要等待事件发生而立即返回，事件没有发生，接口返回-1，此时需要通过errno的值来区分是否出错，有过网络编程的经验的应该都了解这点。不同的接口，立即返回时的errno值不尽相同，如，recv、send、accept errno通常被设置为EAGIN 或者EWOULDBLOCK，connect 则为EINPRO-GRESS 。</p>
<p>以recv操作非阻塞套接字为例，如图2所示。</p>
<p><img src="https:////note.youdao.com/src/0DF7FBEB18524D968DA0D4DC4F7ED257" alt="img"></p>
<p>​                     图2 非阻塞I/O模型示意图</p>
<p>1</p>
<p>当我们需要读取，在有数据可读的事件触发时，再调用recv，避免应用层不断去轮询检查是否可读，提高程序的处理效率。通常非阻塞I/O与I/O事件处理机制结合使用。</p>
<p>I/O复用</p>
<p>最常用的I/O事件通知机制就是I/O复用(I/O multiplexing)。Linux 环境中使用select/poll/epoll 实现I/O复用，I/O复用接口本身是阻塞的，在应用程序中通过I/O复用接口向内核注册fd所关注的事件，当关注事件触发时，通过I/O复用接口的返回值通知到应用程序，如图3所示,以recv为例。I/O复用接口可以同时监听多个I/O事件以提高事件处理效率。</p>
<p><img src="https:////note.youdao.com/src/2FE99F76417C4837A098D4D8DA4EDFCF" alt="img"></p>
<p>​                    图 3I/O复用模型示意图</p>
<p>1</p>
<p>关于select/poll/epoll的对比，可以参考[]，epoll使用比较多，但是在并发的模式下，需要关注惊群的影响。</p>
<p>SIGIO</p>
<p>除了I/O复用方式通知I/O事件，还可以通过SIGIO信号来通知I/O事件，如图4所示。两者不同的是，在等待数据达到期间，I/O复用是会阻塞应用程序，而SIGIO方式是不会阻塞应用程序的。</p>
<p><img src="https:////note.youdao.com/src/4EC5DCA3909E4C52910ABD33BC7FD478" alt="img"></p>
<p>​                     图 4 信号驱动I/O模型示意图</p>
<p>1</p>
<p>异步I/O</p>
<p>POSIX规范定义了一组异步操作I/O的接口，不用关心fd 是阻塞还是非阻塞，异步I/O是由内核接管应用层对fd的I/O操作。异步I/O向应用层通知I/O操作完成的事件，这与前面介绍的I/O 复用模型、SIGIO模型通知事件就绪的方式明显不同。以aio_read 实现异步读取IO数据为例，如图5所示，在等待I/O操作完成期间，不会阻塞应用程序。</p>
<p><img src="https:////note.youdao.com/src/DDC1E38AE6ED40E6B1302E75DFD4F7F8" alt="img"></p>
<p>​                      图 5 异步I/O 模型示意图</p>
<p>1</p>
<p>I/O模型对比</p>
<p>前面介绍的5中I/O中，I/O 阻塞、I/O非阻塞、I/O复用、SIGIO 都会在不同程度上阻塞应用程序，而只有异步I/O模型在整个操作期间都不会阻塞应用程序。</p>
<p>如图6所示，列出了5种I/O模型的比较</p>
<p><img src="https:////note.youdao.com/src/3F0992AC6EC74A9880DC225FF3F8EE05" alt="img"></p>
<p>​                   图6 五种I/O 模型比较示意图</p>
<p>1</p>
<p>事件处理模型</p>
<p>网络设计模式中，如何处理各种I/O事件是其非常重要的一部分，Reactor 和Proactor两种事件处理模型应运而生。上章节提到将I/O分为同步I/O 和 异步I/O，可以使用同步I/O实现Reactor模型，使用异步I/O实现Proactor模型。</p>
<p>本章节将介绍Reactor和Proactor两种模型，最后将介绍一种使用同步I/O模拟Proactor事件处理模型。</p>
<p>Reactor事件处理模型</p>
<p>Reactor模型是同步I/O事件处理的一种常见模型，关于Reactor模型结构的资料非常多，一个典型的Reactor模型类图结构如图7所示，</p>
<p><img src="https:////note.youdao.com/src/CBD29D74325044DAB307FFCFE83D46E2" alt="img"></p>
<p>​                   图 7 Reactor 模型类结构图</p>
<p>1</p>
<p>Reactor的核心思想：将关注的I/O事件注册到多路复用器上，一旦有I/O事件触发，将事件分发到事件处理器中，执行就绪I/O事件对应的处理函数中。模型中有三个重要的组件：</p>
<ul>
<li>多路复用器：由操作系统提供接口，Linux提供的I/O复用接口有select、poll、epoll；</li>
<li>事件分离器：将多路复用器返回的就绪事件分发到事件处理器中；</li>
<li>事件处理器：处理就绪事件处理函数。</li>
</ul>
<p>图7所示，Reactor 类结构中包含有如下角色。</p>
<ul>
<li>Handle：标示文件描述符；</li>
<li>Event Demultiplexer：执行多路事件分解操作，对操作系统内核实现I/O复用接口的封装；用于阻塞等待发生在句柄集合上的一个或多个事件（如select/poll/epoll）；</li>
<li>Event Handler：事件处理接口；</li>
<li>Event Handler A(B)：实现应用程序所提供的特定事件处理逻辑；</li>
<li>Reactor：反应器，定义一个接口，实现以下功能：</li>
</ul>
<p>​      a)供应用程序注册和删除关注的事件句柄；      b)运行事件处理循环；      c)等待的就绪事件触发，分发事件到之前注册的回调函数上处理.</p>
<p>123</p>
<p>接下来介绍Reactor的工作流程，如图8所示，为Reactor模型工作的简化流程。</p>
<p><img src="https:////note.youdao.com/src/FA1A0970047647E9BE2DC7AB66721B97" alt="img"></p>
<p>​                  图8 Reactor模型简化流程示意图</p>
<p>1</p>
<ol>
<li>注册I/O就绪事件处理器；</li>
<li>事件分离器等待I/O就绪事件；</li>
<li>I/O事件触发，激活事件分离器，分离器调度对应的事件处理器；</li>
<li>事件处理器完成I/O操作，处理数据.</li>
</ol>
<p>网络设计中，Reactor使用非常广，在开源社区有很许多非常成熟的、跨平台的、Reactor模型的网络库，比较典型如libevent。</p>
<p>Proactor事件处理模型</p>
<p>与Reactor不同的是，Proactor使用异步I/O系统接口将I/O操作托管给操作系统，Proactor模型中分发处理异步I/O完成事件，并调用相应的事件处理接口来处理业务逻辑。Proactor类结构如图9所示。</p>
<p><img src="https:////note.youdao.com/src/541F3DEA29674188AD21BB9C12AB2508" alt="img"></p>
<p>​                    图9 Proactor模型类结构图</p>
<p>1</p>
<p>图9所示，Proactor类结构中包含有如下角色：</p>
<ul>
<li>Handle： 用来标识socket连接或是打开文件；</li>
<li>Async Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li>
<li>Async Operation：异步操作；</li>
<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用；</li>
<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li>
<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li>
<li>Completion Handler A(B)：完成事件处理逻辑；实现接口定义特定的应用处理逻辑。</li>
</ul>
<p>Proactor模型的简化的工作流程,如图10所示。</p>
<p><img src="https:////note.youdao.com/src/72BA30C44C334ED28602FDA853052912" alt="img"></p>
<p>​                 图10 Proactor模型简化工作流程示意图</p>
<p>1</p>
<ol>
<li>发起I/O异步操作，注册I/O完成事件处理器;</li>
<li>事件分离器等待I/O操作完成事件；</li>
<li>内核并行执行实际的I/O操作，并将结果数据存入用户自定义缓 冲区；</li>
<li>内核完成I/O操作，通知事件分离器，事件分离器调度对应的事件处理器；</li>
<li>事件处理器处理用户自定义缓冲区中的数据。</li>
</ol>
<p>Proactor利用异步I/O并行能力，可给应用程序带来更高的效率，但是同时也增加了编程的复杂度。windows对异步I/O提供了非常好的支持，常用Proactor的模型实现服务器；而Linux对异步I/O操作(aio接口)的支持并不是特别理想，而且不能直接处理accept，因此Linux平台上还是以Reactor模型为主。</p>
<p>Boost asio采用的是Proactor模型，但是Linux上，采用I/O复用的方式来模拟Proactor，另启用线程来完成读写操作和调度。</p>
<p>同步I/O模拟Proactor</p>
<p>下面一种使用同步I/O模拟Proactor的方案，原理是：</p>
<p>主线程执行数据读写操作，读写操作完成后，主线程向工作线程通知I/O操作“完成事件”；</p>
<p>工作流程如图 11所示。</p>
<p><img src="https:////note.youdao.com/src/4A797D1DFA4345A6B8CA651380814811" alt="img"></p>
<p>​                  图11 同步I/O模拟Proactor模型</p>
<p>1</p>
<p>简单的描述一下图11 的执行流程：</p>
<ol>
<li>主线程往系统I/O复用中注册文件描述符fd上的读就绪事件；</li>
<li>主线程调用调用系统I/O复用接口等待文件描述符fd上有数据可读；</li>
<li>当fd上有数据可读时，通知主线程。主线程循环读取fd上的数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后向I/O复用中注册fd上的写就绪事件。主线程进入事件等待循环，等待fd可写。</li>
</ol>
<p>并发模式</p>
<p>在I/O密集型的程序，采用并发方式可以提高CPU的使用率，可采用多进程和多线程两种方式实现并发。当前有高效的两种并发模式，半同步/半异步模式、Follower/Leader模式。</p>
<p>半同步/半异步模式</p>
<p>首先区分一个概念，并发模式中的“同步”、“异步”与 I/O模型中的“同步”、“异步”是两个不同的概念：</p>
<p>并发模式中，“同步”指程序按照代码顺序执行，“异步”指程序依赖事件驱动，如图12 所示并发模式的“同步”执行和“异步”执行的读操作；</p>
<p>I/O模型中，“同步”、“异步”用来区分I/O操作的方式，是主动通过I/O操作拿到结果，还是由内核异步的返回操作结果。</p>
<p><img src="https:////note.youdao.com/src/C0FEC4831C074C0CB23329F010B270AD" alt="img"></p>
<p>​                     图12(a)  同步读操作示意图</p>
<p>1</p>
<p><img src="https:////note.youdao.com/src/4CAE98C8589D434B95B3DFA4B94D1028" alt="img"></p>
<p>​                     图12(b) 异步读操作示意图</p>
<p>1</p>
<p>本节从最简单的半同步/半异步模式的工作流程出发，并结合事件处理模型介绍两种演变的模式。</p>
<p>半同步/半异步工作流程</p>
<p>半同步/半异步模式的工作流程如图13 所示。</p>
<p><img src="https:////note.youdao.com/src/C8F33A95D4AA432A94A9D57854FE5977" alt="img"></p>
<p>​              图13 半同步/半异步模式的工作流程示意图</p>
<p>1</p>
<p>其中异步线程处理I/O事件，同步线程处理请求对象，简单的来说：</p>
<ol>
<li>异步线程监听到事件后，将其封装为请求对象插入到请求队列中；</li>
<li>请求队列有新的请求对象，通知同步线程获取请求对象；</li>
<li>同步线程处理请求对象，实现业务逻辑。</li>
</ol>
<p>半同步/半反应堆模式</p>
<p>考虑将两种事件处理模型，即Reactor和Proactor，与几种I/O模型结合在一起，那么半同步/半异步模式就演变为半同步／半反应堆模式。先看看使用Reactor的方式，如图14 所示。</p>
<p><img src="https:////note.youdao.com/src/249D671B15CD43F8AC5733EB176EF31A" alt="img"></p>
<p>​                    图14 半同步／半反应堆模式示意图</p>
<p>1</p>
<p>其工作流程为：</p>
<ol>
<li>异步线程监听所有fd上的I/O事件，若监听socket接可读，接受新的连接；并监听该连接上的读写事件；</li>
<li>若连接socket上有读写事件发生，异步线程将该连接socket插入请求队列中；</li>
<li>同步线程被唤醒，并接管连接socket，从socket上读取请求和发送应答；</li>
</ol>
<p>若将Reactor替换为Proactor，那么其工作流程为：</p>
<ol>
<li>异步线程完成I/O操作，并I/O操作的结果封装为任务对象，插入请求队列中；</li>
<li>请求队列通知同步线程处理任务；</li>
<li>同步线程执行任务处理逻辑。</li>
</ol>
<p>一种高效的演变模式</p>
<p>半同步／半反应堆模式有明显的缺点：</p>
<ol>
<li>异步线程和同步线程共享队列，需要保护，存在资源竞争；</li>
<li>工作线程同一时间只能处理一个任务，任务处理量很大或者任务处理存在一定的阻塞时，任务队列将会堆积，任务的时效性也等不到保证；不能简单地考虑增加工作线程来处理该问题，线程数达到一定的程度，工作线程的切换也将白白消耗大量的CPU资源。</li>
</ol>
<p>下面介绍一种改进的方式，如图15 所示，每个工作线程都有自己的事件循环，能同时独立处理多个用户连接。</p>
<p><img src="https:////note.youdao.com/src/B73C3DDD172F400C9A270FAD1E69048F" alt="img"></p>
<p>​                图 15 半同步／半反应堆模式的演变模式</p>
<p>1</p>
<p>其工作流程为：</p>
<ol>
<li>主线程实现连接监听，只处理网络I/O连接事件；</li>
<li>新的连接socket分发至工作线程中，这个socket上的I/O事件都由该工作线程处理，工作线程都可以处理多个socket 的I/O事件；</li>
<li>工作线程独立维护自己的事件循环，监听不同连接socket的I/O事件。</li>
</ol>
<p>Follower/Leader 模式</p>
<p>Follower/Leader是多个工作线程轮流进行事件监听、事件分发、处理事件的模式。</p>
<p>在Follower/Leader模式工作的任何一个时间点，只有一个工作线程处理成为Leader ，负责I/O事件监听，而其他线程都是Follower，并等待成为Leader。</p>
<p>Follower/Leader模式的工作流概述如下：</p>
<ol>
<li>当前Leader Thread1监听到就绪事件后，从Follower 线程集中推选出 Thread 2成为新的Leader；</li>
<li>新的Leader Thread2 继续事件I/O监听；</li>
<li>Thread1继续处理I/O就绪事件，执行完后加入到Follower 线程集中，等待成为Leader。</li>
</ol>
<p>从上描述，Leader/Follower模式的工作线程存在三种状态，工作线程同一时间只能处于一种状态，这三种状态为：</p>
<ul>
<li>Leader：线程处于领导者状态，负责监听I/O事件；</li>
<li>Processing：线程处理就绪I/O事件；</li>
<li>Follower：等待成为新的领导者或者可能被当前Leader指定处理就绪事件。</li>
</ul>
<p>Leader监听到I/O就绪事件后，有两种处理方式:</p>
<ol>
<li>推选出新的Leader后，并转移到Processing处理该I/O就绪事件；</li>
<li>指定其他Follower 线程处理该I/O就绪事件，此时保持Leader状态不变；</li>
</ol>
<p>如图16所示为上面描述的三种状态的转移关系。</p>
<p><img src="https:////note.youdao.com/src/0300C58B6573442BA8167AC358109B97" alt="img"></p>
<p>​              图16 Follower/Leader模式状态转移示意图</p>
<p>1</p>
<p>如图16所示，处于Processing状态的线程处理完I/O事件后，若当前不存在Leader，就自动提升为Leader，否则转变Follower。</p>
<p>从以上描述中可知，Follower/Leader模式中不需要在线程间传递数据，线程间也不存在共享资源。但很明显Follower/Leader 仅支持一个事件处理源集，无法做到图15所示的每个工作线程独立监听I/O事件。</p>
<p>Swoole 网络模型分析</p>
<p>Swoole为PHP提供I/O扩展功能，支持异步I/O、同步I/O、并发通信，并且为PHP多进程模式提供了并发数据结构和IPC通信机制；Swoole 既可以充当网络I/O服务器，也支持I/O客户端，较大程度为用户简化了网络I/O、多进程／多线程并发编程的工作。</p>
<p>Swoole作为server时，支持3种运行模式，分别是多进程模式、多线程模式、多进程＋多线程模式；多进程＋多线程模式是其中最为复杂的方式，其他两种方式可以认为是其特例。</p>
<p>本节结合之前介绍几种事件处理模型、并发模式来分析Swoole server的多进程＋多线程模型，如图17。</p>
<p><img src="https:////note.youdao.com/src/89BFEDF8F539474881899FE905512DE7" alt="img"></p>
<p>​             图17 swoole server多进程＋多线程模型结构示意图</p>
<p>1</p>
<p>图17所示，整体上可以分为Master Process、Manger Process、Work Process Pool三部分。这三部分的主要功能：</p>
<ol>
<li>Master Process：监听服务端口，接收用户连接，收发连接数据，依靠reactor模型驱动；</li>
<li>Manager Process：Master Process的子进程，负责fork WorkProcess，并监控Work Process的运行状态；</li>
<li>Work Process Pool：工作进程池，与PHP业务层交互，将客户端数据或者事件（如连接关闭）回调给业务层，并将业务层的响应数据或者操作（如主动关闭连接）交给Master Process处理；工作进程依靠reactor模型驱动。</li>
</ol>
<p>Manager Process 监控Work Process进程，本节不做进一步讲解，主要关注Master和Work。</p>
<p>Master Process</p>
<p>Master Process 内部包括主线程(Main Thread)和工作线程池(Work Thread Pool),这两部分主要功能分别是：</p>
<p>主线程: 监听服务端口，接收网络连接，将成功建立的连接分发到线程池中；依赖reactor模型驱动；</p>
<p>工作线程池: 独立管理连接，收发网络数据；依赖Reactor事件处理驱动。</p>
<p>顾一下前面介绍的半同步/半异步并发模式，很明显，主进程的工作方式就是图15所示的方式。</p>
<p>Work Process</p>
<p>如上所描述，Work Process是Master Process和PHP层之间的媒介：</p>
<ol>
<li>Work Process接收来自Master Process的数据，包括网络数据和连接事件，回调至PHP业务层；</li>
<li>将来自PHP层的数据和连接控制信息发送给Master Process进程，Master Process来处理。</li>
</ol>
<p>Work Process同样是依赖Reactor事件模型驱动，其工作方式一个典型的Reactor模式。</p>
<p>Work Process作为Master Process和PHP层之间的媒介，将数据收发操作和数据处理分离开来，即使PHP层因消息处理将Work进程阻塞一段时间，也不会对其他连接有影响。</p>
<p>从整体层面来看，Master Process实现对连接socket上数据的I/O操作，这个过程对于Work Process是异步的，结合图11 所描述的同步I/O模拟Proactor模式，两种方式如出一辙，只不过这里使用的是多进程。</p>
<p>进程间通信</p>
<p>Work Process是Master Process和PHP层之间的媒介，那么需要看看Work Process 与Master Process之间的通信方式，并在Swoole server 的多进程＋多线程模型进程中，整个过程还是有些复杂，下面说明一下该流程，如图18所示。</p>
<p><img src="https:////note.youdao.com/src/76B546B115CB4361B342121A82049291" alt="img"></p>
<p>​                图18 swoole server 多进程多线程通信示意图</p>
<p>1</p>
<p>具体流程为：</p>
<ol>
<li>Master 进程主线程接收客户端连接，连接建立成功后，分发至工作线程，工作线程通过Unix Socket通知Work进程连接信息；</li>
<li>Work 进程将连接信息回调至PHP业务层；</li>
<li>Maser 进程中的工作线程接收客户端请求消息，并通过Unix Socket方式发送到Work进程；</li>
<li>Work 进程将请求消息回调至PHP业务层；</li>
<li>PHP业务层构造回复消息，通过Work进程发送，Work进程将回复消息拷贝至共享内存中，并通过Unix Socket通知发送至Master进程的工作线程有数据需要发送；</li>
<li>工作线程从共享内存中取出需发送的数据，并发送至客户端；</li>
<li>客户端断开连接，工作线程将连接断开的事件通过UnixSocket发送至Work进程；</li>
<li>Work进程将连接断开事件回调至PHP业务层.</li>
</ol>
<p>需要注意在步骤5中，Work进程通知Master进程有数据需要发送，不是将数据直接发送给Master进程，而是将数据地址(在共享内存中)发送给Master进程。</p>
<p>改善性能的方法</p>
<p>性能对于服务器而言是非常敏感和重要的，当前，硬件的发展虽然不是服务器性能的瓶颈，作为软件开发人员还是应该考虑在软件层面来上改善服务性能。好的网络模块，除了稳定性，还有非常多的细节、技巧处理来提升服务性能，感兴趣的同学可以深入了解Ngnix源码的细节，以及陈硕的《Linux多线程服务器编程》。</p>
<p>数据复制</p>
<p>如果应用程序不关心数据的内容，就没有必要将数据拷贝到应用缓冲区，可以借助内核接口直接将数据拷贝到内核缓冲区处理，如在提供文件下载服务时，不需要将文件内容先读到应用缓冲区，在调用send接口发送出去，可以直接使用sendfile （零拷贝）接口直接发送出去。</p>
<p>应用程序的工作模块之间也应该避免数据拷贝，如：</p>
<ol>
<li>当两个工作进程之间需要传递数据，可以考虑使用共享内存的方式实现数据共享；</li>
<li>在流媒体的应用中，对帧数据的非必要拷贝会对程序性能的影响，特备是在嵌入式环境中影响非常明显。通常采用的办法是，给每帧数据分配内存（下面统称为buffer），当需要使用该buffer时，会增加该buffer的引用计数，buffer的引用计数为0时才会释放对应的内存。这种方式适合在进程内数据无拷贝传递，并且不会给释放buffer带来困扰。</li>
</ol>
<p>资源池</p>
<p>在服务运行期间，需要使用系统调用为用户分配资源，通常系统资源的分配都是比较耗时的，如动态创建进程／线程。可以考虑在服务启动时预先分配资源，即创建资源池，当需要资源，从资源池中获取即可，若资源池不够用时，再动态的分配，使用完成后交还到资源池中。这实际上是用空间换取时间，在服务运行期间可以节省非必要的资源创建过程。需要注意的是，使用资源池还需要根据业务和硬件环境对资源池的大小进行限制。</p>
<p>资源池是一个抽象的概念，常见的包括进程池、线程池、 内存池、连接池；这些资源池的相关资料非常多，这里就不一一介绍了。</p>
<p>锁/上下文切换</p>
<p>1.关于锁</p>
<p>对共享资源的操作是并发程序中经常被提起的一个话题，都知道在业务逻辑上无法保证同步操作共享资源时，需要对共享资源加锁保护，但是锁不仅不能处理任何业务逻辑，而且还存在一定的系统开销。并且对锁的不恰当使用，可能成为服务期性能的瓶颈。</p>
<p>针对锁的使用有如下建议：</p>
<ol>
<li>如果能够在设计层面避免共享资源竞争，就可以避免锁，如图15描述的模式;</li>
<li>若无法避免对共享资源的竞争，优先考虑使用无锁队列的方式实现共享资源；</li>
<li>使用锁时，优先考虑使用读写锁；此外，锁的范围也要考虑，尽量较少锁的颗粒度，避免其他线程无谓的等待。</li>
</ol>
<p>2.上下文切换</p>
<p>并发程序需要考虑上下文切换的问题，内核调度线程(进程)执行是存在系统开销的，若线程(进程)调度占用CPU的时间比重过大，那处理业务逻辑占用的CPU时间就会不足。在项目中，线程(进程)数量越多，上下文切换会很频繁，因此是不建议为每个用户连接创建一个线程，如图15所示的并发模式，一个线程可同时处理多个用户连接，是比较合理的解决方案。</p>
<p>多核的机器上，并发程序的不同线程可以运行在不同的CPU上，只要线程数量不大于CPU数目，上下文切换不会有什么问题，在实际的并发网络模块中，线程(进程)的个数也是根据CPU数目来确定的。在多核机器上，可以设置CPU亲和性，将进程／线程与CPU绑定，提高CPU cache的命中率，建好内存访问损耗。</p>
<p>有限状态机器</p>
<p>有限状态机是一种高效的逻辑处理方式，在网络协议处理中应用非常广泛，最典型的是内核协议栈中TCP状态转移。有限状态机中每种类型对应执行逻辑单元的状态，对逻辑事务的处理非常有效。有限状态机包括两种，一种是每个状态都是相互独立的，状态间不存在转移；另一种就是状态间存在转移。有限状态机比较容易理解，下面给出两种有限状态机的示例代码。</p>
<p>不存在状态转移</p>
<p>typedefenum _tag_state_enum{      A_STATE,    B_STATE,    C_STATE,    D_STATE}state_enum;voidSTATE_MACHINE_HANDLER(state_enum cur_state){    switch (cur_state){    case A_STATE:         process_A_STATE();         break;    case B_STATE:         process_B_STATE();         break;    case C_STATE:         process_C_STATE();         break;    default:         break;    }    return ;}</p>
<p>1234567891011121314151617181920212223242526</p>
<p>存在状态转移</p>
<p>voidTRANS_STATE_MACHINE_HANDLER(state_enum cur_state){    while (C_STATE != cur_state) {        switch (cur_state) {        case A_STATE:            process_A_STATE();            cur_state = B_STATE;            break;        case B_STATE:            process_B_STATE();            cur_state = C_STATE;            break;        case C_STATE:            process_C_STATE();            cur_state = D_STATE;            break;        default:            return ;      }   }   return ;}</p>
<p>123456789101112131415161718192021222324252627</p>
<p>时间轮</p>
<p>经常会面临一些业务定时超时的需求，用例子来说明吧。</p>
<p>功能需求：服务器需要维护来自大量客户端的TCP连接（假设单机服务器需要支持的最大TCP连接数在10W级别），如果某连接上60s内没有数据到达，就认为相应的客户端下线。</p>
<p>先介绍一下两种容易想到的解决方案,</p>
<p>方案a轮询扫描</p>
<p>处理过程为：</p>
<ol>
<li>维护一个map 记录客户端最近一次的请求时间；</li>
<li>当client_id对应连接有数据到达时，更新last_update_time；</li>
<li>启动一个定时器，轮询扫描map 中client_id 对应的last_update_time，若超过 60s，则认为对应的客户端下线。</li>
</ol>
<p>轮询扫描，只启动一个定时器，但轮询效率低，特别是服务器维护的连接数很大时，部分连接超时事件得不到及时处理。</p>
<p>方案b多定时器触发</p>
<p>处理过程为：</p>
<ol>
<li>维护一个map 记录客户端最近一次的请求时间；</li>
<li>当某client_id 对应连接有数据到达时，更新last_update_time，同时为client_id启用一个定时器，60s后触发;</li>
<li>当client_id对应的定时器触发后，查看map中client_id对应的last_update_time是否超过60s，若超时则认为对应客户端下线。</li>
</ol>
<p>多定时器触发，每次请求都要启动一个定时器，可以想象，消息请求非常频繁是，定时器的数量将会很庞大，消耗大量的系统资源。</p>
<p>方案c 时间轮方案</p>
<p>下面介绍一下利用时间轮的方式实现的一种高效、能批量的处理方案，先说一下需要的数据结构：</p>
<ol>
<li>创建0~60的数据，构成环形队列time_wheel，current_index维护环形队列的当前游标，如图19所示；</li>
<li>数组元素是slot 结构，slot是一个set，构成任务集；</li>
<li>维护一个map，记录client_id 落在哪个slot上。</li>
</ol>
<p><img src="https:////note.youdao.com/src/C5981CB237A048868220D6C27354F990" alt="img"></p>
<p>​                     图19 时间轮环形队列示意图</p>
<p>1</p>
<p>执行过程为：</p>
<ol>
<li>启用一个定时器，运行间隔1s，更新current_index，指向环形队列下一个元素，0-&gt;1-&gt;2-&gt;3…-&gt;58-&gt;59-&gt;60…0；</li>
<li>连接上数据到达时，从map中获取client_id所在的slot，在slot的set中删除该client_id；</li>
<li>将client_id加入到current_index - 1锁标记的slot中；</li>
<li>更新map中client_id 为current_id-1 。</li>
</ol>
<p>与a、b两种方案相比，方案c具有如下优势：</p>
<ol>
<li>只需要一个定时器，运行间隔1s，CPU消耗非常少；</li>
<li>current_index 所标记的slot中的set不为空时，set中的所有client_id对应的客户端均认为下线，即批量超时。</li>
</ol>
<p>上面描述的时间轮处理方式会存在1s以内的误差，若考虑实时性，可以提高定时器的运行间隔，另外该方案可以根据实际业务需求扩展到应用中。我们对Swoole的修改中，包括对定时器进行了重构，其中超时定时器采用的就是如上所描述的时间轮方案，并且精度可控。</p>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-7.md</title>
    <url>/2018/09/23/arts-7/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    用递归的思想一点一点地合并，时间复杂度是O(n+m)，空间复杂的也是O(n+m) 。写的时候遇到一个以前没有注意到的小坑，就是C语言里是没有elseif这个关键字的，esle和if之间必须有空格，不然会编译失败，</p>
<h4 id="Approach-2-Iteration"><a href="#Approach-2-Iteration" class="headerlink" title="Approach 2: Iteration"></a>Approach 2: Iteration</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prehead</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">prehead</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            prev-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    迭代l1和l2头上的元素进行比较，每次取出较小的一个放入一个新链表，并更新较小的那个元素所在的链表的指针，使其指向下一个元素，重复上一步骤，直至其中一个链表为空，把另一个链表剩下的部分拼到新链表后面，并返回新链表。</p>
<p>​    时间复杂度为O(n+m)，因为while循环的次数相当于两个链表的长度之和（忽略剩余的部分），是线性的。</p>
<p>​    空间复杂度是O(1)，迭代算法只是分配了几个指针，具有恒定的总内存占用量。</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-6.md</title>
    <url>/2018/09/16/arts-6/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> limit = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(limit);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cur = s[i];</span><br><span class="line">        <span class="keyword">if</span> ((cur == <span class="string">'('</span>) || (cur == <span class="string">'['</span>) || (cur == <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == limit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[idx++] = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((cur == <span class="string">'&#125;'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'&#123;'</span>)</span><br><span class="line">                || (cur == <span class="string">']'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'['</span>)</span><br><span class="line">                || (cur == <span class="string">')'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'('</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> idx == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"(([]))"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">isValid</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    parentheses := <span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">rune</span>&#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">'('</span> || char == <span class="string">'['</span> || char == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; parentheses[char] == stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题比较简单，解题思路比较单一（也可能是我没看到别的思路），用一个栈去从左到右的读取字符串，遇到左括号就入栈，右括号就判断与前一个是否对应，是的话就出栈，否的话就报错，直至读取完没有遇到错误的话idx的值应该等于0。</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>指针学习笔记</title>
    <url>/2018/09/09/%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C语言指针的总结"><a href="#C语言指针的总结" class="headerlink" title="C语言指针的总结"></a>C语言指针的总结</h1><p>原文出自xx_cc</p>
<p>链接：<a href="https://www.jianshu.com/p/63f3bfb58687" target="_blank" rel="noopener">https://www.jianshu.com/p/63f3bfb58687</a></p>
<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ol>
<li>不同类型的变量在内存中占据不同的字节空间。</li>
<li>内存中存储数据的最小基本单位是字节，每一个字节都有一个内存地址，这个地址是一个十六进制的数。</li>
<li>声明一个变量，在内存中是从高字节向低字节分配连续的指定字节数的空间。</li>
<li>任何数据在内存中都是以其二进制的补码形式存储的，低位存储在低字节，高位存储在高字节。</li>
<li>变量的值：存储在变量中的数据，叫做变量的值。</li>
<li>变量的地址：一个变量是由一个或者多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址。</li>
<li>如何取出变量的地址：使用&amp;（取地址运算符）运算符，&amp;变量名；这个表达式的值就是这个变量的地址。使用%p控制度输出变量的地址。</li>
<li>什么是指针：变量的地址叫做指针，指针就是地址，地址就是指针。</li>
</ol>
<p>下面通过一张图可以更直观的理解内存中的地址</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1434508-3146d4e4c4362be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p>
<p>内存中的地址演示图</p>
<a id="more"></a>

<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><ol>
<li>指针是C语言的灵魂。指针变量占据8个字节。</li>
<li>变量在内存中的存储。<br> 变量的值：存储在变量中的数据，叫做变量的值。<br> 变量的地址：组成这个变量的低字节的地址，就是这个变量的地址。</li>
<li>取出变量的地址，用&amp;运算符 %p输出变量的地址。</li>
<li>变量的地址就叫做指针，我们可以使用一个指针变量来存储变量的地址。</li>
</ol>
<h5 id="指针变量："><a href="#指针变量：" class="headerlink" title="指针变量："></a>指针变量：</h5><ol>
<li>指针变量就是专门用来存储 <strong>地址</strong> 的变量，那么我们就说指针变量指向了另外一个变量，存储着另外一个变量的地址。</li>
<li>指针可以使访问一个变量的方式分为两种。<br> a. 直接访问<br> b. 可以通过指针变量，找到这个指针指向的变量<br> 所以通过指针变量可以间接的访问指针变量指向的另外一个变量。</li>
<li><strong>如何声明一个专门用来存储地址的指针变量</strong><br> 数据类型  <code>*</code> 指针变量的名称   — <code>int * p1;</code><br> 指针变量的名字叫做p1，这个指针变量的类型是<code>int*</code> 读作int指针。<br> <code>*</code>表示这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量，所以有哪些普通的数据类型，就可以有哪些类型的指针。<br> 声明的时候注意，<code>*</code>的位置 建议  <code>int* p</code>这样提醒我们这是一个<code>int*</code>类型的指针。<br> ** 一个指针变量并不是可以存储任意类型的变量的地址，而是有限定的，只能存储和这个指针类型相同的普通变量的地址。** 所以<code>p</code> 指针变量中只能存储<code>int</code>类型变量的地址。</li>
<li>指针变量的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; 10;</span><br><span class="line">int *p &#x3D;  &amp;num; 建议int* p &#x3D; &amp;num;这样写</span><br></pre></td></tr></table></figure>

<p>p指针指向了num变量。因为p指针的值就是num变量的地址，不能直接赋值一个非地址类型的常量数据，也不能直接赋值一个变量给指针。</p>
<ol>
<li>p指针自己也有地址， 因为指针变量也是一个变量，&amp;p取到指针p的地址。</li>
<li>p操作的是p这个指针变量，可以取p得值，也可以为p赋值</li>
<li><strong>指针变量的使用</strong><br> 可以使用指针间接的操作指针指向的变量。<br> <code>*p</code> 代表 <code>p</code> 指针指向的变量。<br> <code>*p</code> 完全等价于<code>num</code> 即 <code>*p = 100</code> 完全等价于 <code>num = 100</code>。<br> <code>*p = 100;</code> 表示将100赋值给p指针指向的变量，也就是num变量</li>
</ol>
<p>使用指针变量的时候注意点<br> <code>int* p1 ,p2, p3 ;</code> 此时<code>p1</code>是<code>int *</code>指针，而<code>p2,p3</code>是<code>int</code>类型数据 如果希望全部都是指针需要 <code>int *p1, * p2, * p3;</code></p>
<ol>
<li><strong>野指针</strong><br> 我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量中是有值的，是<strong>垃圾值，随机数</strong>。因为这个时候，这个指针变量有可能指向了一块<strong>随机的空间</strong>，这个空间可能无人使用，也可能别的程序在用，也可能系统在用，这个时候，去访问指针指向的的变量的时候，就会报错。<strong>BAD_ACCESS</strong>坏地址访问错误，像这样的指针我们就叫做野指针。</li>
<li>NULL值 完全等价于0<br> 为了防止野指针的产生，建议声明一个指针变量后，最好为其初始化，如果没有变量的地址初始化给这个指针变量。那么就初始化一个<strong>NULL</strong>值。NULL值代表指针变量不指向内存中的任何地址，这样就不会出现野指针，<strong>NULL完全等价于0</strong>，所以也可以直接赋值给一个指针变量0。<br> 如果一个指针变量的值是NULL，那么去访问这个指针指向的变量的时候一定会报错。</li>
<li>多个指针指向同一个变量，修改其中一个所有指针指向的值都会改变。因为多个个指针指向的是同一块地址。即 <code>*</code> 会使指针间接的操作指针指向的变量。</li>
<li><strong>指针作为函数的参数</strong><br> 如果函数的参数是一个指针，那么就必须要为这个<strong>指针</strong>传递一个和<strong>指针类型相同的普通变量的地址</strong>，这个时候，在函数的内部去访问参数指针的变量的时候，其实访问的就是实参变量</li>
<li><strong>指针作为函数的参数，可以实现什么效果？</strong><br> 函数的内部可以修改实参变量的值。那么什么时候使用指针作为参数呢？<br> 一般函数只能返回一个数据，那么当函数需要返回<strong>多个数据</strong>的时候就可以使用<strong>指针作为参数</strong>，让<strong>调用者将自己的变量的地址传递给函数内部，函数内部通过指针就可以修改参数</strong>，函数无需将数值传回来，就已经修改了参数的值。其实scanf函数传递的就是指针，<strong>因此当函数需要多个返回值的时候就可以使用指针作为参数。</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从下面代码中就可以看出，我们可以直接在函数中修改两个变量的值。相当于函数有两个返回值。</span><br><span class="line">void  changeValue (int* p1 ,int* p2)&#123;</span><br><span class="line">    *p1 &#x3D; 100;</span><br><span class="line">    *p2 &#x3D; 200;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int num1 &#x3D; 1;</span><br><span class="line">    int num2 &#x3D; 2;</span><br><span class="line">    changeValue(&amp;num1, &amp;num2);</span><br><span class="line">    printf(&quot;num1 &#x3D; %d\n&quot;,num1);</span><br><span class="line">    printf(&quot;num2 &#x3D; %d&quot;,num2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指针为什么要分类型</strong><br> <strong>指针变量既然是一个变量就要在内存中占用字节空间</strong><br> 指针变量在内存中占据多少字节数？<br> <strong>无论指针是什么类型在内存中都是占据8个字节。</strong><br> 那为什么指针还要分类呢？<br> p指针变量中存储的是num变量的地址，也就是num变量低字节的地址，<strong>通过p指针只能找到这个地址的字节</strong>，这个时候，通过p指针找到这个字节，操作的时候，操作多少个字节是则是根据<strong>指针的类型</strong>来决定的。<br> <strong>所以指针变量的类型决定了通过这个指针找到字节以后，连续操作多少个字节空间。</strong><br> int 指针 连续操作4个字节空间<br> double 指针 连续操作8个字节空间<br> float 指针  连续操作4个字节空间<br> char 指针  连续操作1个字节空间<br> 因此，指针的类型如果不和指向的变量的类型相同的话，那么通过指针就无法正确的操作指向的变量，所以，<strong>指针的变量一定要指向一个和自己类型相同的普通变量才可以。</strong></li>
</ol>
<p>   <img src="https:////upload-images.jianshu.io/upload_images/1434508-a35b6912864b9740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="img"></p>
<p>   指针为什么要分类型？</p>
<ol start="2">
<li><p>多级指针<br> 一个指针变量中存储的是一个一级指针的地址，那么它就是二级指针，一个指针变量中存储的是一个二级指针的地址，那么它就是三级指针。<br> 二级指针：<code>数据类型 ** 指针名</code><br> 二级指针只能存储一级指针变量的地址。<br> 多级指针在开发中很少用到，遇到多级指针耐心分析一定可以理清其中的关系。</p>
</li>
<li><p>指针与整数的加减法<br> 指针可以和整数进行加减运算，指针+1并不是在指针地址的基础之上加一个字节的地址，而是在这个<strong>指针地址的基础之上加一个单位变量占用的字节数</strong>，例如：如果指针类型是<code>int *</code> 则+1代表加4个字节地址，以此类推。</p>
</li>
<li><p><strong>指针与数组</strong><br> 我们可以使用指针来遍历数组，因为数组的本质其实就是指针，当我们创建数组的时候，系统会在内存中由高地址向低地址分配连续的类型所占的空间字节数 * 数组内元素的个数的字节控件。而数组名则代表了数组的低字节地址，也就是数组的地址。<br> 1). 使用指针遍历数组的第一种方式.<br> int arr[7] = {10,20,30,40,50,60,70}; //在内存中高地址向低地址分配连续的 类型所占的空间字节数 * 数组内元素的个数 7 * 4 = 28 个字节空间<br> int* p1 = arr;    //p1指针指向了数组的第0个元素.<br> for(int i = 0; i &lt; 7; i++)<br> {<br> printf(“%d\n”,*(p1+i));<br> }</p>
<p>2). 使用指针遍历数组的第二种方式.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(arr+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3). 使用指针遍历数组的第三种方式.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">int* p1 &#x3D; arr;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(p1++));</span><br><span class="line">&#125;</span><br><span class="line">注意的地方,每次循环,p1的值都会变化。</span><br><span class="line">最后1次执行完毕之后,p1指针指向数组外面去了,p1就不再执行数组中的任何元素了。</span><br></pre></td></tr></table></figure>

<p>注意: 数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变。<br> 所以，我们不能为数组名赋值也不能修改数组名的值，但是可以使用数组名的值。<br> <strong>arr是数组的地址，也是数组中第0个元素的地址，arr+1就是数组中第一个元素的地址，数据名就是一个地址常量，无法改变。</strong></p>
</li>
<li><p><strong>数组作为函数的参数的本质</strong><br> 当数组作为函数的参数的时候，在声明这个参数数组的时候，并不是去创建一个数组，而是去创建一个用来存储地址的指针变量，如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组变成了指针，这也就是为什么我们通过sizeof计算参数数组得到的永远都是8，所以以后我们的函数如果带了一个数组参数，建议直接写一个指向数组的第0个元素的指针，在传入数组的长度</p>
</li>
<li><p><strong>索引的本质</strong><br> <strong>指针变量后面可以使用中括号，在中括弧中写上下标来访问数据。</strong><br> <code>p[n];</code>前提<code>p</code>是一个指针变量，完全等价于<code>*(p + n);</code><br> 所以<code>arr[0]</code> 就等价于 <code>* [arr + 0]</code>。<br> 操作数组我们虽然使用中括弧下标来操作，实际上内部本质仍然是使用的指针来操作。</p>
</li>
<li><p>存储指针的数组<br> 如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组<br> 格式 ：<code>元素类型 数组名[数组长度];</code> <code>int * arr[3];</code><br> arr数组里面存储int指针数据，最多存储3个。</p>
</li>
<li><p>指针与指针之间的减法运算<br> 指针与指针之间可以做减法运算，结果是一个long类型的数据，<br> 结果的意义代表两个指针指向的变量之间相差多少个单位变量，绝大多数情况下，我们用在判断数组的两个元素之间相差多少个元素<br> 如果参与减法运算的两个指针不指向同一个数组，结果就会出现问题<br> <strong>结果 = 两个指针的差 / 每一个指针变量对应的普通变量占用的字节数。</strong><br> 并且只能做减法运算，<strong>用在数组当中判断两个元素之间相差多少个元素。</strong></p>
</li>
<li><p>指针与指针在之间的比较运算 <code>&lt;, &lt;=, &gt;, &gt;=, ==, !=</code>都可以使用<br> 可以用来判断两个指针指向的变量的字节，谁在高字节，谁在低字节。或者两个指针的地址是不是同一个地址。</p>
</li>
<li><p><strong>指针和字符变量</strong><br> <code>char *name = &quot;jack&quot;;</code>表示直接将一个字符串数据初始化给一个字符指针。</p>
<p><strong>字符指针存储和字符数组存储的区别</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符数组存储：将字符串数据的每一个字符存储到字符数组的元素中，并追加一个 \n 表示结束</span><br><span class="line">char name[5] &#x3D; &quot;jack&quot;;</span><br><span class="line">&#x2F;&#x2F; 直接为字符指针初始化一个字符串数据</span><br><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">1.) 当他们都是局部变量的时候</span><br></pre></td></tr></table></figure>

<p><strong>字符数组</strong>是申请在栈区的，字符串的每一个字符存储在字符数组的每一个元素中。<br> <strong>指针变量</strong>是声明在栈区的。但是此时字符串数据是以字符数组的形式存储在<strong>常量区</strong>的。此时<strong>指针变量中存储的是字符串在常量区的地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.) 当他们作为全局变量的时候</span><br></pre></td></tr></table></figure>

<p><strong>字符数组</strong>是存储在常量区的，字符串的每一个字符存储在这个数组中的每一个元素中。<br> <strong>字符指针</strong>也是存储在常量区，字符串也是以字符数组的形式存储在常量区，<strong>指针中存储的是字符串在常量区的地址。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**以字符数组存储的字符串数据，可以修改字符数组的元素。可变</span><br><span class="line">以字符指针的形式存储字符串数据，这个时候字符指针指向的字符串数据是无法修改的，不可变**</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>字符串的恒定型</strong><br> 前提：<strong>以字符指针形式存储的字符串</strong><br> 1.) 当我们以字符指针的形式存储字符串的时候，无论如何，字符串数据是存储在常量区的，并且，一旦存储到常量去中去，这个字符串数据就无法更改。</p>
<p>2.) 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储到常量区中。</p>
<p>3.) 当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，因为原来的字符串数据是不可更改的，而是重新的创建了一个字符串，把这个新的字符串的地址赋给他。建议使用字符指针来存储字符串数据。优势：长度任意。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">nsme &#x3D; &quot;rose&quot;;</span><br><span class="line">&#x2F;&#x2F; 这样可以 但是并不是把jack改成了rose，而是重新创建了一个&quot;rose&quot;,把rose地址赋值给name</span><br></pre></td></tr></table></figure>

<ol>
<li>字符串数组<br> <code>char *names[4] = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};</code><br> names数组的元素的类型是char指针，初始化给元素的字符串数据是存储在常量区的。元素中存储的是<strong>字符串在常量区的地址</strong><br> 因此这是一个存储指针的数组，每一个元素的类型是一个指针，占用得内存为8个字节。</li>
<li>指向函数的指针。<br> 程序在运行的时候，会将程序加载到内存，内存的代码段中主要存储的就是程序的代码，而程序的代码就包括函数。<strong>既然函数要存储在内存中，那么肯定要用1块空间来存储，那么这个块空间一定有1个地址。</strong><br> 因此我们就可以<strong>声明1个指针用来存储这个函数的地址</strong>，也就是说让这个指针指向这个函数。这样我们就可以使用<strong>指针来间接的调用函数</strong>。<br> 优势: 调用函数有了两种方式。<br> 1.) 直接使用函数名调用<br> 2.) 使用指向函数的指针间接调用.</li>
<li>指向函数的指针的声明<br> 一个指向函数的指针，并不是任意的函数都可以指向，而是有限定的，要求指向的<strong>函数的返回值类型和参数描述必须要与指针的描述一样</strong>。<br> 声明语法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 (*指针名)([参数列表]);</span><br><span class="line">void (*pFunction)();</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFunction。</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向没有返回值,并且没有参数的函数。</span><br><span class="line">int (*pFun)(int num1,int num2);</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFun.</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向返回值为int类型 并且有两个整型的参数的函数.</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指向函数的指针的初始化</strong><br><strong>函数的名称就代表函数的地址，因此我们直接将符合条件的函数的名称赋值给这个指针。</strong><br>并且我们有两种方法可以通过指针来调用这个函数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int MaxValue (int a, int b)&#123;</span><br><span class="line">       return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;    </span><br><span class="line">       int(*pMaxValue)(int a, int b) &#x3D; MaxValue; &#x2F;&#x2F; 创建一个返回int 并且有两个int型参数的函数指针，并赋值。</span><br><span class="line">       printf(&quot;%d\n&quot;, pMaxValue(5,10)); &#x2F;&#x2F; 通过指针调用函数方法1</span><br><span class="line">       printf(&quot;%d\n&quot;,(*pMaxValue)(6,9)); &#x2F;&#x2F; 通过指针调用函数方法2</span><br><span class="line">       printf(&quot;%d\n&quot;,MaxValue(9, 13)); &#x2F;&#x2F; 调用函数</span><br><span class="line">       printf(&quot;%p\n&quot;,MaxValue); &#x2F;&#x2F; 输出函数的地址</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识点总结</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-5</title>
    <url>/2018/08/12/arts-5/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<a id="more"></a>

<p><strong>Solution:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">char</span> **strs, <span class="keyword">int</span> strsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strsSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    先通过把第一个字符串跟每个字符串比较的方式计算出公共前缀的长度</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]); <span class="keyword">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (tempIndex = <span class="number">0</span>; tempIndex &lt; index; tempIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][tempIndex] != strs[i][tempIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        当tempIndex &lt; Index时，可以更新Index来省去多余的计算</span></span><br><span class="line">        <span class="keyword">if</span> (tempIndex &lt; index) &#123;</span><br><span class="line">            index = tempIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算出前缀长度后，字符串数据是存储在常量区的，不能直接更改，所以要为前缀申请内存空间并付值，+1是为了留出'\0'的位置</span></span><br><span class="line">    <span class="keyword">char</span> *prefix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (index + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">strncpy</span>(prefix, strs[<span class="number">0</span>], index);</span><br><span class="line">    prefix[index] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arr[] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = longestCommonPrefix(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Summary:</strong></p>
<p>这是一个比较容易想到的思路，时间复杂度的是O(n^2)，不算快；空间复杂度是O(1)。可以优化的点有两个：tempIndex小于Index时更新Index，减少不必要的比较；计算出前缀的长度再去为变量申请空间，会比一上来就申请strs[0]大小的空间之后再截断的方式好一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	fst := strs[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> carry <span class="keyword">string</span></span><br><span class="line">L0:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> fst &#123;</span><br><span class="line">		t := fst[<span class="number">0</span> : i+<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;</span><br><span class="line">			<span class="keyword">if</span> !strings.HasPrefix(v, t) &#123;</span><br><span class="line">				<span class="keyword">break</span> L0</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(carry) &#123;</span><br><span class="line">			carry = t</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> carry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://angular.io/guide/architecture-services" target="_blank" rel="noopener">Angular:Introduction to services and dependency injection</a></p>
<p>Components consume services; that is, you can inject a service into a component, giving the component access to that service class.</p>
<p>组件使用服务。换句话说，你可以把某个服务注入到组件中，从而使得这个组件可以访问到该服务。</p>
<p>Dependency injection (often called DI) is wired into the Angular framework and used everywhere to provide new components with the services or other things they need.</p>
<p>依赖注入，经常被简称为DI，在Angular中被广泛使用。你几乎可以在任何地方，看见他们为各类组件提供所需的服务。</p>
<p>The injector maintains a container of dependency instances that it has already created, and reuses them if possible.</p>
<p>注入器维护着一个容器，这个容器中是各类已经被创建过的依赖的实例。如果可能的话，注入器会优先复用这些实例。</p>
<p>A provider is a recipe for creating a dependency. For a service, this is typically the service class itself. For any dependency you need in your app, you must register a provider with the app’s injector, so that the injector can use it to create new instances.</p>
<p>“提供者”是创建依赖时所使用的机制。对于普通服务来说，“提供者”通常就是服务类本身。但对于应用中所需的其他依赖来说，你必须通过“注入器”注册一个“提供者”，以便注入器可以使用该“提供者”创建新的实例。</p>
<p>When Angular discovers that a component depends on a service, it first checks if the injector already has any existing instances of that service.</p>
<p>当Angular发现一个组件依赖于某个服务时，它会先去检查“注入器”中是否已经有了这个服务的实例。</p>
<p>If a requested service instance does not yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</p>
<p>如果被请求的服务实例不存在，那么“注入器”就会用注册过的“提供者”创建一个新的实例，然后把它加入到“注入器”中，并把这个实例返回给Angular。</p>
<h2 id="SHARE"><a href="#SHARE" class="headerlink" title="SHARE"></a>SHARE</h2><h3 id="关于-typedef-的一些理解"><a href="#关于-typedef-的一些理解" class="headerlink" title="关于 typedef 的一些理解"></a>关于 typedef 的一些理解</h3><ol>
<li>表达方式简洁。</li>
<li>可以使程序参数化，提高程序的可移植性。如果 typedef 声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需要改变 typedef 类型定义就可以了。</li>
<li>为程序提供更好的说明性——Treeptr 类型显然比一个声明为指向复杂结构的指针更容易让人理解。</li>
</ol>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-4</title>
    <url>/2018/08/04/arts-4/</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.</li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.</li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<a id="more"></a>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">0</span>, value2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += temp) &#123;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        value1 = convert(s[i]);</span><br><span class="line">        value2 = convert(s[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2 &amp;&amp; value2 != <span class="number">0</span>) &#123;</span><br><span class="line">            result += value2 - value1;</span><br><span class="line">            temp = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://www.kernel.org/doc/html/latest/userspace-api/unshare.html" target="_blank" rel="noopener">The Linux Kernel</a></p>
<p>Most legacy operating system kernels support an abstraction of threads as multiple execution contexts within a process.</p>
<p>很多老旧的操作系统内核以这样的方式来支持线程：它们把线程抽象成了同一进程内的多个执行上下文。</p>
<p>These kernels provide special resources and mechanisms to maintain these “threads”.</p>
<p>这些系统内核提供了特殊的资源和管理机制来支持这类线程。</p>
<p>The Linux kernel, in a clever and simple manner, does not make distinction between processes and “threads”.</p>
<p>而Linux内核，则采用了一种聪明而且简单的方式——在内核层面上，它并不区分进程和线程。</p>
<p>The kernel allows processes to share resources and thus they can achieve legacy “threads” behavior without requiring additional data structures and mechanisms in the kernel.</p>
<p>Linux内核允许多条进程共享资源。这样做的好处在于，即使内核不再提供额外的数据结构和管理机制，和传统线程类似的行为也能被实现出来。</p>
<p>The power of implementing threads in this manner comes not only from its simplicity but also from allowing application programmers to work outside the confinement of all-or-nothing shared resources of legacy threads.</p>
<p>以这样的实现方式来支持线程，不仅简单，而且也可以帮助程序员们摆脱曾经让他们感到烦恼的一个限制：在传统的线程模型中，要么就不能共享资源，要么就得全局共享资源。</p>
<p>On Linux, at the time of thread creation using the clone system call, applications can selectively choose which resources to share between threads.</p>
<p>在Linux中，程序在使用clone这个系统指令去创建线程时，可以选择性地指定哪部分资源会被其他线程所共享，而无需将所有资源都共享出去。</p>
<p>unshare() system call adds a primitive to the Linux thread model that allows threads to selectively ‘unshare’ any resources that were being shared at the time of their creation.</p>
<p>unshare这个系统指令，为Linux的线程模型增加了一个基本功能：即便一些资源在线程创建时被设置为可共享了，也可以使用unshare指令将这些资源重新收归私有。</p>
<p>OSI and TCP/IP are the most used models to abstract the computer network.</p>
<p>OSI和TCP/IP是在抽象计算机网络时最常用的两种模型。</p>
<p>OSI, the theoretically better abstraction of the network model, failed to be widely adopted due to its complexity.</p>
<p>OSI，这种在理论上看似更优的网络模型的抽象方式，由于过于复杂而没有被工业界大规模采用。</p>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINES 5000 <span class="comment">/* max #lines to be sorted */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *lineptr[MAXLINES]; <span class="comment">/* pointers to text lines */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000 <span class="comment">/* size of available space */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE]; <span class="comment">/* storage for alloc */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf; <span class="comment">/* next free position */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">/* return pointer to n characters */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123; <span class="comment">/* it fits */</span> allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n; <span class="comment">/* old p */</span> &#125; <span class="keyword">else</span> <span class="comment">/* not enough room */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span> <span class="comment">/* free storage pointed to by p */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) allocp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getline2</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim - <span class="number">1</span> &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != <span class="string">'\n'</span>; ++i)</span><br><span class="line">        s[i] = c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">        s[i] = c;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort input lines */</span></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">int</span> nlines; <span class="comment">/* number of input lines read */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((nlines = readlines(lineptr, nlines)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        qsort(lineptr, <span class="number">0</span>, nlines - <span class="number">1</span>);</span><br><span class="line">        writelines(lineptr, nlines);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: input too big to sort\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 1000 <span class="comment">/* max length of any input line */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> maxlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, nlines;</span><br><span class="line">    <span class="keyword">char</span> *p, <span class="built_in">line</span>[MAXLEN];</span><br><span class="line">    nlines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = getline2(<span class="built_in">line</span>, MAXLEN)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (nlines &gt;= maxlines || (p = alloc(len)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">line</span>[len - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">/* delete newline */</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p, <span class="built_in">line</span>);</span><br><span class="line">            lineptr[nlines++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> nlines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nlines; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, lineptr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* qsort: sort v[left]...v[right] into increasing order */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="comment">/* do nothing if array contains */</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* fewer than two elements */</span></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);</span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(v[i], v[left]) &lt; <span class="number">0</span>) swap(v, ++last, i);</span><br><span class="line">    swap(v, left, last);</span><br><span class="line">    qsort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    qsort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* swap: interchange v[i] and v[j] */</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    temp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123;</span><br><span class="line">        allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) &#123;</span><br><span class="line">        allocp = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a = alloc(<span class="number">1</span>);</span><br><span class="line">    *(a<span class="number">-1</span>) = <span class="string">'b'</span>;</span><br><span class="line">    *a = <span class="string">'a'</span>;</span><br><span class="line">    *(a+<span class="number">1</span>) = <span class="string">'b'</span>;</span><br><span class="line"><span class="comment">//    *(a+2) = '\0';</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Created by akaQin on 2018&#x2F;8&#x2F;11.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char *strcat(char *s, char *t) &#123;</span><br><span class="line">    char *se &#x3D; s;</span><br><span class="line">&#x2F;&#x2F;    for (; *se; ++se);</span><br><span class="line">        while (*se !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">            se++;</span><br><span class="line">        &#125;</span><br><span class="line">    while ((*se++ &#x3D; *t++) !&#x3D; &#39;\0&#39;);</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char s[] &#x3D; &quot;ab&quot;;</span><br><span class="line"></span><br><span class="line">char t[] &#x3D; &quot;cd&quot;;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    printf(&quot;%s&quot;, strcat(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-3</title>
    <url>/2018/07/29/arts-3/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a><strong>Example 2:</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>



<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a><strong>Example 3:</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hold = x;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        val = val * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val == hold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.5/en/replication-implementation.html" target="_blank" rel="noopener">MySQL Replication Implementation</a></p>
<p>Replication is based on the master server keeping track of all changes to its databases (updates, deletes, and so on) in its binary log.</p>
<p>复制是通过将所有数据库修改操作记录（更新，删除等）到了日志文件中的主服务器实现的。</p>
<p>The binary log serves as a written record of all events that modify database structure or content (data) from the moment the server was started.</p>
<p>日志服务器担负着将各类修改记录写入日志文件的职责。从日志服务器被启动的那一刻起，所有修改了数据库结构或者数据的事件，都会被它记录下来。</p>
<p>Typically, SELECT statements are not recorded because they modify neither database structure nor content.</p>
<p>一般来说，SELECT语句不会被记录下来，因为他们既不会影响数据库的结构，也不会影响数据库的数据。</p>
<p>Each slave that connects to the master requests a copy of the binary log.</p>
<p>每台接上了主服务器的从服务器都会请求一份二进制日志的拷贝文件。</p>
<p>That is, it pulls the data from the master, rather than the master pushing the data to the slave.</p>
<p>那就是，“从服务器”从“主服务器”那里将日志拉取回来，而非主服务器向从服务器推送日志。</p>
<p>The slave also executes the events from the binary log that it receives. This has the effect of repeating the originalchanges just as they were made on the master.</p>
<p>从服务器会将它收到的二进制日志中所记录的事件再执行一遍，这样就起到了重复这些操作的效果，就好像这些操作在主服务器上被执行时一样。</p>
<p>Tables are created or their structure modified, and data is inserted, deleted, and updated according to the changes that were originally made on the master.</p>
<p>根据主服务器对于各类操作的记录，从服务器上的数据表会相应地被创建或修改、而从服务器上的数据也会被相应地插入、删除或更新。</p>
<h2 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h2><p>逆波兰计算器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP 100 <span class="comment">/* max size of operand or operator */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span> <span class="comment">/* signal that a number was found */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> [])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> NUMBER:</span><br><span class="line">                push(atof(s));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                push(pop() + pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                push(op2 - pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                push(pop() * pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                op2 == <span class="number">0.0</span> ? <span class="built_in">printf</span>(<span class="string">"zero divisor\n"</span>) : push(pop() / op2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: unknown command %s\n"</span>, s);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100 <span class="comment">/* maximum depth of val stack */</span></span></span><br><span class="line"><span class="keyword">int</span> sp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> val[MAXVAL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &lt; MAXVAL) &#123;</span><br><span class="line">        val[sp++] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack full, can't push %g\n"</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val[--sp];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getop: get next character or numeric operand */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, c;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getch()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>) &#123; ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF) &#123;</span><br><span class="line">        ungetch(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 100</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE]; <span class="comment">/* buffer for ungetch */</span></span><br><span class="line"><span class="keyword">int</span> bufp = <span class="number">0</span>; <span class="comment">/* next free position in buf */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">/* get a (possibly pushed-back) character */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bufp &gt; <span class="number">0</span>) ? buf[--bufp] : getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">/* push character back on input */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufp &gt;= BUFSIZE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ungetch: too many characters\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buf[bufp++] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-2</title>
    <url>/2018/07/09/arts-2/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Note:</strong></p>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	minInt32, maxInt32 := <span class="number">-2147483648</span>, <span class="number">2147483647</span></span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; x != <span class="number">0</span>; x = x/<span class="number">10</span> &#123;</span><br><span class="line">		result = (result * <span class="number">10</span>) + x % <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> result &gt; maxInt32 || result &lt; minInt32  &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>​    首先想到的是把int转成字符串或码点数组，但没成功，思考后没有想到别的思路。后来看Discuss使用对10取余，pop&amp;push的方式，感觉豁然开朗，于是自己尝试写下了这种解法，美中不足是maxInt32和minInt32都是手动填写的，go语言里貌似没有现成的常量（也可能是我没找到），但肯定有能计算这个数的表达式，现在还不知道该怎么写，以后回来填坑。</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>原文：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/index.html" target="_blank" rel="noopener">Act with Prudence</a></p>
<blockquote>
<p>*”Whatever you undertake, act with prudence and consider the consequences” Anon*</p>
</blockquote>
<p>​    源自耗子叔专栏推荐文章 <a href="https://legacy.gitbook.com/book/97-things-every-x-should-know/97-things-every-programmer-should-know/details" target="_blank" rel="noopener">97 Things Every Programmer Should Know</a> 中的第一篇，这个系列文章每过段时间看总会有新的认知，是难得的程序员用来学习并锻炼英文阅读能力的好文，推荐给大家。</p>
<p>​    我们在实际项目中经常遇到”doing it right” or “doing it quick”的问题，我的习惯是做事力求完美，但有些时候还是不够谨慎，这是我日后需要注意的。再就是一个项目第一版的质量非常重要，它决定了后面的迭代开发和维护的成本和效率，所以第一版尤其要写的仔细，多思考，即使是一些小的不合适的地方也要立即改正。不过我们也难免遇到因为排期压力妥协，遗留技术债务的情况，这时候一定要记录项目中遗留了哪些坑，还有哪些地方是需要完善的，并尽快处理这些逻辑。拖的越久，越难修复，最可怕的是拖到重构的代价已经超过重写，但为了服务在线还要继续维护，那剩下的只有无尽的痛苦，崩溃。。</p>
<h1 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h1><p>计算斐波纳切数列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibonacci1(i<span class="number">-2</span>) + fibonacci1(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci2</span><span class="params">(j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= j; i++ &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fibonacci1(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"fibonacci1 done: %v \n"</span>, time.Since(t1))</span><br><span class="line"></span><br><span class="line">	t2 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fibonacci2(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"fibonacci2 done: %v \n"</span>, time.Since(t2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    学习的过程中做做这种小练习还是蛮有意思的，上面的代码分别用递归（从大到小）和动态规划（从小到大）的思路进行实现。尤其是第二种从小到大计算的算法，“a, b = b, a+b” 因为我之前没写过python，看到后给我眼前一亮的感觉。写完后发现效率很差，开始用goroutine去优化性能，写的过程中坑还是蛮多的：</p>
<ul>
<li><p>对计数器的应用，如果顺序写的不对会导致wg.Done执行多次把数计成负的报一个panic异常；</p>
</li>
<li><p>还有在for循环中用goroutine 调用闭包时，这个单独的变量i是被所有 的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了i并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，所以当这些goroutine开始读取i的值时，它们所看到的值已经是slice的最后一个元素了。 显式地添加这个参数，我们能够确保使用的i是当go语句执行时的“当前”那个i。</p>
</li>
</ul>
<p>  写完后会发现第二种解法会比第一种快很多很多。</p>
<h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://laravel-china.org/topics/9991/20-laravel-eloquent-necessary-practical-skills" target="_blank" rel="noopener">20 个 Laravel Eloquent 必备的实用技巧</a></p>
<p>​    一些你可能还不知道的Larvel实用技巧，学习了～</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-1</title>
    <url>/2018/06/26/arts-1/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> nums[k1+<span class="number">1</span>:] &#123;</span><br><span class="line">            <span class="keyword">if</span> v1 + v2 == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="keyword">int</span>&#123;k1, k1 + k2 + <span class="number">1</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach 2"></a>Approach 2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> j, ok := m[target-v]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul>
<li>Time complexity : O(n^2)O(n2). For each element, we try to find its complement by looping through the rest of array which takes O(n)O(n) time. Therefore, the time complexity is O(n^2)O(n2).</li>
<li>Space complexity : O(1)O(1).</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>​    Approach 1 is the simplest and low-grade arithmetic which I came up with first.Due to it is my first time to solving problem on leetcode, I have no other ideas.I found the approach 2 in Solution tag, it has a much faster time complexity than the other one and it’s an extension of my thinking.</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>​    由于我的英语实在太渣了，暂时没找到啥合适的英文文章做反思总结，所以第一周的Review先用中文的代替，下周开始一定替换成英文。</p>
<blockquote>
<p><a href="https://studygolang.com/articles/2216" target="_blank" rel="noopener">为什么 Go 语言把类型放在后面？</a></p>
</blockquote>
<p>​    相信大家在学go语言的时候，尤其是有c语言基础的人，一定会有和我一样的疑问，go作为一门类c语言，其他地方都和c很像，唯独类型为什么要放在变量名后面？这么奇葩？后来看到耗子叔的解释，犹如醍醐灌顶，不能认同更多：</p>
<blockquote>
<p>Go的语法并不奇葩，Go的作者也是C的重度使用者甚至C的作者，当你觉得它奇葩，通常来说是自己没有理解，凡事都问几个为什么，你会明白更多。</p>
</blockquote>
<p>​    看了上面引用的文章，对Go语言为什么要把类型放在后面有了初步的理解：C语言的写法在声明一些比较复杂的函数，尤其是带有指针的参数时，会变得非常难懂，容易引起混淆。由于我没有C的基础，感觉理解的还不够透彻，打算等学完C再来看一遍，相信一定会有更深刻的理解。</p>
<h1 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h1><p>​    用一个二叉树实现插入排序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	value       <span class="keyword">int</span></span><br><span class="line">	left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> root *tree</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		root = add(root, v)</span><br><span class="line">	&#125;</span><br><span class="line">	appendValues(values[:<span class="number">0</span>], root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="keyword">int</span>, t *tree)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		values = appendValues(values, t.left)</span><br><span class="line">		values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">		values = appendValues(values, t.right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="keyword">int</span>)</span> *<span class="title">tree</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">		t = <span class="built_in">new</span>(tree)</span><br><span class="line">		t.value = value</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">		t.left = add(t.left, value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.right = add(t.right, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>arts</title>
    <url>/2018/06/26/arts/</url>
    <content><![CDATA[<p>ARTS is a learning activity initiated by <a href="https://weibo.com/haoel?profile_ftype=1&is_all=1#_0" target="_blank" rel="noopener">Chen Hao</a></p>
<blockquote>
<p>A: Algorithm example which I learned on <a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a>;</p>
<p>R: Review an English blog or essay;</p>
<p>T: Technical skills which I learned;</p>
<p>S: Share something which I learn from a classic computer book;</p>
</blockquote>
<p>In the next year, I will write a ARTS note every week;</p>
<p>If you have suggestions or inspiration， welcome to communicate with me</p>
<a id="more"></a>

<p>e-mail: <a href="mailto:qinlong@akaqin.me">qinlong@akaqin.me</a></p>
<p>June 24, 2018</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统》第一章</title>
    <url>/2018/06/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    hello程序的生命周期是从一个源程序开始的。源程序是一个由值0和1组成的位（又称比特）序列，8个位组成一组，称为字节。每个字节必保湿程序中的某些特殊文本字符。大部分计算机系统使用ASCII标准来表示文本字符，这种方式实际上就是一个唯一的单字节大小的整数值来表示每个字符（入下图）。</p>
<p><img src="http://pfjta0ejx.bkt.clouddn.com/hello-ASCII.png" alt="ASCII"></p>
<p>​    hello.c程序是以字节序列的方式存储在文本文件中的。每个字节都有一个整数值，对应某些字符。这种表示方法说明了一个节本思想：系统中所有信息——包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传输的数据，都是由一串比特表示的，区别不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>​    hello程序的生命周期是从一个高级C语言开始的，因为这种形式被人读懂。然而为了在系统上运行，每条C语句被其他程序转化为一系列低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存起来。下面是GCC编译驱动器把源文件翻译成可执行文件的四个阶段。</p>
<p><img src="http://pfjta0ejx.bkt.clouddn.com/compile-system.png" alt=""></p>
]]></content>
      <categories>
        <category>《CSAPP》笔记</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux私房菜》学习笔记</title>
    <url>/2018/03/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="Linux中，Ctrl组合键"><a href="#Linux中，Ctrl组合键" class="headerlink" title="Linux中，Ctrl组合键"></a>Linux中，Ctrl组合键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+c 结束正在运行的程序</span><br><span class="line"></span><br><span class="line">Ctrl+d 结束输入或退出shell</span><br><span class="line"></span><br><span class="line">Ctrl+s 暂停屏幕输出【锁住终端】</span><br><span class="line"></span><br><span class="line">Ctrl+q 恢复屏幕输出【解锁终端】</span><br><span class="line"></span><br><span class="line">Ctrl+l 清屏，【是字母L的小写】等同于Clear</span><br><span class="line"></span><br><span class="line">Ctrl+a 切换到命令行开始</span><br><span class="line"></span><br><span class="line">trl+e 切换到命令行末尾</span><br><span class="line"></span><br><span class="line">Ctrl+u 清除剪切光标之前的内容</span><br><span class="line"></span><br><span class="line">Ctrl+k 清除剪切光标及光标之后的内容</span><br><span class="line"></span><br><span class="line">Ctrl+y 在光标处粘贴剪切的内容</span><br><span class="line"></span><br><span class="line">Ctrl+r 查找历史命令【输入关键字，就能调出以前执行过的命令】</span><br><span class="line"></span><br><span class="line">Ctrl+t 调换光标所在处与其之前字符位置，并把光标移到下个字符</span><br><span class="line"></span><br><span class="line">Ctrl+x+u 撤销操作</span><br></pre></td></tr></table></figure>
<h2 id="第四章、基础操作入门"><a href="#第四章、基础操作入门" class="headerlink" title="第四章、基础操作入门"></a>第四章、基础操作入门</h2><h3 id="关机或重启"><a href="#关机或重启" class="headerlink" title="关机或重启"></a>关机或重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据同步写入磁盘：</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line">关机：</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line">重启：</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日期和时间：date</span><br><span class="line">日历：cal</span><br><span class="line">计算器：bc</span><br></pre></td></tr></table></figure>

<h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Tab]:命令补全或文件补齐</span><br><span class="line">[Ctrl]-c:中断目前程序</span><br><span class="line">[Ctrl]-d:（键盘输入结束，End Of File，EOF 或 End Of Input），相当于输入exit</span><br><span class="line">[shift]+&#123;[PageUP]|[Page Down]&#125;:翻页</span><br></pre></td></tr></table></figure>

<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--help</span><br><span class="line">man page</span><br><span class="line">info page</span><br></pre></td></tr></table></figure>

<h2 id="第五章、文件权限与目录配置"><a href="#第五章、文件权限与目录配置" class="headerlink" title="第五章、文件权限与目录配置"></a>第五章、文件权限与目录配置</h2><h3 id="修改文件或目录属组"><a href="#修改文件或目录属组" class="headerlink" title="修改文件或目录属组"></a>修改文件或目录属组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-R] group dirname&#x2F;filename   </span><br><span class="line">chown [-R] user dirname&#x2F;filename    </span><br><span class="line">chown [-R] user:group dirname&#x2F;filename</span><br></pre></td></tr></table></figure>

<h3 id="修改文件或目录权限"><a href="#修改文件或目录权限" class="headerlink" title="修改文件或目录权限"></a>修改文件或目录权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-R] [ugoa][+-&#x3D;][rwx] dirname&#x2F;filename</span><br><span class="line">chmod [-R] [xyz] dirname&#x2F;filename (xyz为0-7的数字)</span><br></pre></td></tr></table></figure>

<h3 id="操作与权限的关系"><a href="#操作与权限的关系" class="headerlink" title="操作与权限的关系"></a>操作与权限的关系</h3><p> <img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/DB45115B20484E5D93435C808DEA4B6C/31" alt="image"></p>
<h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><ul>
<li>正规文件（regular file)：第一个字符为[-],包括纯文本文档（ASCII），二进制文件（binary），数据格式文件（data）；</li>
<li>目录（directory）：第一个字符为[d]；</li>
<li>连接档（link）：第一个字符为[l]；</li>
<li>设备与装置文件（device）：通常都集中在/dev目录下，分为区块(block)设备档[b]和字符(character)设备文件[c];</li>
<li>资料接口文件（sockets）：第一个字符为[s]；</li>
<li>数据传输文件（FIFO，pipe）：第一个字符为[p];<h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3></li>
<li>/（root，根目录）：与开机系统有关；</li>
<li>/usr(unix software recourse):与软件安装／执行有关</li>
<li>/var(variable):与系统运作过程有关；</li>
<li>/bin:很多配置文件和指令的目录；</li>
<li>/boot:开机用到的文件；</li>
<li>/dev:装置与接口设备；</li>
<li>/etc:系统主要配置文件；</li>
<li>/lib:系统函数库；</li>
<li>/media:可移除装置，如光盘，软盘，DVD；</li>
<li>/opt:第三方协力软件目录；</li>
<li>/run:早起的FHS规定系统开机后所产生的各项信息放置目录;</li>
<li>/sbin:设定系统环境的指令;</li>
<li>/srv:一些网络服务启动后，需要取用的数据目录;</li>
<li>/tmp:临时文件目录;</li>
<li>/home:家目录;</li>
<li>/lost+found:系统发生错误时，遗失片段放置目录；</li>
</ul>
<h2 id="第六章、文件与目录管理"><a href="#第六章、文件与目录管理" class="headerlink" title="第六章、文件与目录管理"></a>第六章、文件与目录管理</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#显示当前目录</span><br><span class="line">pwd [-P]    </span><br><span class="line">-P:显示真实路径，而非链接（link）路径</span><br><span class="line"></span><br><span class="line">#建立新目录</span><br><span class="line">mkdir 【-mp] dirname    </span><br><span class="line">-m:配置文件权限</span><br><span class="line">-p：递归建立</span><br><span class="line"></span><br><span class="line">#删除空目录</span><br><span class="line">rmdir [-p] dirname  </span><br><span class="line">-p：连同上层的空目录一起删除</span><br></pre></td></tr></table></figure>
<h3 id="执行文件所在路径的变量-PATH"><a href="#执行文件所在路径的变量-PATH" class="headerlink" title="执行文件所在路径的变量$PATH"></a>执行文件所在路径的变量$PATH</h3><p>只有在$PATH中的指令才可以在任意地方执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH  #查看</span><br><span class="line"></span><br><span class="line">PATH&#x3D;&quot;$PATH:&#x2F;root&quot;  #把&#x2F;root加入到$PATH中</span><br></pre></td></tr></table></figure>

<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看</span><br><span class="line">ls [-aAdfFhilnrRSt] filename&#x2F;dirname    </span><br><span class="line">ls [--color&#x3D;&#123;never,auto,always&#125;] filename&#x2F;dirname</span><br><span class="line">ls [--full-time] filename&#x2F;dirname</span><br><span class="line">-a : 全部文件，包括隐藏文件（.开头)</span><br><span class="line">-d : 仅列出目录本身，而不是目录内文件</span><br><span class="line">-l : 长数据串输出，包含文件属性、权限等数据</span><br><span class="line"></span><br><span class="line">#复制</span><br><span class="line">cp [-adfilprsu] 来源文件(source) 目标文件(destination)  </span><br><span class="line">cp [options] source1 source2 source3 .... directory</span><br><span class="line">-a : 相当于-dr --preserve&#x3D;all的意思</span><br><span class="line">-d : 若源文件为链接文件属性(link file),则复制链接文件属性，而非文件本身</span><br><span class="line">-f : 强制（force),若文件已存在，删除后再尝试一次</span><br><span class="line">-i ：若目标文件已存在，覆盖前先询问</span><br><span class="line">-l : 建立硬连接，而非复制文件本身</span><br><span class="line">-p : 连同属性（权限，用户，时间）一起复制，而非使用默认属性</span><br><span class="line">-r : 递归</span><br><span class="line">-s ：软链</span><br><span class="line">-u : destination 比 source旧才更新，或destination不存在才复制</span><br><span class="line"></span><br><span class="line">#移除</span><br><span class="line">rm [-fir] filename&#x2F;dirname</span><br><span class="line">-f : force,忽略不存在的文件，不报错</span><br><span class="line">-i : 互动模式，删前确认</span><br><span class="line">-r ：递归</span><br><span class="line"></span><br><span class="line">#移动</span><br><span class="line">mv [-fiu] source destination</span><br><span class="line">mv [options] source1 source2 source3 ... directory</span><br><span class="line">-f : force</span><br><span class="line">-i : 若目标文件已存在，询问是否覆盖</span><br><span class="line">-u : 若目标已存在，且source比较新，才会更新</span><br></pre></td></tr></table></figure>

<h3 id="取得路径和文件名"><a href="#取得路径和文件名" class="headerlink" title="取得路径和文件名"></a>取得路径和文件名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#路径</span><br><span class="line">basename &#x2F;a&#x2F;b&#x2F;c     #c</span><br><span class="line">#文件名</span><br><span class="line">dirname &#x2F;a&#x2F;b&#x2F;c      #&#x2F;a&#x2F;b</span><br></pre></td></tr></table></figure>

<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li>cat(con++cat++enate)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br><span class="line">-n : 打印行号</span><br></pre></td></tr></table></figure></li>
<li>tac(反向的cat)</li>
<li>nl</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl [-bnw] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>more(一页一页翻动)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：查找</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">b：往回翻页</span><br></pre></td></tr></table></figure>
<ul>
<li><p>less（一页一页反动）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：向下查找</span><br><span class="line">?字符串：向上查找</span><br><span class="line">n：重复前一个搜寻</span><br><span class="line">N：反向重复前一个搜寻</span><br><span class="line">g：去第一行</span><br><span class="line">G：去最后一行</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">[pagedown]:下一页</span><br><span class="line">[pageup]:上一页</span><br></pre></td></tr></table></figure></li>
<li><p>head（取出前面几行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head [-n number] file</span><br><span class="line">head [-n +number] file  #取反，后n行不显示</span><br></pre></td></tr></table></figure>
</li>
<li><p>tail（取后面几行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail [-n number] [-f] file</span><br><span class="line">head [-n -number] file  #取反，前n行不显示</span><br><span class="line">-f：动态输出</span><br></pre></td></tr></table></figure></li>
<li><p>od（非纯文本文档）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">od [-t TYPE] file</span><br></pre></td></tr></table></figure>
<h3 id="新建文档或修改文件时间"><a href="#新建文档或修改文件时间" class="headerlink" title="新建文档或修改文件时间"></a>新建文档或修改文件时间</h3><ul>
<li>mtime（modification time）：文件内容变更时间(ls默认时间)</li>
<li>ctime（status time）：文件状态（权限、属性）变更时间</li>
<li>atime（access time）：文件读取时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch [-acdmt] file #建立一个新文件或更新文件的mtime和atime</span><br></pre></td></tr></table></figure>
<h3 id="默认权限和隐藏权限"><a href="#默认权限和隐藏权限" class="headerlink" title="默认权限和隐藏权限"></a>默认权限和隐藏权限</h3><ul>
<li>文件预设权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask</span><br></pre></td></tr></table></figure></li>
<li>文件隐藏属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chattr [+-&#x3D;][ASacdistu] file&#x2F;dir    #配置文件或目录隐藏属性</span><br><span class="line">lsattr [-adR] file&#x2F;dir  #查看隐藏属性</span><br></pre></td></tr></table></figure></li>
<li>文件特殊权限：SUID，SGID，SBIT</li>
<li>观察文件类型：fie</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure>
<h3 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h3><ul>
<li>which（寻找【指令文件】）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which [-a] command</span><br></pre></td></tr></table></figure></li>
<li>whereis(在特定目录搜寻系统文件，不实用)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis [-bmsu] file&#x2F;dir</span><br></pre></td></tr></table></figure></li>
<li>locate/updatedb（依靠db快速查询）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate [-ir] keyword</span><br><span class="line">updatedb    #locate是靠db快速查询，所以查询较新文件时需要手动updatedb</span><br></pre></td></tr></table></figure>
find(强大，但比较吃硬盘，影响速度)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">1.time(-atime,-ctime,-mtime)</span><br><span class="line">    -mtime n : n天前（一天内）被改动过的文件</span><br><span class="line">    -mtime +n : n天前（不含n本身）被改动过的文件</span><br><span class="line">    -mtime -n : n天内（含n本身）被改动过的文件</span><br><span class="line">2.属组相关参数</span><br><span class="line">    -uid n</span><br><span class="line">    -gid n</span><br><span class="line">    -user name</span><br><span class="line">    -group name</span><br><span class="line">    -nouser</span><br><span class="line">    -nogroup</span><br><span class="line">3.权限及名称</span><br><span class="line">    -name filename</span><br><span class="line">    -size [+-]SIZE:c代表byte，k代表kb</span><br><span class="line">    -type TYPE ： [f,b,c,d,l,s,p]</span><br><span class="line">    -perm mode</span><br><span class="line">    -perm -mode</span><br><span class="line">    -perm &#x2F;mode</span><br><span class="line">4.额外参数</span><br><span class="line">    -exec command : command见下图</span><br><span class="line">    -print</span><br><span class="line">    -a : and的意思，用于连接两个条件，如find &#x2F;etc -size +50k -a -size -60k</span><br><span class="line">    ! : 取反的意思，如find &#x2F;etc -size +50k -a ! -user root</span><br></pre></td></tr></table></figure>
<img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/85FEA75CCD8E4D0CAA94260B98089A1E/431" alt="image"></li>
</ul>
<h2 id="第七章、Linux-磁盘与文件系统管理"><a href="#第七章、Linux-磁盘与文件系统管理" class="headerlink" title="第七章、Linux 磁盘与文件系统管理"></a>第七章、Linux 磁盘与文件系统管理</h2><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>操作系统的文件数据除了文件实际内容外，还有非常多的属性（权限，属组，时间参数）。文件系统会将这两部分数据存放在不同的区块，权限与属性放到inode中，实际数据放到data block中。另外，还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括inode和block总量、使用量、剩余量等。</p>
<ul>
<li>superblock：记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在block号码；</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block；</li>
</ul>
<p>每个inode与block都有编号，每个文件都会占用一个inode，inode内则有文件数据放置的block号码。这种数据存取方法我们称为索引式文件系统（indexed allocation）（下图）。<br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/EE38F1F9F8A54CB185593EC9E07B2AAA/489" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/561C779757124369BE8A8F997D760FBE/501" alt="image"><br>上图为闪存用的FAT格式，没有inode存在，所以FAT没有办法将这个文件的所有block再一开始就读取出来。每个block号码都记录再前一个block当中。如果同一个文件数据写入的block分散的太过厉害，无法在磁盘转一圈就读到所有数据，就需要多转好几圈。<br>碎片整理的原因就是文件写入的block过于分散，读取文件的效率会变得很差，这时候可以透过 碎片整理将同一个文件的blcok汇整到一起，这样读取会比较容易。Ext2是索引式文件系统，不需要整理。</p>
<h3 id="Linux的EXT2文件系统（inode）"><a href="#Linux的EXT2文件系统（inode）" class="headerlink" title="Linux的EXT2文件系统（inode）"></a>Linux的EXT2文件系统（inode）</h3><p>文件系统一开始就将inode与block规划好了，除非重新格式化（或者利用resize2fs等指令变更文件系统大小），否则inode与block固定后就不再变动。</p>
<h3 id="7-2-文件系统的简单操作"><a href="#7-2-文件系统的简单操作" class="headerlink" title="7.2 文件系统的简单操作"></a>7.2 文件系统的简单操作</h3><h4 id="7-2-1-磁盘与目录的容量"><a href="#7-2-1-磁盘与目录的容量" class="headerlink" title="7.2.1 磁盘与目录的容量"></a>7.2.1 磁盘与目录的容量</h4><p>df:列出文件系统的整体磁盘使用量；</p>
]]></content>
      <categories>
        <category>《Linux私房菜》笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言编程心得</title>
    <url>/2018/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p>
</li>
<li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p>
</li>
<li><p>声明变量后一定要记得赋初识值，尤其是数组</p>
</li>
<li><p>变量就近声明</p>
</li>
<li><p>文件内使用的函数要习惯声明static</p>
</li>
<li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>first post</title>
    <url>/2017/02/23/first-post/</url>
    <content><![CDATA[<p>I love you, Joyce!</p>
]]></content>
  </entry>
</search>
