<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么calloc会比malloc+memset快</title>
    <url>/2020/02/23/%E4%B8%BA%E4%BB%80%E4%B9%88calloc%E4%BC%9A%E6%AF%94malloc-memset%E5%BF%AB/</url>
    <content><![CDATA[<ol>
<li><code>malloc</code>和<code>calloc</code>分配小的内存时直接从内存池分配，内存池不够时向内核申请更多内存；分配大内存时会直接调用<code>mmap</code>或<code>sbrk</code>系统调用</li>
<li>内核分配的内存可能是前一个进程用过的，为保证不泄漏敏感数据，内核始终在将内存交给进程前先将内存置0，因此<code>mmap()</code>保证返回的新内存始终为零</li>
<li>当程序申请内存时，内核并不会马上修改页表为进程提供RAM，而是在进程中找到一些地址空间，记下应该去的地方，并保证如果您的程序实际使用RAM，它将在其中放置RAM。当程序尝试读写那些地址，会出发缺页故障，内核将RAM分配给这些地址，继续执行程序。如果不读写，内核就不会分配RAM给进程。</li>
<li>有的进程分配内存后只读不写，这意味着跨不同进程的内存中的许多页面可能填充有从<code>mmap()</code>返回的原始零。由于这些页面都是相同的，因此内核使所有这些虚拟地址指向一个共享的4 KiB内存页面，其中填充了零。如果您尝试写入该内存，则处理器会触发另一个页面错误（写时复制），内核会介入，从而为您提供一个零的新页面，该页面不会与任何其他程序共享。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>C语言编程心得</title>
    <url>/2020/02/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li><p>字符’0’ 不等于0， 截断字符串时，a[n] = 0 与 a[n] = ‘\0’效果相同;</p>
</li>
<li><p>函数里直接声明结构体比声明结构体指针方便，因为指针要手动为它分配空间，不用后还需要手动释放；结构体自动分配，函数返回后自动释放</p>
</li>
<li><p>声明变量后一定要记得赋初识值，尤其是数组</p>
</li>
<li><p>变量就近声明</p>
</li>
<li><p>文件内使用的函数要习惯声明static</p>
</li>
<li><p>char *a = “ac”; 指针声明的字符串存在可执行文件的只读段，修改会产生段错误。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>第七章——进程环境</title>
    <url>/2020/02/23/%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="进程开始"><a href="#进程开始" class="headerlink" title="进程开始"></a>进程开始</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br></pre></td></tr></table></figure>
<p>   以main函数开始执行。当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序将此启动例程指定为程序的起始地址——这是由链接编辑器设置的，而链接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用做好安排。</p>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>   有8种终止方式，前5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从启动例程返回</li>
<li>从最后一个线程调用pthread_exit<br>异常终止有3种：</li>
<li>调用abort</li>
<li>遇到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="终止处理程序"><a href="#终止处理程序" class="headerlink" title="终止处理程序"></a>终止处理程序</h3><ul>
<li>一个进程可以通过<code>atexit</code>函数登记至多32个函数作为终止处理程序（exit handler），这些函数将在程序终止时有<code>exit</code>自动调用。<br> 调用顺序与登记顺序相反，登记多次也会调用多次。<br> 如若程序调用<code>exec</code>函数族中任一函数，则将清除所有已安装的终止处理程序。</li>
</ul>
<h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a><code>exit</code>函数</h3><ul>
<li><code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>首先调用各终止处理程序，然后通过<code>fclose</code>关闭所有打开流，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</li>
<li>内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显示或隐式地（通过调用<code>exit</code>）调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。<br> <img src="7-2.png" alt=""></li>
</ul>
<h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><ul>
<li>通常用<code>getenv</code>和<code>putenv</code>访问特定的环境变量<br> <img src="7-5.png" alt=""></li>
</ul>
<h3 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h3><ul>
<li>正文段。由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使频繁执行的程序在存储器中也只需要由一个副本。正文段通常是只读的，以防止程序由于意外而修改其指令。</li>
<li>初始化数据段，通常称为数据段。包含了明确赋初值的变量。例如C程序中任何函数之外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxcount = <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li>未初始化数据段，也称为bss（block started by symbol）段。程序开始执行前，内核将此段数据初始化为0或空指针。例如函数外的声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常用于进行动态存储分配。</li>
<li>未初始化数据段的内容并不存储在磁盘文件中，内核在程序运行前将它们设置为0.存放在磁盘文件中的段只有正文段和初始化数据段。<br> <img src="7-6.png" alt=""></li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul>
<li>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</li>
<li>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。</li>
<li>这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时或每个共享库函数第一次被调用时。</li>
<li>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑。</li>
</ul>
<h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><ul>
<li><code>malloc</code>分配指定字节数的存储区。其中的初始值不确定。</li>
<li><code>calloc</code>分配的每一位都初始化为0。</li>
<li><code>realloc</code>增加或减少分配区长度。新增区域内初始值不确定</li>
<li>这些分配例程通常通过<code>sbrk</code>系统调用实现</li>
<li><a href="为什么calloc会比malloc-memset快.md">为什么calloc会比malloc-memset快</a></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>APUE</tag>
        <tag>进程</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>first post</title>
    <url>/2020/02/23/first-post/</url>
    <content><![CDATA[<p>I love you, Joyce!</p>
]]></content>
  </entry>
</search>
