<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="生活,旅行,思考,代码,博客" />
   
  <meta name="description" content="一座孤岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     akaQin&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="akaQin's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/akaQin"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">akaQin&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-异步网络模型" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/24/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"
    >异步网络模型</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/24/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2018-09-24T07:33:38.000Z" itemprop="datePublished">2018-09-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="异步网络模型"><a href="#异步网络模型" class="headerlink" title="异步网络模型"></a>异步网络模型</h1><p>异步网络模型在服务开发中应用非常广泛，相关资料和开源库也非常多。项目中，使用现成的轮子提高了开发效率，除了能使用轮子，还是有必要了解一下轮子的内部构造。</p>
<p>这篇文章从最基础的5种I/O模型切入，到I/O事件处理模型，再到并发模式，最后以Swoole开源库来做具体分析，逐步深入。文中提到的模型都是一些通用的模型，在《linux高性能服务器编程》中也都有涉及。文章不涉及模型的实现细节，最重要的是去理解各个模型的工作模式以及其优缺点。</p>
<p>读后感：</p>
<p>所谓异步：</p>
<p>1.(fd)阻塞调用 + select/pool, epool  （IO事件通知方式：IO复用）</p>
<p>2.(fd)非阻塞调用 + SIGIO （IO事件通知方式：SIGIO 信号）</p>
<p>文中涉及接口调用的部分，都是指Linux系统的接口调用。共分为5部分：</p>
<p>I/O模型</p>
<p>从基础的系统调用方法出发，给大家从头回顾一下最基本的I/O模型，虽然简单，但是不可或缺的基础；</p>
<p>事件处理模型</p>
<p>这部分在同步I/O、异步I/O的基础上分别介绍Reactor模型以及Proactor模型，着重两种模型的构成以及事件处理流程。Reactor模型是我们常见的；不同平台对异步I/O系统接口的支持力度不同，这部分还介绍了一种使用同步I/O来模拟Proactor模型的方法。</p>
<p>并发模式</p>
<p>就是多线程、多进程的编程的模式。介绍了两种较为高效的并发模型，半同步／半异步(包括其演变模式)、Follower／Leader模式。</p>
<p>Swoole异步网络模型分析</p>
<p>这部分是结合已介绍的事件处理模型、并发模式对Swoole的异步模型进行分析；从分析的过程来看，看似复杂的网络模型，可以拆分为简单的模型单元，只不过我们需要权衡利弊，选取合适业务需求的模型单元进行组合。我们团队基于Swoole 1.8.5版本，做了很多修改，部分模块做了重构，计划在17年6月底将修改后版本开源出去，敬请期待。</p>
<p>改善性能的方法</p>
<p>最后一部分是在引入话题，介绍的是几种常用的方法。性能优化是没有终点的，希望大家能贡献一些想法和具体方法。</p>
<p>I/O模型</p>
<p>POSIX 规范中定义了同步I/O 和异步I/O的术语，</p>
<p>同步I/O : 需要进程去真正的去操作I/O；</p>
<p>异步I/O：内核在I/O操作完成后再通知应用进程操作结果。</p>
<p>在《UNIX网络编程》中介绍了5中I/O模型：阻塞I/O、非阻塞I/O、I/O复用、SIGIO 、异步I/O；本节对这5种I/O模型进行说明和对比。</p>
<p>I/O阻塞</p>
<p>通常把阻塞的文件描述符（file descriptor，fd）称之为阻塞I/O。默认条件下，创建的socket fd是阻塞的，针对阻塞I/O调用系统接口，可能因为等待的事件没有到达而被系统挂起，直到等待的事件触发调用接口才返回，例如，tcp socket的connect调用会阻塞至第三次握手成功（不考虑socket 出错或系统中断），如图1所示。另外socket 的系统API ，如，accept、send、recv等都可能被阻塞。</p>
<p><img src="https:////note.youdao.com/src/B7FFBB5BC3684E41BFFE7BB61A1BF09E" alt="img"></p>
<p>​                      图1I/O 阻塞模型示意图</p>
<p>1</p>
<p>另外补充一点，网络编程中，通常把可能永远阻塞的系统API调用 称为慢系统调用，典型的如 accept、recv、select等。慢系统调用在阻塞期间可能被信号中断而返回错误，相应的errno 被设置为EINTR，我们需要处理这种错误，解决办法有：</p>
<p>\1. 重启系统调用</p>
<p>直接上示例代码吧，以accept为例，被中断后重启accept 。有个例外，若connect 系统调用在阻塞时被中断，是不能直接重启的（与内核socket 的状态有关)，有兴趣的同学可以深入研究一下connect 的内核实现。使用I/O复用等待连接完成，能避免connect不能重启的问题。</p>
<p>int client_fd = -1;  structsockaddr_inclient_addr;socklen_t child_addrlen;  while (1) {  call_accept:      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {       if (EINTR == errno) {          goto call_accept;       } else {          sw_sysError(“accept fail”);          break;       }    }}</p>
<p>123456789101112131415</p>
<p>\2. 信号处理</p>
<p>利用信号处理，可以选择忽略信号，或者在安装信号时设置SA_RESTART属性。设置属性SA_RESTART，信号处理函数返回后，被安装信号中断的系统调用将自动恢复，示例代码如下。需要知道的是，设置SA_RESTART属性方法并不完全适用，对某些系统调用可能无效，这里只是提供一种解决问题的思路，示例代码如下：</p>
<p>int client_fd = -1;  structsigactionaction,old_action;action.sa_handler = sig_handler;  sigemptyset(&amp;action.sa_mask);  action.sa_flags = 0;  action.sa_flags |= SA_RESTART;/// 若信号已经被忽略，则不设置sigaction(SIGALRM, NULL, &amp;old_action)；  if (old_action.sa_handler != SIG_IGN) {      sigaction(SIGALRM, &amp;action, NULL)；}while (1) {      client_fd = accept(server_fd,NULL,NULL)；    if (client_fd &lt; 0) {        sw_sysError(“accept fail”);        break;    }}</p>
<p>123456789101112131415161718192021</p>
<p>I/O非阻塞</p>
<p>把非阻塞的文件描述符称为非阻塞I/O。可以通过设置SOCK_NONBLOCK标记创建非阻塞的socket fd，或者使用fcntl将fd设置为非阻塞。</p>
<p>对非阻塞fd调用系统接口时，不需要等待事件发生而立即返回，事件没有发生，接口返回-1，此时需要通过errno的值来区分是否出错，有过网络编程的经验的应该都了解这点。不同的接口，立即返回时的errno值不尽相同，如，recv、send、accept errno通常被设置为EAGIN 或者EWOULDBLOCK，connect 则为EINPRO-GRESS 。</p>
<p>以recv操作非阻塞套接字为例，如图2所示。</p>
<p><img src="https:////note.youdao.com/src/0DF7FBEB18524D968DA0D4DC4F7ED257" alt="img"></p>
<p>​                     图2 非阻塞I/O模型示意图</p>
<p>1</p>
<p>当我们需要读取，在有数据可读的事件触发时，再调用recv，避免应用层不断去轮询检查是否可读，提高程序的处理效率。通常非阻塞I/O与I/O事件处理机制结合使用。</p>
<p>I/O复用</p>
<p>最常用的I/O事件通知机制就是I/O复用(I/O multiplexing)。Linux 环境中使用select/poll/epoll 实现I/O复用，I/O复用接口本身是阻塞的，在应用程序中通过I/O复用接口向内核注册fd所关注的事件，当关注事件触发时，通过I/O复用接口的返回值通知到应用程序，如图3所示,以recv为例。I/O复用接口可以同时监听多个I/O事件以提高事件处理效率。</p>
<p><img src="https:////note.youdao.com/src/2FE99F76417C4837A098D4D8DA4EDFCF" alt="img"></p>
<p>​                    图 3I/O复用模型示意图</p>
<p>1</p>
<p>关于select/poll/epoll的对比，可以参考[]，epoll使用比较多，但是在并发的模式下，需要关注惊群的影响。</p>
<p>SIGIO</p>
<p>除了I/O复用方式通知I/O事件，还可以通过SIGIO信号来通知I/O事件，如图4所示。两者不同的是，在等待数据达到期间，I/O复用是会阻塞应用程序，而SIGIO方式是不会阻塞应用程序的。</p>
<p><img src="https:////note.youdao.com/src/4EC5DCA3909E4C52910ABD33BC7FD478" alt="img"></p>
<p>​                     图 4 信号驱动I/O模型示意图</p>
<p>1</p>
<p>异步I/O</p>
<p>POSIX规范定义了一组异步操作I/O的接口，不用关心fd 是阻塞还是非阻塞，异步I/O是由内核接管应用层对fd的I/O操作。异步I/O向应用层通知I/O操作完成的事件，这与前面介绍的I/O 复用模型、SIGIO模型通知事件就绪的方式明显不同。以aio_read 实现异步读取IO数据为例，如图5所示，在等待I/O操作完成期间，不会阻塞应用程序。</p>
<p><img src="https:////note.youdao.com/src/DDC1E38AE6ED40E6B1302E75DFD4F7F8" alt="img"></p>
<p>​                      图 5 异步I/O 模型示意图</p>
<p>1</p>
<p>I/O模型对比</p>
<p>前面介绍的5中I/O中，I/O 阻塞、I/O非阻塞、I/O复用、SIGIO 都会在不同程度上阻塞应用程序，而只有异步I/O模型在整个操作期间都不会阻塞应用程序。</p>
<p>如图6所示，列出了5种I/O模型的比较</p>
<p><img src="https:////note.youdao.com/src/3F0992AC6EC74A9880DC225FF3F8EE05" alt="img"></p>
<p>​                   图6 五种I/O 模型比较示意图</p>
<p>1</p>
<p>事件处理模型</p>
<p>网络设计模式中，如何处理各种I/O事件是其非常重要的一部分，Reactor 和Proactor两种事件处理模型应运而生。上章节提到将I/O分为同步I/O 和 异步I/O，可以使用同步I/O实现Reactor模型，使用异步I/O实现Proactor模型。</p>
<p>本章节将介绍Reactor和Proactor两种模型，最后将介绍一种使用同步I/O模拟Proactor事件处理模型。</p>
<p>Reactor事件处理模型</p>
<p>Reactor模型是同步I/O事件处理的一种常见模型，关于Reactor模型结构的资料非常多，一个典型的Reactor模型类图结构如图7所示，</p>
<p><img src="https:////note.youdao.com/src/CBD29D74325044DAB307FFCFE83D46E2" alt="img"></p>
<p>​                   图 7 Reactor 模型类结构图</p>
<p>1</p>
<p>Reactor的核心思想：将关注的I/O事件注册到多路复用器上，一旦有I/O事件触发，将事件分发到事件处理器中，执行就绪I/O事件对应的处理函数中。模型中有三个重要的组件：</p>
<ul>
<li>多路复用器：由操作系统提供接口，Linux提供的I/O复用接口有select、poll、epoll；</li>
<li>事件分离器：将多路复用器返回的就绪事件分发到事件处理器中；</li>
<li>事件处理器：处理就绪事件处理函数。</li>
</ul>
<p>图7所示，Reactor 类结构中包含有如下角色。</p>
<ul>
<li>Handle：标示文件描述符；</li>
<li>Event Demultiplexer：执行多路事件分解操作，对操作系统内核实现I/O复用接口的封装；用于阻塞等待发生在句柄集合上的一个或多个事件（如select/poll/epoll）；</li>
<li>Event Handler：事件处理接口；</li>
<li>Event Handler A(B)：实现应用程序所提供的特定事件处理逻辑；</li>
<li>Reactor：反应器，定义一个接口，实现以下功能：</li>
</ul>
<p>​      a)供应用程序注册和删除关注的事件句柄；      b)运行事件处理循环；      c)等待的就绪事件触发，分发事件到之前注册的回调函数上处理.</p>
<p>123</p>
<p>接下来介绍Reactor的工作流程，如图8所示，为Reactor模型工作的简化流程。</p>
<p><img src="https:////note.youdao.com/src/FA1A0970047647E9BE2DC7AB66721B97" alt="img"></p>
<p>​                  图8 Reactor模型简化流程示意图</p>
<p>1</p>
<ol>
<li>注册I/O就绪事件处理器；</li>
<li>事件分离器等待I/O就绪事件；</li>
<li>I/O事件触发，激活事件分离器，分离器调度对应的事件处理器；</li>
<li>事件处理器完成I/O操作，处理数据.</li>
</ol>
<p>网络设计中，Reactor使用非常广，在开源社区有很许多非常成熟的、跨平台的、Reactor模型的网络库，比较典型如libevent。</p>
<p>Proactor事件处理模型</p>
<p>与Reactor不同的是，Proactor使用异步I/O系统接口将I/O操作托管给操作系统，Proactor模型中分发处理异步I/O完成事件，并调用相应的事件处理接口来处理业务逻辑。Proactor类结构如图9所示。</p>
<p><img src="https:////note.youdao.com/src/541F3DEA29674188AD21BB9C12AB2508" alt="img"></p>
<p>​                    图9 Proactor模型类结构图</p>
<p>1</p>
<p>图9所示，Proactor类结构中包含有如下角色：</p>
<ul>
<li>Handle： 用来标识socket连接或是打开文件；</li>
<li>Async Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li>
<li>Async Operation：异步操作；</li>
<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用；</li>
<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li>
<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li>
<li>Completion Handler A(B)：完成事件处理逻辑；实现接口定义特定的应用处理逻辑。</li>
</ul>
<p>Proactor模型的简化的工作流程,如图10所示。</p>
<p><img src="https:////note.youdao.com/src/72BA30C44C334ED28602FDA853052912" alt="img"></p>
<p>​                 图10 Proactor模型简化工作流程示意图</p>
<p>1</p>
<ol>
<li>发起I/O异步操作，注册I/O完成事件处理器;</li>
<li>事件分离器等待I/O操作完成事件；</li>
<li>内核并行执行实际的I/O操作，并将结果数据存入用户自定义缓 冲区；</li>
<li>内核完成I/O操作，通知事件分离器，事件分离器调度对应的事件处理器；</li>
<li>事件处理器处理用户自定义缓冲区中的数据。</li>
</ol>
<p>Proactor利用异步I/O并行能力，可给应用程序带来更高的效率，但是同时也增加了编程的复杂度。windows对异步I/O提供了非常好的支持，常用Proactor的模型实现服务器；而Linux对异步I/O操作(aio接口)的支持并不是特别理想，而且不能直接处理accept，因此Linux平台上还是以Reactor模型为主。</p>
<p>Boost asio采用的是Proactor模型，但是Linux上，采用I/O复用的方式来模拟Proactor，另启用线程来完成读写操作和调度。</p>
<p>同步I/O模拟Proactor</p>
<p>下面一种使用同步I/O模拟Proactor的方案，原理是：</p>
<p>主线程执行数据读写操作，读写操作完成后，主线程向工作线程通知I/O操作“完成事件”；</p>
<p>工作流程如图 11所示。</p>
<p><img src="https:////note.youdao.com/src/4A797D1DFA4345A6B8CA651380814811" alt="img"></p>
<p>​                  图11 同步I/O模拟Proactor模型</p>
<p>1</p>
<p>简单的描述一下图11 的执行流程：</p>
<ol>
<li>主线程往系统I/O复用中注册文件描述符fd上的读就绪事件；</li>
<li>主线程调用调用系统I/O复用接口等待文件描述符fd上有数据可读；</li>
<li>当fd上有数据可读时，通知主线程。主线程循环读取fd上的数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后向I/O复用中注册fd上的写就绪事件。主线程进入事件等待循环，等待fd可写。</li>
</ol>
<p>并发模式</p>
<p>在I/O密集型的程序，采用并发方式可以提高CPU的使用率，可采用多进程和多线程两种方式实现并发。当前有高效的两种并发模式，半同步/半异步模式、Follower/Leader模式。</p>
<p>半同步/半异步模式</p>
<p>首先区分一个概念，并发模式中的“同步”、“异步”与 I/O模型中的“同步”、“异步”是两个不同的概念：</p>
<p>并发模式中，“同步”指程序按照代码顺序执行，“异步”指程序依赖事件驱动，如图12 所示并发模式的“同步”执行和“异步”执行的读操作；</p>
<p>I/O模型中，“同步”、“异步”用来区分I/O操作的方式，是主动通过I/O操作拿到结果，还是由内核异步的返回操作结果。</p>
<p><img src="https:////note.youdao.com/src/C0FEC4831C074C0CB23329F010B270AD" alt="img"></p>
<p>​                     图12(a)  同步读操作示意图</p>
<p>1</p>
<p><img src="https:////note.youdao.com/src/4CAE98C8589D434B95B3DFA4B94D1028" alt="img"></p>
<p>​                     图12(b) 异步读操作示意图</p>
<p>1</p>
<p>本节从最简单的半同步/半异步模式的工作流程出发，并结合事件处理模型介绍两种演变的模式。</p>
<p>半同步/半异步工作流程</p>
<p>半同步/半异步模式的工作流程如图13 所示。</p>
<p><img src="https:////note.youdao.com/src/C8F33A95D4AA432A94A9D57854FE5977" alt="img"></p>
<p>​              图13 半同步/半异步模式的工作流程示意图</p>
<p>1</p>
<p>其中异步线程处理I/O事件，同步线程处理请求对象，简单的来说：</p>
<ol>
<li>异步线程监听到事件后，将其封装为请求对象插入到请求队列中；</li>
<li>请求队列有新的请求对象，通知同步线程获取请求对象；</li>
<li>同步线程处理请求对象，实现业务逻辑。</li>
</ol>
<p>半同步/半反应堆模式</p>
<p>考虑将两种事件处理模型，即Reactor和Proactor，与几种I/O模型结合在一起，那么半同步/半异步模式就演变为半同步／半反应堆模式。先看看使用Reactor的方式，如图14 所示。</p>
<p><img src="https:////note.youdao.com/src/249D671B15CD43F8AC5733EB176EF31A" alt="img"></p>
<p>​                    图14 半同步／半反应堆模式示意图</p>
<p>1</p>
<p>其工作流程为：</p>
<ol>
<li>异步线程监听所有fd上的I/O事件，若监听socket接可读，接受新的连接；并监听该连接上的读写事件；</li>
<li>若连接socket上有读写事件发生，异步线程将该连接socket插入请求队列中；</li>
<li>同步线程被唤醒，并接管连接socket，从socket上读取请求和发送应答；</li>
</ol>
<p>若将Reactor替换为Proactor，那么其工作流程为：</p>
<ol>
<li>异步线程完成I/O操作，并I/O操作的结果封装为任务对象，插入请求队列中；</li>
<li>请求队列通知同步线程处理任务；</li>
<li>同步线程执行任务处理逻辑。</li>
</ol>
<p>一种高效的演变模式</p>
<p>半同步／半反应堆模式有明显的缺点：</p>
<ol>
<li>异步线程和同步线程共享队列，需要保护，存在资源竞争；</li>
<li>工作线程同一时间只能处理一个任务，任务处理量很大或者任务处理存在一定的阻塞时，任务队列将会堆积，任务的时效性也等不到保证；不能简单地考虑增加工作线程来处理该问题，线程数达到一定的程度，工作线程的切换也将白白消耗大量的CPU资源。</li>
</ol>
<p>下面介绍一种改进的方式，如图15 所示，每个工作线程都有自己的事件循环，能同时独立处理多个用户连接。</p>
<p><img src="https:////note.youdao.com/src/B73C3DDD172F400C9A270FAD1E69048F" alt="img"></p>
<p>​                图 15 半同步／半反应堆模式的演变模式</p>
<p>1</p>
<p>其工作流程为：</p>
<ol>
<li>主线程实现连接监听，只处理网络I/O连接事件；</li>
<li>新的连接socket分发至工作线程中，这个socket上的I/O事件都由该工作线程处理，工作线程都可以处理多个socket 的I/O事件；</li>
<li>工作线程独立维护自己的事件循环，监听不同连接socket的I/O事件。</li>
</ol>
<p>Follower/Leader 模式</p>
<p>Follower/Leader是多个工作线程轮流进行事件监听、事件分发、处理事件的模式。</p>
<p>在Follower/Leader模式工作的任何一个时间点，只有一个工作线程处理成为Leader ，负责I/O事件监听，而其他线程都是Follower，并等待成为Leader。</p>
<p>Follower/Leader模式的工作流概述如下：</p>
<ol>
<li>当前Leader Thread1监听到就绪事件后，从Follower 线程集中推选出 Thread 2成为新的Leader；</li>
<li>新的Leader Thread2 继续事件I/O监听；</li>
<li>Thread1继续处理I/O就绪事件，执行完后加入到Follower 线程集中，等待成为Leader。</li>
</ol>
<p>从上描述，Leader/Follower模式的工作线程存在三种状态，工作线程同一时间只能处于一种状态，这三种状态为：</p>
<ul>
<li>Leader：线程处于领导者状态，负责监听I/O事件；</li>
<li>Processing：线程处理就绪I/O事件；</li>
<li>Follower：等待成为新的领导者或者可能被当前Leader指定处理就绪事件。</li>
</ul>
<p>Leader监听到I/O就绪事件后，有两种处理方式:</p>
<ol>
<li>推选出新的Leader后，并转移到Processing处理该I/O就绪事件；</li>
<li>指定其他Follower 线程处理该I/O就绪事件，此时保持Leader状态不变；</li>
</ol>
<p>如图16所示为上面描述的三种状态的转移关系。</p>
<p><img src="https:////note.youdao.com/src/0300C58B6573442BA8167AC358109B97" alt="img"></p>
<p>​              图16 Follower/Leader模式状态转移示意图</p>
<p>1</p>
<p>如图16所示，处于Processing状态的线程处理完I/O事件后，若当前不存在Leader，就自动提升为Leader，否则转变Follower。</p>
<p>从以上描述中可知，Follower/Leader模式中不需要在线程间传递数据，线程间也不存在共享资源。但很明显Follower/Leader 仅支持一个事件处理源集，无法做到图15所示的每个工作线程独立监听I/O事件。</p>
<p>Swoole 网络模型分析</p>
<p>Swoole为PHP提供I/O扩展功能，支持异步I/O、同步I/O、并发通信，并且为PHP多进程模式提供了并发数据结构和IPC通信机制；Swoole 既可以充当网络I/O服务器，也支持I/O客户端，较大程度为用户简化了网络I/O、多进程／多线程并发编程的工作。</p>
<p>Swoole作为server时，支持3种运行模式，分别是多进程模式、多线程模式、多进程＋多线程模式；多进程＋多线程模式是其中最为复杂的方式，其他两种方式可以认为是其特例。</p>
<p>本节结合之前介绍几种事件处理模型、并发模式来分析Swoole server的多进程＋多线程模型，如图17。</p>
<p><img src="https:////note.youdao.com/src/89BFEDF8F539474881899FE905512DE7" alt="img"></p>
<p>​             图17 swoole server多进程＋多线程模型结构示意图</p>
<p>1</p>
<p>图17所示，整体上可以分为Master Process、Manger Process、Work Process Pool三部分。这三部分的主要功能：</p>
<ol>
<li>Master Process：监听服务端口，接收用户连接，收发连接数据，依靠reactor模型驱动；</li>
<li>Manager Process：Master Process的子进程，负责fork WorkProcess，并监控Work Process的运行状态；</li>
<li>Work Process Pool：工作进程池，与PHP业务层交互，将客户端数据或者事件（如连接关闭）回调给业务层，并将业务层的响应数据或者操作（如主动关闭连接）交给Master Process处理；工作进程依靠reactor模型驱动。</li>
</ol>
<p>Manager Process 监控Work Process进程，本节不做进一步讲解，主要关注Master和Work。</p>
<p>Master Process</p>
<p>Master Process 内部包括主线程(Main Thread)和工作线程池(Work Thread Pool),这两部分主要功能分别是：</p>
<p>主线程: 监听服务端口，接收网络连接，将成功建立的连接分发到线程池中；依赖reactor模型驱动；</p>
<p>工作线程池: 独立管理连接，收发网络数据；依赖Reactor事件处理驱动。</p>
<p>顾一下前面介绍的半同步/半异步并发模式，很明显，主进程的工作方式就是图15所示的方式。</p>
<p>Work Process</p>
<p>如上所描述，Work Process是Master Process和PHP层之间的媒介：</p>
<ol>
<li>Work Process接收来自Master Process的数据，包括网络数据和连接事件，回调至PHP业务层；</li>
<li>将来自PHP层的数据和连接控制信息发送给Master Process进程，Master Process来处理。</li>
</ol>
<p>Work Process同样是依赖Reactor事件模型驱动，其工作方式一个典型的Reactor模式。</p>
<p>Work Process作为Master Process和PHP层之间的媒介，将数据收发操作和数据处理分离开来，即使PHP层因消息处理将Work进程阻塞一段时间，也不会对其他连接有影响。</p>
<p>从整体层面来看，Master Process实现对连接socket上数据的I/O操作，这个过程对于Work Process是异步的，结合图11 所描述的同步I/O模拟Proactor模式，两种方式如出一辙，只不过这里使用的是多进程。</p>
<p>进程间通信</p>
<p>Work Process是Master Process和PHP层之间的媒介，那么需要看看Work Process 与Master Process之间的通信方式，并在Swoole server 的多进程＋多线程模型进程中，整个过程还是有些复杂，下面说明一下该流程，如图18所示。</p>
<p><img src="https:////note.youdao.com/src/76B546B115CB4361B342121A82049291" alt="img"></p>
<p>​                图18 swoole server 多进程多线程通信示意图</p>
<p>1</p>
<p>具体流程为：</p>
<ol>
<li>Master 进程主线程接收客户端连接，连接建立成功后，分发至工作线程，工作线程通过Unix Socket通知Work进程连接信息；</li>
<li>Work 进程将连接信息回调至PHP业务层；</li>
<li>Maser 进程中的工作线程接收客户端请求消息，并通过Unix Socket方式发送到Work进程；</li>
<li>Work 进程将请求消息回调至PHP业务层；</li>
<li>PHP业务层构造回复消息，通过Work进程发送，Work进程将回复消息拷贝至共享内存中，并通过Unix Socket通知发送至Master进程的工作线程有数据需要发送；</li>
<li>工作线程从共享内存中取出需发送的数据，并发送至客户端；</li>
<li>客户端断开连接，工作线程将连接断开的事件通过UnixSocket发送至Work进程；</li>
<li>Work进程将连接断开事件回调至PHP业务层.</li>
</ol>
<p>需要注意在步骤5中，Work进程通知Master进程有数据需要发送，不是将数据直接发送给Master进程，而是将数据地址(在共享内存中)发送给Master进程。</p>
<p>改善性能的方法</p>
<p>性能对于服务器而言是非常敏感和重要的，当前，硬件的发展虽然不是服务器性能的瓶颈，作为软件开发人员还是应该考虑在软件层面来上改善服务性能。好的网络模块，除了稳定性，还有非常多的细节、技巧处理来提升服务性能，感兴趣的同学可以深入了解Ngnix源码的细节，以及陈硕的《Linux多线程服务器编程》。</p>
<p>数据复制</p>
<p>如果应用程序不关心数据的内容，就没有必要将数据拷贝到应用缓冲区，可以借助内核接口直接将数据拷贝到内核缓冲区处理，如在提供文件下载服务时，不需要将文件内容先读到应用缓冲区，在调用send接口发送出去，可以直接使用sendfile （零拷贝）接口直接发送出去。</p>
<p>应用程序的工作模块之间也应该避免数据拷贝，如：</p>
<ol>
<li>当两个工作进程之间需要传递数据，可以考虑使用共享内存的方式实现数据共享；</li>
<li>在流媒体的应用中，对帧数据的非必要拷贝会对程序性能的影响，特备是在嵌入式环境中影响非常明显。通常采用的办法是，给每帧数据分配内存（下面统称为buffer），当需要使用该buffer时，会增加该buffer的引用计数，buffer的引用计数为0时才会释放对应的内存。这种方式适合在进程内数据无拷贝传递，并且不会给释放buffer带来困扰。</li>
</ol>
<p>资源池</p>
<p>在服务运行期间，需要使用系统调用为用户分配资源，通常系统资源的分配都是比较耗时的，如动态创建进程／线程。可以考虑在服务启动时预先分配资源，即创建资源池，当需要资源，从资源池中获取即可，若资源池不够用时，再动态的分配，使用完成后交还到资源池中。这实际上是用空间换取时间，在服务运行期间可以节省非必要的资源创建过程。需要注意的是，使用资源池还需要根据业务和硬件环境对资源池的大小进行限制。</p>
<p>资源池是一个抽象的概念，常见的包括进程池、线程池、 内存池、连接池；这些资源池的相关资料非常多，这里就不一一介绍了。</p>
<p>锁/上下文切换</p>
<p>1.关于锁</p>
<p>对共享资源的操作是并发程序中经常被提起的一个话题，都知道在业务逻辑上无法保证同步操作共享资源时，需要对共享资源加锁保护，但是锁不仅不能处理任何业务逻辑，而且还存在一定的系统开销。并且对锁的不恰当使用，可能成为服务期性能的瓶颈。</p>
<p>针对锁的使用有如下建议：</p>
<ol>
<li>如果能够在设计层面避免共享资源竞争，就可以避免锁，如图15描述的模式;</li>
<li>若无法避免对共享资源的竞争，优先考虑使用无锁队列的方式实现共享资源；</li>
<li>使用锁时，优先考虑使用读写锁；此外，锁的范围也要考虑，尽量较少锁的颗粒度，避免其他线程无谓的等待。</li>
</ol>
<p>2.上下文切换</p>
<p>并发程序需要考虑上下文切换的问题，内核调度线程(进程)执行是存在系统开销的，若线程(进程)调度占用CPU的时间比重过大，那处理业务逻辑占用的CPU时间就会不足。在项目中，线程(进程)数量越多，上下文切换会很频繁，因此是不建议为每个用户连接创建一个线程，如图15所示的并发模式，一个线程可同时处理多个用户连接，是比较合理的解决方案。</p>
<p>多核的机器上，并发程序的不同线程可以运行在不同的CPU上，只要线程数量不大于CPU数目，上下文切换不会有什么问题，在实际的并发网络模块中，线程(进程)的个数也是根据CPU数目来确定的。在多核机器上，可以设置CPU亲和性，将进程／线程与CPU绑定，提高CPU cache的命中率，建好内存访问损耗。</p>
<p>有限状态机器</p>
<p>有限状态机是一种高效的逻辑处理方式，在网络协议处理中应用非常广泛，最典型的是内核协议栈中TCP状态转移。有限状态机中每种类型对应执行逻辑单元的状态，对逻辑事务的处理非常有效。有限状态机包括两种，一种是每个状态都是相互独立的，状态间不存在转移；另一种就是状态间存在转移。有限状态机比较容易理解，下面给出两种有限状态机的示例代码。</p>
<p>不存在状态转移</p>
<p>typedefenum _tag_state_enum{      A_STATE,    B_STATE,    C_STATE,    D_STATE}state_enum;voidSTATE_MACHINE_HANDLER(state_enum cur_state){    switch (cur_state){    case A_STATE:         process_A_STATE();         break;    case B_STATE:         process_B_STATE();         break;    case C_STATE:         process_C_STATE();         break;    default:         break;    }    return ;}</p>
<p>1234567891011121314151617181920212223242526</p>
<p>存在状态转移</p>
<p>voidTRANS_STATE_MACHINE_HANDLER(state_enum cur_state){    while (C_STATE != cur_state) {        switch (cur_state) {        case A_STATE:            process_A_STATE();            cur_state = B_STATE;            break;        case B_STATE:            process_B_STATE();            cur_state = C_STATE;            break;        case C_STATE:            process_C_STATE();            cur_state = D_STATE;            break;        default:            return ;      }   }   return ;}</p>
<p>123456789101112131415161718192021222324252627</p>
<p>时间轮</p>
<p>经常会面临一些业务定时超时的需求，用例子来说明吧。</p>
<p>功能需求：服务器需要维护来自大量客户端的TCP连接（假设单机服务器需要支持的最大TCP连接数在10W级别），如果某连接上60s内没有数据到达，就认为相应的客户端下线。</p>
<p>先介绍一下两种容易想到的解决方案,</p>
<p>方案a轮询扫描</p>
<p>处理过程为：</p>
<ol>
<li>维护一个map 记录客户端最近一次的请求时间；</li>
<li>当client_id对应连接有数据到达时，更新last_update_time；</li>
<li>启动一个定时器，轮询扫描map 中client_id 对应的last_update_time，若超过 60s，则认为对应的客户端下线。</li>
</ol>
<p>轮询扫描，只启动一个定时器，但轮询效率低，特别是服务器维护的连接数很大时，部分连接超时事件得不到及时处理。</p>
<p>方案b多定时器触发</p>
<p>处理过程为：</p>
<ol>
<li>维护一个map 记录客户端最近一次的请求时间；</li>
<li>当某client_id 对应连接有数据到达时，更新last_update_time，同时为client_id启用一个定时器，60s后触发;</li>
<li>当client_id对应的定时器触发后，查看map中client_id对应的last_update_time是否超过60s，若超时则认为对应客户端下线。</li>
</ol>
<p>多定时器触发，每次请求都要启动一个定时器，可以想象，消息请求非常频繁是，定时器的数量将会很庞大，消耗大量的系统资源。</p>
<p>方案c 时间轮方案</p>
<p>下面介绍一下利用时间轮的方式实现的一种高效、能批量的处理方案，先说一下需要的数据结构：</p>
<ol>
<li>创建0~60的数据，构成环形队列time_wheel，current_index维护环形队列的当前游标，如图19所示；</li>
<li>数组元素是slot 结构，slot是一个set，构成任务集；</li>
<li>维护一个map，记录client_id 落在哪个slot上。</li>
</ol>
<p><img src="https:////note.youdao.com/src/C5981CB237A048868220D6C27354F990" alt="img"></p>
<p>​                     图19 时间轮环形队列示意图</p>
<p>1</p>
<p>执行过程为：</p>
<ol>
<li>启用一个定时器，运行间隔1s，更新current_index，指向环形队列下一个元素，0-&gt;1-&gt;2-&gt;3…-&gt;58-&gt;59-&gt;60…0；</li>
<li>连接上数据到达时，从map中获取client_id所在的slot，在slot的set中删除该client_id；</li>
<li>将client_id加入到current_index - 1锁标记的slot中；</li>
<li>更新map中client_id 为current_id-1 。</li>
</ol>
<p>与a、b两种方案相比，方案c具有如下优势：</p>
<ol>
<li>只需要一个定时器，运行间隔1s，CPU消耗非常少；</li>
<li>current_index 所标记的slot中的set不为空时，set中的所有client_id对应的客户端均认为下线，即批量超时。</li>
</ol>
<p>上面描述的时间轮处理方式会存在1s以内的误差，若考虑实时性，可以提高定时器的运行间隔，另外该方案可以根据实际业务需求扩展到应用中。我们对Swoole的修改中，包括对定时器进行了重构，其中超时定时器采用的就是如上所描述的时间轮方案，并且精度可控。</p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I-O/" rel="tag">I/O</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-Linux学习笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >Linux学习笔记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-09-24T03:14:08.000Z" itemprop="datePublished">2018-09-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="Linux中，Ctrl组合键"><a href="#Linux中，Ctrl组合键" class="headerlink" title="Linux中，Ctrl组合键"></a>Linux中，Ctrl组合键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+c 结束正在运行的程序</span><br><span class="line"></span><br><span class="line">Ctrl+d 结束输入或退出shell</span><br><span class="line"></span><br><span class="line">Ctrl+s 暂停屏幕输出【锁住终端】</span><br><span class="line"></span><br><span class="line">Ctrl+q 恢复屏幕输出【解锁终端】</span><br><span class="line"></span><br><span class="line">Ctrl+l 清屏，【是字母L的小写】等同于Clear</span><br><span class="line"></span><br><span class="line">Ctrl+a 切换到命令行开始</span><br><span class="line"></span><br><span class="line">trl+e 切换到命令行末尾</span><br><span class="line"></span><br><span class="line">Ctrl+u 清除剪切光标之前的内容</span><br><span class="line"></span><br><span class="line">Ctrl+k 清除剪切光标及光标之后的内容</span><br><span class="line"></span><br><span class="line">Ctrl+y 在光标处粘贴剪切的内容</span><br><span class="line"></span><br><span class="line">Ctrl+r 查找历史命令【输入关键字，就能调出以前执行过的命令】</span><br><span class="line"></span><br><span class="line">Ctrl+t 调换光标所在处与其之前字符位置，并把光标移到下个字符</span><br><span class="line"></span><br><span class="line">Ctrl+x+u 撤销操作</span><br></pre></td></tr></table></figure>
<h2 id="第四章、基础操作入门"><a href="#第四章、基础操作入门" class="headerlink" title="第四章、基础操作入门"></a>第四章、基础操作入门</h2><h3 id="关机或重启"><a href="#关机或重启" class="headerlink" title="关机或重启"></a>关机或重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据同步写入磁盘：</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line">关机：</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line">重启：</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日期和时间：date</span><br><span class="line">日历：cal</span><br><span class="line">计算器：bc</span><br></pre></td></tr></table></figure>

<h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Tab]:命令补全或文件补齐</span><br><span class="line">[Ctrl]-c:中断目前程序</span><br><span class="line">[Ctrl]-d:（键盘输入结束，End Of File，EOF 或 End Of Input），相当于输入exit</span><br><span class="line">[shift]+&#123;[PageUP]|[Page Down]&#125;:翻页</span><br></pre></td></tr></table></figure>

<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">man page</span><br><span class="line">info page</span><br></pre></td></tr></table></figure>

<h2 id="第五章、文件权限与目录配置"><a href="#第五章、文件权限与目录配置" class="headerlink" title="第五章、文件权限与目录配置"></a>第五章、文件权限与目录配置</h2><h3 id="修改文件或目录属组"><a href="#修改文件或目录属组" class="headerlink" title="修改文件或目录属组"></a>修改文件或目录属组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] group dirname&#x2F;filename   </span><br><span class="line">chown [-R] user dirname&#x2F;filename    </span><br><span class="line">chown [-R] user:group dirname&#x2F;filename</span><br></pre></td></tr></table></figure>

<h3 id="修改文件或目录权限"><a href="#修改文件或目录权限" class="headerlink" title="修改文件或目录权限"></a>修改文件或目录权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] [ugoa][+-&#x3D;][rwx] dirname&#x2F;filename</span><br><span class="line">chmod [-R] [xyz] dirname&#x2F;filename (xyz为0-7的数字)</span><br></pre></td></tr></table></figure>

<h3 id="操作与权限的关系"><a href="#操作与权限的关系" class="headerlink" title="操作与权限的关系"></a>操作与权限的关系</h3><p> <img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/DB45115B20484E5D93435C808DEA4B6C/31" alt="image"></p>
<h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><ul>
<li>正规文件（regular file)：第一个字符为[-],包括纯文本文档（ASCII），二进制文件（binary），数据格式文件（data）；</li>
<li>目录（directory）：第一个字符为[d]；</li>
<li>连接档（link）：第一个字符为[l]；</li>
<li>设备与装置文件（device）：通常都集中在/dev目录下，分为区块(block)设备档[b]和字符(character)设备文件[c];</li>
<li>资料接口文件（sockets）：第一个字符为[s]；</li>
<li>数据传输文件（FIFO，pipe）：第一个字符为[p];<h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3></li>
<li>/（root，根目录）：与开机系统有关；</li>
<li>/usr(unix software recourse):与软件安装／执行有关</li>
<li>/var(variable):与系统运作过程有关；</li>
<li>/bin:很多配置文件和指令的目录；</li>
<li>/boot:开机用到的文件；</li>
<li>/dev:装置与接口设备；</li>
<li>/etc:系统主要配置文件；</li>
<li>/lib:系统函数库；</li>
<li>/media:可移除装置，如光盘，软盘，DVD；</li>
<li>/opt:第三方协力软件目录；</li>
<li>/run:早起的FHS规定系统开机后所产生的各项信息放置目录;</li>
<li>/sbin:设定系统环境的指令;</li>
<li>/srv:一些网络服务启动后，需要取用的数据目录;</li>
<li>/tmp:临时文件目录;</li>
<li>/home:家目录;</li>
<li>/lost+found:系统发生错误时，遗失片段放置目录；</li>
</ul>
<h2 id="第六章、文件与目录管理"><a href="#第六章、文件与目录管理" class="headerlink" title="第六章、文件与目录管理"></a>第六章、文件与目录管理</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#显示当前目录</span><br><span class="line">pwd [-P]    </span><br><span class="line">-P:显示真实路径，而非链接（link）路径</span><br><span class="line"></span><br><span class="line">#建立新目录</span><br><span class="line">mkdir 【-mp] dirname    </span><br><span class="line">-m:配置文件权限</span><br><span class="line">-p：递归建立</span><br><span class="line"></span><br><span class="line">#删除空目录</span><br><span class="line">rmdir [-p] dirname  </span><br><span class="line">-p：连同上层的空目录一起删除</span><br></pre></td></tr></table></figure>
<h3 id="执行文件所在路径的变量-PATH"><a href="#执行文件所在路径的变量-PATH" class="headerlink" title="执行文件所在路径的变量$PATH"></a>执行文件所在路径的变量$PATH</h3><p>只有在$PATH中的指令才可以在任意地方执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH  #查看</span><br><span class="line"></span><br><span class="line">PATH&#x3D;&quot;$PATH:&#x2F;root&quot;  #把&#x2F;root加入到$PATH中</span><br></pre></td></tr></table></figure>

<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">ls [-aAdfFhilnrRSt] filename&#x2F;dirname    </span><br><span class="line">ls [--color&#x3D;&#123;never,auto,always&#125;] filename&#x2F;dirname</span><br><span class="line">ls [--full-time] filename&#x2F;dirname</span><br><span class="line">-a : 全部文件，包括隐藏文件（.开头)</span><br><span class="line">-d : 仅列出目录本身，而不是目录内文件</span><br><span class="line">-l : 长数据串输出，包含文件属性、权限等数据</span><br><span class="line"></span><br><span class="line">#复制</span><br><span class="line">cp [-adfilprsu] 来源文件(source) 目标文件(destination)  </span><br><span class="line">cp [options] source1 source2 source3 .... directory</span><br><span class="line">-a : 相当于-dr --preserve&#x3D;all的意思</span><br><span class="line">-d : 若源文件为链接文件属性(link file),则复制链接文件属性，而非文件本身</span><br><span class="line">-f : 强制（force),若文件已存在，删除后再尝试一次</span><br><span class="line">-i ：若目标文件已存在，覆盖前先询问</span><br><span class="line">-l : 建立硬连接，而非复制文件本身</span><br><span class="line">-p : 连同属性（权限，用户，时间）一起复制，而非使用默认属性</span><br><span class="line">-r : 递归</span><br><span class="line">-s ：软链</span><br><span class="line">-u : destination 比 source旧才更新，或destination不存在才复制</span><br><span class="line"></span><br><span class="line">#移除</span><br><span class="line">rm [-fir] filename&#x2F;dirname</span><br><span class="line">-f : force,忽略不存在的文件，不报错</span><br><span class="line">-i : 互动模式，删前确认</span><br><span class="line">-r ：递归</span><br><span class="line"></span><br><span class="line">#移动</span><br><span class="line">mv [-fiu] source destination</span><br><span class="line">mv [options] source1 source2 source3 ... directory</span><br><span class="line">-f : force</span><br><span class="line">-i : 若目标文件已存在，询问是否覆盖</span><br><span class="line">-u : 若目标已存在，且source比较新，才会更新</span><br></pre></td></tr></table></figure>

<h3 id="取得路径和文件名"><a href="#取得路径和文件名" class="headerlink" title="取得路径和文件名"></a>取得路径和文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#路径</span><br><span class="line">basename &#x2F;a&#x2F;b&#x2F;c     #c</span><br><span class="line">#文件名</span><br><span class="line">dirname &#x2F;a&#x2F;b&#x2F;c      #&#x2F;a&#x2F;b</span><br></pre></td></tr></table></figure>

<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li>cat(con++cat++enate)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br><span class="line">-n : 打印行号</span><br></pre></td></tr></table></figure></li>
<li>tac(反向的cat)</li>
<li>nl</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>more(一页一页翻动)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">more filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：查找</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">b：往回翻页</span><br></pre></td></tr></table></figure>
<ul>
<li><p>less（一页一页反动）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">less filename</span><br><span class="line">空格（space）：向下翻一页</span><br><span class="line">回车（Enter）：向下翻一行</span><br><span class="line">&#x2F;字符串：向下查找</span><br><span class="line">?字符串：向上查找</span><br><span class="line">n：重复前一个搜寻</span><br><span class="line">N：反向重复前一个搜寻</span><br><span class="line">g：去第一行</span><br><span class="line">G：去最后一行</span><br><span class="line">:f ：显示文件名和目前显示行数</span><br><span class="line">q：离开</span><br><span class="line">[pagedown]:下一页</span><br><span class="line">[pageup]:上一页</span><br></pre></td></tr></table></figure></li>
<li><p>head（取出前面几行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] file</span><br><span class="line">head [-n +number] file  #取反，后n行不显示</span><br></pre></td></tr></table></figure>
</li>
<li><p>tail（取后面几行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] [-f] file</span><br><span class="line">head [-n -number] file  #取反，前n行不显示</span><br><span class="line">-f：动态输出</span><br></pre></td></tr></table></figure></li>
<li><p>od（非纯文本文档）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od [-t TYPE] file</span><br></pre></td></tr></table></figure>
<h3 id="新建文档或修改文件时间"><a href="#新建文档或修改文件时间" class="headerlink" title="新建文档或修改文件时间"></a>新建文档或修改文件时间</h3><ul>
<li>mtime（modification time）：文件内容变更时间(ls默认时间)</li>
<li>ctime（status time）：文件状态（权限、属性）变更时间</li>
<li>atime（access time）：文件读取时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acdmt] file #建立一个新文件或更新文件的mtime和atime</span><br></pre></td></tr></table></figure>
<h3 id="默认权限和隐藏权限"><a href="#默认权限和隐藏权限" class="headerlink" title="默认权限和隐藏权限"></a>默认权限和隐藏权限</h3><ul>
<li>文件预设权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask</span><br></pre></td></tr></table></figure></li>
<li>文件隐藏属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-&#x3D;][ASacdistu] file&#x2F;dir    #配置文件或目录隐藏属性</span><br><span class="line">lsattr [-adR] file&#x2F;dir  #查看隐藏属性</span><br></pre></td></tr></table></figure></li>
<li>文件特殊权限：SUID，SGID，SBIT</li>
<li>观察文件类型：fie</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure>
<h3 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h3><ul>
<li>which（寻找【指令文件】）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [-a] command</span><br></pre></td></tr></table></figure></li>
<li>whereis(在特定目录搜寻系统文件，不实用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] file&#x2F;dir</span><br></pre></td></tr></table></figure></li>
<li>locate/updatedb（依靠db快速查询）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate [-ir] keyword</span><br><span class="line">updatedb    #locate是靠db快速查询，所以查询较新文件时需要手动updatedb</span><br></pre></td></tr></table></figure>
find(强大，但比较吃硬盘，影响速度)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">1.time(-atime,-ctime,-mtime)</span><br><span class="line">    -mtime n : n天前（一天内）被改动过的文件</span><br><span class="line">    -mtime +n : n天前（不含n本身）被改动过的文件</span><br><span class="line">    -mtime -n : n天内（含n本身）被改动过的文件</span><br><span class="line">2.属组相关参数</span><br><span class="line">    -uid n</span><br><span class="line">    -gid n</span><br><span class="line">    -user name</span><br><span class="line">    -group name</span><br><span class="line">    -nouser</span><br><span class="line">    -nogroup</span><br><span class="line">3.权限及名称</span><br><span class="line">    -name filename</span><br><span class="line">    -size [+-]SIZE:c代表byte，k代表kb</span><br><span class="line">    -type TYPE ： [f,b,c,d,l,s,p]</span><br><span class="line">    -perm mode</span><br><span class="line">    -perm -mode</span><br><span class="line">    -perm &#x2F;mode</span><br><span class="line">4.额外参数</span><br><span class="line">    -exec command : command见下图</span><br><span class="line">    -print</span><br><span class="line">    -a : and的意思，用于连接两个条件，如find &#x2F;etc -size +50k -a -size -60k</span><br><span class="line">    ! : 取反的意思，如find &#x2F;etc -size +50k -a ! -user root</span><br></pre></td></tr></table></figure>
<img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/85FEA75CCD8E4D0CAA94260B98089A1E/431" alt="image"></li>
</ul>
<h2 id="第七章、Linux-磁盘与文件系统管理"><a href="#第七章、Linux-磁盘与文件系统管理" class="headerlink" title="第七章、Linux 磁盘与文件系统管理"></a>第七章、Linux 磁盘与文件系统管理</h2><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>操作系统的文件数据除了文件实际内容外，还有非常多的属性（权限，属组，时间参数）。文件系统会将这两部分数据存放在不同的区块，权限与属性放到inode中，实际数据放到data block中。另外，还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括inode和block总量、使用量、剩余量等。</p>
<ul>
<li>superblock：记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在block号码；</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block；</li>
</ul>
<p>每个inode与block都有编号，每个文件都会占用一个inode，inode内则有文件数据放置的block号码。这种数据存取方法我们称为索引式文件系统（indexed allocation）（下图）。<br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/EE38F1F9F8A54CB185593EC9E07B2AAA/489" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/91f49489e63185046c6483d6ca66c85a/xmlnote/561C779757124369BE8A8F997D760FBE/501" alt="image"><br>上图为闪存用的FAT格式，没有inode存在，所以FAT没有办法将这个文件的所有block再一开始就读取出来。每个block号码都记录再前一个block当中。如果同一个文件数据写入的block分散的太过厉害，无法在磁盘转一圈就读到所有数据，就需要多转好几圈。<br>碎片整理的原因就是文件写入的block过于分散，读取文件的效率会变得很差，这时候可以透过 碎片整理将同一个文件的blcok汇整到一起，这样读取会比较容易。Ext2是索引式文件系统，不需要整理。</p>
<h3 id="Linux的EXT2文件系统（inode）"><a href="#Linux的EXT2文件系统（inode）" class="headerlink" title="Linux的EXT2文件系统（inode）"></a>Linux的EXT2文件系统（inode）</h3><p>文件系统一开始就将inode与block规划好了，除非重新格式化（或者利用resize2fs等指令变更文件系统大小），否则inode与block固定后就不再变动。</p>
<h3 id="7-2-文件系统的简单操作"><a href="#7-2-文件系统的简单操作" class="headerlink" title="7.2 文件系统的简单操作"></a>7.2 文件系统的简单操作</h3><h4 id="7-2-1-磁盘与目录的容量"><a href="#7-2-1-磁盘与目录的容量" class="headerlink" title="7.2.1 磁盘与目录的容量"></a>7.2.1 磁盘与目录的容量</h4><p>df:列出文件系统的整体磁盘使用量；</p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-《CS:APP》学习笔记-第一章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/23/%E3%80%8ACS:APP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"
    >《深入理解计算机系统》第一章</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/23/%E3%80%8ACS:APP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="article-date">
  <time datetime="2018-09-23T07:33:38.000Z" itemprop="datePublished">2018-09-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    hello程序的生命周期是从一个源程序开始的。源程序是一个由值0和1组成的位（又称比特）序列，8个位组成一组，称为字节。每个字节必保湿程序中的某些特殊文本字符。大部分计算机系统使用ASCII标准来表示文本字符，这种方式实际上就是一个唯一的单字节大小的整数值来表示每个字符（入下图）。</p>
<p><img src="http://pfjta0ejx.bkt.clouddn.com/hello-ASCII.png" alt="ASCII"></p>
<p>​    hello.c程序是以字节序列的方式存储在文本文件中的。每个字节都有一个整数值，对应某些字符。这种表示方法说明了一个节本思想：系统中所有信息——包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传输的数据，都是由一串比特表示的，区别不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>​    hello程序的生命周期是从一个高级C语言开始的，因为这种形式被人读懂。然而为了在系统上运行，每条C语句被其他程序转化为一系列低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存起来。下面是GCC编译驱动器把源文件翻译成可执行文件的四个阶段。</p>
<p><img src="http://pfjta0ejx.bkt.clouddn.com/compile-system.png" alt=""></p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-7" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/23/arts-7/"
    >arts-7.md</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/23/arts-7/" class="article-date">
  <time datetime="2018-09-23T06:57:22.000Z" itemprop="datePublished">2018-09-23</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h4 id="Approach-1-Recursion"><a href="#Approach-1-Recursion" class="headerlink" title="Approach 1: Recursion"></a>Approach 1: Recursion</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    用递归的思想一点一点地合并，时间复杂度是O(n+m)，空间复杂的也是O(n+m) 。写的时候遇到一个以前没有注意到的小坑，就是C语言里是没有elseif这个关键字的，esle和if之间必须有空格，不然会编译失败，</p>
<h4 id="Approach-2-Iteration"><a href="#Approach-2-Iteration" class="headerlink" title="Approach 2: Iteration"></a>Approach 2: Iteration</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prehead</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">prehead</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            prev-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    迭代l1和l2头上的元素进行比较，每次取出较小的一个放入一个新链表，并更新较小的那个元素所在的链表的指针，使其指向下一个元素，重复上一步骤，直至其中一个链表为空，把另一个链表剩下的部分拼到新链表后面，并返回新链表。</p>
<p>​    时间复杂度为O(n+m)，因为while循环的次数相当于两个链表的长度之和（忽略剩余的部分），是线性的。</p>
<p>​    空间复杂度是O(1)，迭代算法只是分配了几个指针，具有恒定的总内存占用量。</p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-6" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/16/arts-6/"
    >arts-6.md</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/16/arts-6/" class="article-date">
  <time datetime="2018-09-16T01:55:29.000Z" itemprop="datePublished">2018-09-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/ARTS/">ARTS</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> limit = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(limit);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cur = s[i];</span><br><span class="line">        <span class="keyword">if</span> ((cur == <span class="string">'('</span>) || (cur == <span class="string">'['</span>) || (cur == <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == limit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[idx++] = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((cur == <span class="string">'&#125;'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'&#123;'</span>)</span><br><span class="line">                || (cur == <span class="string">']'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'['</span>)</span><br><span class="line">                || (cur == <span class="string">')'</span> &amp;&amp; <span class="built_in">stack</span>[idx - <span class="number">1</span>] == <span class="string">'('</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> idx == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"(([]))"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">isValid</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    parentheses := <span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">rune</span>&#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">'('</span> || char == <span class="string">'['</span> || char == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; parentheses[char] == stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题比较简单，解题思路比较单一（也可能是我没看到别的思路），用一个栈去从左到右的读取字符串，遇到左括号就入栈，右括号就判断与前一个是否对应，是的话就出栈，否的话就报错，直至读取完没有遇到错误的话idx的值应该等于0。</p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-指针学习笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/09/%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >指针学习笔记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/09/%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-09-09T02:36:27.000Z" itemprop="datePublished">2018-09-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="C语言指针的总结"><a href="#C语言指针的总结" class="headerlink" title="C语言指针的总结"></a>C语言指针的总结</h1><p>原文出自xx_cc</p>
<p>链接：<a href="https://www.jianshu.com/p/63f3bfb58687" target="_blank" rel="noopener">https://www.jianshu.com/p/63f3bfb58687</a></p>
<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ol>
<li>不同类型的变量在内存中占据不同的字节空间。</li>
<li>内存中存储数据的最小基本单位是字节，每一个字节都有一个内存地址，这个地址是一个十六进制的数。</li>
<li>声明一个变量，在内存中是从高字节向低字节分配连续的指定字节数的空间。</li>
<li>任何数据在内存中都是以其二进制的补码形式存储的，低位存储在低字节，高位存储在高字节。</li>
<li>变量的值：存储在变量中的数据，叫做变量的值。</li>
<li>变量的地址：一个变量是由一个或者多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址。</li>
<li>如何取出变量的地址：使用&amp;（取地址运算符）运算符，&amp;变量名；这个表达式的值就是这个变量的地址。使用%p控制度输出变量的地址。</li>
<li>什么是指针：变量的地址叫做指针，指针就是地址，地址就是指针。</li>
</ol>
<p>下面通过一张图可以更直观的理解内存中的地址</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1434508-3146d4e4c4362be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p>
<p>内存中的地址演示图</p>
<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><ol>
<li>指针是C语言的灵魂。指针变量占据8个字节。</li>
<li>变量在内存中的存储。<br> 变量的值：存储在变量中的数据，叫做变量的值。<br> 变量的地址：组成这个变量的低字节的地址，就是这个变量的地址。</li>
<li>取出变量的地址，用&amp;运算符 %p输出变量的地址。</li>
<li>变量的地址就叫做指针，我们可以使用一个指针变量来存储变量的地址。</li>
</ol>
<h5 id="指针变量："><a href="#指针变量：" class="headerlink" title="指针变量："></a>指针变量：</h5><ol>
<li>指针变量就是专门用来存储 <strong>地址</strong> 的变量，那么我们就说指针变量指向了另外一个变量，存储着另外一个变量的地址。</li>
<li>指针可以使访问一个变量的方式分为两种。<br> a. 直接访问<br> b. 可以通过指针变量，找到这个指针指向的变量<br> 所以通过指针变量可以间接的访问指针变量指向的另外一个变量。</li>
<li><strong>如何声明一个专门用来存储地址的指针变量</strong><br> 数据类型  <code>*</code> 指针变量的名称   — <code>int * p1;</code><br> 指针变量的名字叫做p1，这个指针变量的类型是<code>int*</code> 读作int指针。<br> <code>*</code>表示这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量，所以有哪些普通的数据类型，就可以有哪些类型的指针。<br> 声明的时候注意，<code>*</code>的位置 建议  <code>int* p</code>这样提醒我们这是一个<code>int*</code>类型的指针。<br> ** 一个指针变量并不是可以存储任意类型的变量的地址，而是有限定的，只能存储和这个指针类型相同的普通变量的地址。** 所以<code>p</code> 指针变量中只能存储<code>int</code>类型变量的地址。</li>
<li>指针变量的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; 10;</span><br><span class="line">int *p &#x3D;  &amp;num; 建议int* p &#x3D; &amp;num;这样写</span><br></pre></td></tr></table></figure>

<p>p指针指向了num变量。因为p指针的值就是num变量的地址，不能直接赋值一个非地址类型的常量数据，也不能直接赋值一个变量给指针。</p>
<ol>
<li>p指针自己也有地址， 因为指针变量也是一个变量，&amp;p取到指针p的地址。</li>
<li>p操作的是p这个指针变量，可以取p得值，也可以为p赋值</li>
<li><strong>指针变量的使用</strong><br> 可以使用指针间接的操作指针指向的变量。<br> <code>*p</code> 代表 <code>p</code> 指针指向的变量。<br> <code>*p</code> 完全等价于<code>num</code> 即 <code>*p = 100</code> 完全等价于 <code>num = 100</code>。<br> <code>*p = 100;</code> 表示将100赋值给p指针指向的变量，也就是num变量</li>
</ol>
<p>使用指针变量的时候注意点<br> <code>int* p1 ,p2, p3 ;</code> 此时<code>p1</code>是<code>int *</code>指针，而<code>p2,p3</code>是<code>int</code>类型数据 如果希望全部都是指针需要 <code>int *p1, * p2, * p3;</code></p>
<ol>
<li><strong>野指针</strong><br> 我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量中是有值的，是<strong>垃圾值，随机数</strong>。因为这个时候，这个指针变量有可能指向了一块<strong>随机的空间</strong>，这个空间可能无人使用，也可能别的程序在用，也可能系统在用，这个时候，去访问指针指向的的变量的时候，就会报错。<strong>BAD_ACCESS</strong>坏地址访问错误，像这样的指针我们就叫做野指针。</li>
<li>NULL值 完全等价于0<br> 为了防止野指针的产生，建议声明一个指针变量后，最好为其初始化，如果没有变量的地址初始化给这个指针变量。那么就初始化一个<strong>NULL</strong>值。NULL值代表指针变量不指向内存中的任何地址，这样就不会出现野指针，<strong>NULL完全等价于0</strong>，所以也可以直接赋值给一个指针变量0。<br> 如果一个指针变量的值是NULL，那么去访问这个指针指向的变量的时候一定会报错。</li>
<li>多个指针指向同一个变量，修改其中一个所有指针指向的值都会改变。因为多个个指针指向的是同一块地址。即 <code>*</code> 会使指针间接的操作指针指向的变量。</li>
<li><strong>指针作为函数的参数</strong><br> 如果函数的参数是一个指针，那么就必须要为这个<strong>指针</strong>传递一个和<strong>指针类型相同的普通变量的地址</strong>，这个时候，在函数的内部去访问参数指针的变量的时候，其实访问的就是实参变量</li>
<li><strong>指针作为函数的参数，可以实现什么效果？</strong><br> 函数的内部可以修改实参变量的值。那么什么时候使用指针作为参数呢？<br> 一般函数只能返回一个数据，那么当函数需要返回<strong>多个数据</strong>的时候就可以使用<strong>指针作为参数</strong>，让<strong>调用者将自己的变量的地址传递给函数内部，函数内部通过指针就可以修改参数</strong>，函数无需将数值传回来，就已经修改了参数的值。其实scanf函数传递的就是指针，<strong>因此当函数需要多个返回值的时候就可以使用指针作为参数。</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从下面代码中就可以看出，我们可以直接在函数中修改两个变量的值。相当于函数有两个返回值。</span><br><span class="line">void  changeValue (int* p1 ,int* p2)&#123;</span><br><span class="line">    *p1 &#x3D; 100;</span><br><span class="line">    *p2 &#x3D; 200;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int num1 &#x3D; 1;</span><br><span class="line">    int num2 &#x3D; 2;</span><br><span class="line">    changeValue(&amp;num1, &amp;num2);</span><br><span class="line">    printf(&quot;num1 &#x3D; %d\n&quot;,num1);</span><br><span class="line">    printf(&quot;num2 &#x3D; %d&quot;,num2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指针为什么要分类型</strong><br> <strong>指针变量既然是一个变量就要在内存中占用字节空间</strong><br> 指针变量在内存中占据多少字节数？<br> <strong>无论指针是什么类型在内存中都是占据8个字节。</strong><br> 那为什么指针还要分类呢？<br> p指针变量中存储的是num变量的地址，也就是num变量低字节的地址，<strong>通过p指针只能找到这个地址的字节</strong>，这个时候，通过p指针找到这个字节，操作的时候，操作多少个字节是则是根据<strong>指针的类型</strong>来决定的。<br> <strong>所以指针变量的类型决定了通过这个指针找到字节以后，连续操作多少个字节空间。</strong><br> int 指针 连续操作4个字节空间<br> double 指针 连续操作8个字节空间<br> float 指针  连续操作4个字节空间<br> char 指针  连续操作1个字节空间<br> 因此，指针的类型如果不和指向的变量的类型相同的话，那么通过指针就无法正确的操作指向的变量，所以，<strong>指针的变量一定要指向一个和自己类型相同的普通变量才可以。</strong></li>
</ol>
<p>   <img src="https:////upload-images.jianshu.io/upload_images/1434508-a35b6912864b9740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="img"></p>
<p>   指针为什么要分类型？</p>
<ol start="2">
<li><p>多级指针<br> 一个指针变量中存储的是一个一级指针的地址，那么它就是二级指针，一个指针变量中存储的是一个二级指针的地址，那么它就是三级指针。<br> 二级指针：<code>数据类型 ** 指针名</code><br> 二级指针只能存储一级指针变量的地址。<br> 多级指针在开发中很少用到，遇到多级指针耐心分析一定可以理清其中的关系。</p>
</li>
<li><p>指针与整数的加减法<br> 指针可以和整数进行加减运算，指针+1并不是在指针地址的基础之上加一个字节的地址，而是在这个<strong>指针地址的基础之上加一个单位变量占用的字节数</strong>，例如：如果指针类型是<code>int *</code> 则+1代表加4个字节地址，以此类推。</p>
</li>
<li><p><strong>指针与数组</strong><br> 我们可以使用指针来遍历数组，因为数组的本质其实就是指针，当我们创建数组的时候，系统会在内存中由高地址向低地址分配连续的类型所占的空间字节数 * 数组内元素的个数的字节控件。而数组名则代表了数组的低字节地址，也就是数组的地址。<br> 1). 使用指针遍历数组的第一种方式.<br> int arr[7] = {10,20,30,40,50,60,70}; //在内存中高地址向低地址分配连续的 类型所占的空间字节数 * 数组内元素的个数 7 * 4 = 28 个字节空间<br> int* p1 = arr;    //p1指针指向了数组的第0个元素.<br> for(int i = 0; i &lt; 7; i++)<br> {<br> printf(“%d\n”,*(p1+i));<br> }</p>
<p>2). 使用指针遍历数组的第二种方式.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(arr+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3). 使用指针遍历数组的第三种方式.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int arr[7] &#x3D; &#123;10,20,30,40,50,60,70&#125;;</span><br><span class="line">int* p1 &#x3D; arr;</span><br><span class="line">for(int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;%d\n&quot;,*(p1++));</span><br><span class="line">&#125;</span><br><span class="line">注意的地方,每次循环,p1的值都会变化。</span><br><span class="line">最后1次执行完毕之后,p1指针指向数组外面去了,p1就不再执行数组中的任何元素了。</span><br></pre></td></tr></table></figure>

<p>注意: 数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变。<br> 所以，我们不能为数组名赋值也不能修改数组名的值，但是可以使用数组名的值。<br> <strong>arr是数组的地址，也是数组中第0个元素的地址，arr+1就是数组中第一个元素的地址，数据名就是一个地址常量，无法改变。</strong></p>
</li>
<li><p><strong>数组作为函数的参数的本质</strong><br> 当数组作为函数的参数的时候，在声明这个参数数组的时候，并不是去创建一个数组，而是去创建一个用来存储地址的指针变量，如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组变成了指针，这也就是为什么我们通过sizeof计算参数数组得到的永远都是8，所以以后我们的函数如果带了一个数组参数，建议直接写一个指向数组的第0个元素的指针，在传入数组的长度</p>
</li>
<li><p><strong>索引的本质</strong><br> <strong>指针变量后面可以使用中括号，在中括弧中写上下标来访问数据。</strong><br> <code>p[n];</code>前提<code>p</code>是一个指针变量，完全等价于<code>*(p + n);</code><br> 所以<code>arr[0]</code> 就等价于 <code>* [arr + 0]</code>。<br> 操作数组我们虽然使用中括弧下标来操作，实际上内部本质仍然是使用的指针来操作。</p>
</li>
<li><p>存储指针的数组<br> 如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组<br> 格式 ：<code>元素类型 数组名[数组长度];</code> <code>int * arr[3];</code><br> arr数组里面存储int指针数据，最多存储3个。</p>
</li>
<li><p>指针与指针之间的减法运算<br> 指针与指针之间可以做减法运算，结果是一个long类型的数据，<br> 结果的意义代表两个指针指向的变量之间相差多少个单位变量，绝大多数情况下，我们用在判断数组的两个元素之间相差多少个元素<br> 如果参与减法运算的两个指针不指向同一个数组，结果就会出现问题<br> <strong>结果 = 两个指针的差 / 每一个指针变量对应的普通变量占用的字节数。</strong><br> 并且只能做减法运算，<strong>用在数组当中判断两个元素之间相差多少个元素。</strong></p>
</li>
<li><p>指针与指针在之间的比较运算 <code>&lt;, &lt;=, &gt;, &gt;=, ==, !=</code>都可以使用<br> 可以用来判断两个指针指向的变量的字节，谁在高字节，谁在低字节。或者两个指针的地址是不是同一个地址。</p>
</li>
<li><p><strong>指针和字符变量</strong><br> <code>char *name = &quot;jack&quot;;</code>表示直接将一个字符串数据初始化给一个字符指针。</p>
<p><strong>字符指针存储和字符数组存储的区别</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符数组存储：将字符串数据的每一个字符存储到字符数组的元素中，并追加一个 \n 表示结束</span><br><span class="line">char name[5] &#x3D; &quot;jack&quot;;</span><br><span class="line">&#x2F;&#x2F; 直接为字符指针初始化一个字符串数据</span><br><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">1.) 当他们都是局部变量的时候</span><br></pre></td></tr></table></figure>

<p><strong>字符数组</strong>是申请在栈区的，字符串的每一个字符存储在字符数组的每一个元素中。<br> <strong>指针变量</strong>是声明在栈区的。但是此时字符串数据是以字符数组的形式存储在<strong>常量区</strong>的。此时<strong>指针变量中存储的是字符串在常量区的地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.) 当他们作为全局变量的时候</span><br></pre></td></tr></table></figure>

<p><strong>字符数组</strong>是存储在常量区的，字符串的每一个字符存储在这个数组中的每一个元素中。<br> <strong>字符指针</strong>也是存储在常量区，字符串也是以字符数组的形式存储在常量区，<strong>指针中存储的是字符串在常量区的地址。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**以字符数组存储的字符串数据，可以修改字符数组的元素。可变</span><br><span class="line">以字符指针的形式存储字符串数据，这个时候字符指针指向的字符串数据是无法修改的，不可变**</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>字符串的恒定型</strong><br> 前提：<strong>以字符指针形式存储的字符串</strong><br> 1.) 当我们以字符指针的形式存储字符串的时候，无论如何，字符串数据是存储在常量区的，并且，一旦存储到常量去中去，这个字符串数据就无法更改。</p>
<p>2.) 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储到常量区中。</p>
<p>3.) 当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，因为原来的字符串数据是不可更改的，而是重新的创建了一个字符串，把这个新的字符串的地址赋给他。建议使用字符指针来存储字符串数据。优势：长度任意。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *name &#x3D; &quot;jack&quot;;</span><br><span class="line">nsme &#x3D; &quot;rose&quot;;</span><br><span class="line">&#x2F;&#x2F; 这样可以 但是并不是把jack改成了rose，而是重新创建了一个&quot;rose&quot;,把rose地址赋值给name</span><br></pre></td></tr></table></figure>

<ol>
<li>字符串数组<br> <code>char *names[4] = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};</code><br> names数组的元素的类型是char指针，初始化给元素的字符串数据是存储在常量区的。元素中存储的是<strong>字符串在常量区的地址</strong><br> 因此这是一个存储指针的数组，每一个元素的类型是一个指针，占用得内存为8个字节。</li>
<li>指向函数的指针。<br> 程序在运行的时候，会将程序加载到内存，内存的代码段中主要存储的就是程序的代码，而程序的代码就包括函数。<strong>既然函数要存储在内存中，那么肯定要用1块空间来存储，那么这个块空间一定有1个地址。</strong><br> 因此我们就可以<strong>声明1个指针用来存储这个函数的地址</strong>，也就是说让这个指针指向这个函数。这样我们就可以使用<strong>指针来间接的调用函数</strong>。<br> 优势: 调用函数有了两种方式。<br> 1.) 直接使用函数名调用<br> 2.) 使用指向函数的指针间接调用.</li>
<li>指向函数的指针的声明<br> 一个指向函数的指针，并不是任意的函数都可以指向，而是有限定的，要求指向的<strong>函数的返回值类型和参数描述必须要与指针的描述一样</strong>。<br> 声明语法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*指针名)([参数列表]);</span><br><span class="line">void (*pFunction)();</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFunction。</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向没有返回值,并且没有参数的函数。</span><br><span class="line">int (*pFun)(int num1,int num2);</span><br><span class="line">&#x2F;&#x2F; 表示声明了1个指向函数的指针,名字叫做pFun.</span><br><span class="line">&#x2F;&#x2F; 这个指针只能指向返回值为int类型 并且有两个整型的参数的函数.</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指向函数的指针的初始化</strong><br><strong>函数的名称就代表函数的地址，因此我们直接将符合条件的函数的名称赋值给这个指针。</strong><br>并且我们有两种方法可以通过指针来调用这个函数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int MaxValue (int a, int b)&#123;</span><br><span class="line">       return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;    </span><br><span class="line">       int(*pMaxValue)(int a, int b) &#x3D; MaxValue; &#x2F;&#x2F; 创建一个返回int 并且有两个int型参数的函数指针，并赋值。</span><br><span class="line">       printf(&quot;%d\n&quot;, pMaxValue(5,10)); &#x2F;&#x2F; 通过指针调用函数方法1</span><br><span class="line">       printf(&quot;%d\n&quot;,(*pMaxValue)(6,9)); &#x2F;&#x2F; 通过指针调用函数方法2</span><br><span class="line">       printf(&quot;%d\n&quot;,MaxValue(9, 13)); &#x2F;&#x2F; 调用函数</span><br><span class="line">       printf(&quot;%p\n&quot;,MaxValue); &#x2F;&#x2F; 输出函数的地址</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8C%87%E9%92%88/" rel="tag">指针</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-5" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/08/12/arts-5/"
    >arts-5</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/08/12/arts-5/" class="article-date">
  <time datetime="2018-08-12T11:20:52.000Z" itemprop="datePublished">2018-08-12</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">char</span> **strs, <span class="keyword">int</span> strsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strsSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    先通过把第一个字符串跟每个字符串比较的方式计算出公共前缀的长度</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]); <span class="keyword">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (tempIndex = <span class="number">0</span>; tempIndex &lt; index; tempIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][tempIndex] != strs[i][tempIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        当tempIndex &lt; Index时，可以更新Index来省去多余的计算</span></span><br><span class="line">        <span class="keyword">if</span> (tempIndex &lt; index) &#123;</span><br><span class="line">            index = tempIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算出前缀长度后，字符串数据是存储在常量区的，不能直接更改，所以要为前缀申请内存空间并付值，+1是为了留出'\0'的位置</span></span><br><span class="line">    <span class="keyword">char</span> *prefix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (index + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">strncpy</span>(prefix, strs[<span class="number">0</span>], index);</span><br><span class="line">    prefix[index] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arr[] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = longestCommonPrefix(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Summary:</strong></p>
<p>这是一个比较容易想到的思路，时间复杂度的是O(n^2)，不算快；空间复杂度是O(1)。可以优化的点有两个：tempIndex小于Index时更新Index，减少不必要的比较；计算出前缀的长度再去为变量申请空间，会比一上来就申请strs[0]大小的空间之后再截断的方式好一些。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	fst := strs[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> carry <span class="keyword">string</span></span><br><span class="line">L0:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> fst &#123;</span><br><span class="line">		t := fst[<span class="number">0</span> : i+<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;</span><br><span class="line">			<span class="keyword">if</span> !strings.HasPrefix(v, t) &#123;</span><br><span class="line">				<span class="keyword">break</span> L0</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(carry) &#123;</span><br><span class="line">			carry = t</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> carry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://angular.io/guide/architecture-services" target="_blank" rel="noopener">Angular:Introduction to services and dependency injection</a></p>
<p>Components consume services; that is, you can inject a service into a component, giving the component access to that service class.</p>
<p>组件使用服务。换句话说，你可以把某个服务注入到组件中，从而使得这个组件可以访问到该服务。</p>
<p>Dependency injection (often called DI) is wired into the Angular framework and used everywhere to provide new components with the services or other things they need.</p>
<p>依赖注入，经常被简称为DI，在Angular中被广泛使用。你几乎可以在任何地方，看见他们为各类组件提供所需的服务。</p>
<p>The injector maintains a container of dependency instances that it has already created, and reuses them if possible.</p>
<p>注入器维护着一个容器，这个容器中是各类已经被创建过的依赖的实例。如果可能的话，注入器会优先复用这些实例。</p>
<p>A provider is a recipe for creating a dependency. For a service, this is typically the service class itself. For any dependency you need in your app, you must register a provider with the app’s injector, so that the injector can use it to create new instances.</p>
<p>“提供者”是创建依赖时所使用的机制。对于普通服务来说，“提供者”通常就是服务类本身。但对于应用中所需的其他依赖来说，你必须通过“注入器”注册一个“提供者”，以便注入器可以使用该“提供者”创建新的实例。</p>
<p>When Angular discovers that a component depends on a service, it first checks if the injector already has any existing instances of that service.</p>
<p>当Angular发现一个组件依赖于某个服务时，它会先去检查“注入器”中是否已经有了这个服务的实例。</p>
<p>If a requested service instance does not yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</p>
<p>如果被请求的服务实例不存在，那么“注入器”就会用注册过的“提供者”创建一个新的实例，然后把它加入到“注入器”中，并把这个实例返回给Angular。</p>
<h2 id="SHARE"><a href="#SHARE" class="headerlink" title="SHARE"></a>SHARE</h2><h3 id="关于-typedef-的一些理解"><a href="#关于-typedef-的一些理解" class="headerlink" title="关于 typedef 的一些理解"></a>关于 typedef 的一些理解</h3><ol>
<li>表达方式简洁。</li>
<li>可以使程序参数化，提高程序的可移植性。如果 typedef 声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需要改变 typedef 类型定义就可以了。</li>
<li>为程序提供更好的说明性——Treeptr 类型显然比一个声明为指向复杂结构的指针更容易让人理解。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-4" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/08/04/arts-4/"
    >arts-4</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/08/04/arts-4/" class="article-date">
  <time datetime="2018-08-04T11:07:58.000Z" itemprop="datePublished">2018-08-04</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">0</span>, value2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += temp) &#123;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        value1 = convert(s[i]);</span><br><span class="line">        value2 = convert(s[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2 &amp;&amp; value2 != <span class="number">0</span>) &#123;</span><br><span class="line">            result += value2 - value1;</span><br><span class="line">            temp = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://www.kernel.org/doc/html/latest/userspace-api/unshare.html" target="_blank" rel="noopener">The Linux Kernel</a></p>
<p>Most legacy operating system kernels support an abstraction of threads as multiple execution contexts within a process.</p>
<p>很多老旧的操作系统内核以这样的方式来支持线程：它们把线程抽象成了同一进程内的多个执行上下文。</p>
<p>These kernels provide special resources and mechanisms to maintain these “threads”.</p>
<p>这些系统内核提供了特殊的资源和管理机制来支持这类线程。</p>
<p>The Linux kernel, in a clever and simple manner, does not make distinction between processes and “threads”.</p>
<p>而Linux内核，则采用了一种聪明而且简单的方式——在内核层面上，它并不区分进程和线程。</p>
<p>The kernel allows processes to share resources and thus they can achieve legacy “threads” behavior without requiring additional data structures and mechanisms in the kernel. </p>
<p>Linux内核允许多条进程共享资源。这样做的好处在于，即使内核不再提供额外的数据结构和管理机制，和传统线程类似的行为也能被实现出来。</p>
<p>The power of implementing threads in this manner comes not only from its simplicity but also from allowing application programmers to work outside the confinement of all-or-nothing shared resources of legacy threads. </p>
<p>以这样的实现方式来支持线程，不仅简单，而且也可以帮助程序员们摆脱曾经让他们感到烦恼的一个限制：在传统的线程模型中，要么就不能共享资源，要么就得全局共享资源。</p>
<p>On Linux, at the time of thread creation using the clone system call, applications can selectively choose which resources to share between threads.</p>
<p>在Linux中，程序在使用clone这个系统指令去创建线程时，可以选择性地指定哪部分资源会被其他线程所共享，而无需将所有资源都共享出去。</p>
<p>unshare() system call adds a primitive to the Linux thread model that allows threads to selectively ‘unshare’ any resources that were being shared at the time of their creation.</p>
<p>unshare这个系统指令，为Linux的线程模型增加了一个基本功能：即便一些资源在线程创建时被设置为可共享了，也可以使用unshare指令将这些资源重新收归私有。</p>
<p>OSI and TCP/IP are the most used models to abstract the computer network.</p>
<p>OSI和TCP/IP是在抽象计算机网络时最常用的两种模型。</p>
<p>OSI, the theoretically better abstraction of the network model, failed to be widely adopted due to its complexity.</p>
<p>OSI，这种在理论上看似更优的网络模型的抽象方式，由于过于复杂而没有被工业界大规模采用。</p>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINES 5000 <span class="comment">/* max #lines to be sorted */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *lineptr[MAXLINES]; <span class="comment">/* pointers to text lines */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000 <span class="comment">/* size of available space */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE]; <span class="comment">/* storage for alloc */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf; <span class="comment">/* next free position */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">/* return pointer to n characters */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123; <span class="comment">/* it fits */</span> allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n; <span class="comment">/* old p */</span> &#125; <span class="keyword">else</span> <span class="comment">/* not enough room */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span> <span class="comment">/* free storage pointed to by p */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) allocp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getline2</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim - <span class="number">1</span> &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != <span class="string">'\n'</span>; ++i)</span><br><span class="line">        s[i] = c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">        s[i] = c;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort input lines */</span></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">int</span> nlines; <span class="comment">/* number of input lines read */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((nlines = readlines(lineptr, nlines)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        qsort(lineptr, <span class="number">0</span>, nlines - <span class="number">1</span>);</span><br><span class="line">        writelines(lineptr, nlines);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: input too big to sort\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 1000 <span class="comment">/* max length of any input line */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> maxlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, nlines;</span><br><span class="line">    <span class="keyword">char</span> *p, <span class="built_in">line</span>[MAXLEN];</span><br><span class="line">    nlines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = getline2(<span class="built_in">line</span>, MAXLEN)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (nlines &gt;= maxlines || (p = alloc(len)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">line</span>[len - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">/* delete newline */</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p, <span class="built_in">line</span>);</span><br><span class="line">            lineptr[nlines++] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> nlines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writelines</span><span class="params">(<span class="keyword">char</span> *lineptr[], <span class="keyword">int</span> nlines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nlines; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, lineptr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* qsort: sort v[left]...v[right] into increasing order */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="comment">/* do nothing if array contains */</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* fewer than two elements */</span></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);</span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(v[i], v[left]) &lt; <span class="number">0</span>) swap(v, ++last, i);</span><br><span class="line">    swap(v, left, last);</span><br><span class="line">    qsort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    qsort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* swap: interchange v[i] and v[j] */</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    temp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by akaQin on 2018/8/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOCSIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> allocbuf[ALLOCSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *allocp = allocbuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123;</span><br><span class="line">        allocp += n;</span><br><span class="line">        <span class="keyword">return</span> allocp - n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afree</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) &#123;</span><br><span class="line">        allocp = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a = alloc(<span class="number">1</span>);</span><br><span class="line">    *(a<span class="number">-1</span>) = <span class="string">'b'</span>;</span><br><span class="line">    *a = <span class="string">'a'</span>;</span><br><span class="line">    *(a+<span class="number">1</span>) = <span class="string">'b'</span>;</span><br><span class="line"><span class="comment">//    *(a+2) = '\0';</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Created by akaQin on 2018&#x2F;8&#x2F;11.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char *strcat(char *s, char *t) &#123;</span><br><span class="line">    char *se &#x3D; s;</span><br><span class="line">&#x2F;&#x2F;    for (; *se; ++se);</span><br><span class="line">        while (*se !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">            se++;</span><br><span class="line">        &#125;</span><br><span class="line">    while ((*se++ &#x3D; *t++) !&#x3D; &#39;\0&#39;);</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char s[] &#x3D; &quot;ab&quot;;</span><br><span class="line"></span><br><span class="line">char t[] &#x3D; &quot;cd&quot;;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    printf(&quot;%s&quot;, strcat(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-3" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/07/29/arts-3/"
    >arts-3</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/07/29/arts-3/" class="article-date">
  <time datetime="2018-07-29T13:07:26.000Z" itemprop="datePublished">2018-07-29</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a><strong>Example 2:</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>



<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a><strong>Example 3:</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Approach 1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hold = x;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        val = val * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val == hold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>原文：<a href="https://dev.mysql.com/doc/mysql-replication-excerpt/5.5/en/replication-implementation.html" target="_blank" rel="noopener">MySQL Replication Implementation</a></p>
<p>Replication is based on the master server keeping track of all changes to its databases (updates, deletes, and so on) in its binary log. </p>
<p>复制是通过将所有数据库修改操作记录（更新，删除等）到了日志文件中的主服务器实现的。</p>
<p>The binary log serves as a written record of all events that modify database structure or content (data) from the moment the server was started. </p>
<p>日志服务器担负着将各类修改记录写入日志文件的职责。从日志服务器被启动的那一刻起，所有修改了数据库结构或者数据的事件，都会被它记录下来。</p>
<p>Typically, SELECT statements are not recorded because they modify neither database structure nor content.</p>
<p>一般来说，SELECT语句不会被记录下来，因为他们既不会影响数据库的结构，也不会影响数据库的数据。</p>
<p>Each slave that connects to the master requests a copy of the binary log.</p>
<p>每台接上了主服务器的从服务器都会请求一份二进制日志的拷贝文件。</p>
<p>That is, it pulls the data from the master, rather than the master pushing the data to the slave. </p>
<p>那就是，“从服务器”从“主服务器”那里将日志拉取回来，而非主服务器向从服务器推送日志。</p>
<p>The slave also executes the events from the binary log that it receives. This has the effect of repeating the originalchanges just as they were made on the master.</p>
<p>从服务器会将它收到的二进制日志中所记录的事件再执行一遍，这样就起到了重复这些操作的效果，就好像这些操作在主服务器上被执行时一样。</p>
<p>Tables are created or their structure modified, and data is inserted, deleted, and updated according to the changes that were originally made on the master.</p>
<p>根据主服务器对于各类操作的记录，从服务器上的数据表会相应地被创建或修改、而从服务器上的数据也会被相应地插入、删除或更新。</p>
<h2 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h2><p>逆波兰计算器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP 100 <span class="comment">/* max size of operand or operator */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span> <span class="comment">/* signal that a number was found */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> [])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> NUMBER:</span><br><span class="line">                push(atof(s));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                push(pop() + pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                push(op2 - pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                push(pop() * pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                op2 = pop();</span><br><span class="line">                op2 == <span class="number">0.0</span> ? <span class="built_in">printf</span>(<span class="string">"zero divisor\n"</span>) : push(pop() / op2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: unknown command %s\n"</span>, s);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100 <span class="comment">/* maximum depth of val stack */</span></span></span><br><span class="line"><span class="keyword">int</span> sp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> val[MAXVAL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &lt; MAXVAL) &#123;</span><br><span class="line">        val[sp++] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack full, can't push %g\n"</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> val[--sp];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: stack empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getop: get next character or numeric operand */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, c;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getch()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>) &#123; ;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) &#123; ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF) &#123;</span><br><span class="line">        ungetch(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 100</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE]; <span class="comment">/* buffer for ungetch */</span></span><br><span class="line"><span class="keyword">int</span> bufp = <span class="number">0</span>; <span class="comment">/* next free position in buf */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">/* get a (possibly pushed-back) character */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bufp &gt; <span class="number">0</span>) ? buf[--bufp] : getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ungetch</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">/* push character back on input */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufp &gt;= BUFSIZE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ungetch: too many characters\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buf[bufp++] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
    <article id="post-arts-2" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/07/09/arts-2/"
    >arts-2</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/07/09/arts-2/" class="article-date">
  <time datetime="2018-07-09T03:25:45.000Z" itemprop="datePublished">2018-07-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> </p>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	minInt32, maxInt32 := <span class="number">-2147483648</span>, <span class="number">2147483647</span></span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; x != <span class="number">0</span>; x = x/<span class="number">10</span> &#123;</span><br><span class="line">		result = (result * <span class="number">10</span>) + x % <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> result &gt; maxInt32 || result &lt; minInt32  &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>​    首先想到的是把int转成字符串或码点数组，但没成功，思考后没有想到别的思路。后来看Discuss使用对10取余，pop&amp;push的方式，感觉豁然开朗，于是自己尝试写下了这种解法，美中不足是maxInt32和minInt32都是手动填写的，go语言里貌似没有现成的常量（也可能是我没找到），但肯定有能计算这个数的表达式，现在还不知道该怎么写，以后回来填坑。</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>原文：<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_01/index.html" target="_blank" rel="noopener">Act with Prudence</a></p>
<blockquote>
<p>*”Whatever you undertake, act with prudence and consider the consequences” Anon*</p>
</blockquote>
<p>​    源自耗子叔专栏推荐文章 <a href="https://legacy.gitbook.com/book/97-things-every-x-should-know/97-things-every-programmer-should-know/details" target="_blank" rel="noopener">97 Things Every Programmer Should Know</a> 中的第一篇，这个系列文章每过段时间看总会有新的认知，是难得的程序员用来学习并锻炼英文阅读能力的好文，推荐给大家。</p>
<p>​    我们在实际项目中经常遇到”doing it right” or “doing it quick”的问题，我的习惯是做事力求完美，但有些时候还是不够谨慎，这是我日后需要注意的。再就是一个项目第一版的质量非常重要，它决定了后面的迭代开发和维护的成本和效率，所以第一版尤其要写的仔细，多思考，即使是一些小的不合适的地方也要立即改正。不过我们也难免遇到因为排期压力妥协，遗留技术债务的情况，这时候一定要记录项目中遗留了哪些坑，还有哪些地方是需要完善的，并尽快处理这些逻辑。拖的越久，越难修复，最可怕的是拖到重构的代价已经超过重写，但为了服务在线还要继续维护，那剩下的只有无尽的痛苦，崩溃。。</p>
<h1 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h1><p>计算斐波纳切数列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibonacci1(i<span class="number">-2</span>) + fibonacci1(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci2</span><span class="params">(j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= j; i++ &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fibonacci1(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"fibonacci1 done: %v \n"</span>, time.Since(t1))</span><br><span class="line"></span><br><span class="line">	t2 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">40</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fibonacci2(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"fibonacci2 done: %v \n"</span>, time.Since(t2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    学习的过程中做做这种小练习还是蛮有意思的，上面的代码分别用递归（从大到小）和动态规划（从小到大）的思路进行实现。尤其是第二种从小到大计算的算法，“a, b = b, a+b” 因为我之前没写过python，看到后给我眼前一亮的感觉。写完后发现效率很差，开始用goroutine去优化性能，写的过程中坑还是蛮多的：</p>
<ul>
<li><p>对计数器的应用，如果顺序写的不对会导致wg.Done执行多次把数计成负的报一个panic异常；</p>
</li>
<li><p>还有在for循环中用goroutine 调用闭包时，这个单独的变量i是被所有 的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了i并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，所以当这些goroutine开始读取i的值时，它们所看到的值已经是slice的最后一个元素了。 显式地添加这个参数，我们能够确保使用的i是当go语句执行时的“当前”那个i。 </p>
</li>
</ul>
<p>  写完后会发现第二种解法会比第一种快很多很多。</p>
<h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://laravel-china.org/topics/9991/20-laravel-eloquent-necessary-practical-skills" target="_blank" rel="noopener">20 个 Laravel Eloquent 必备的实用技巧</a></p>
<p>​    一些你可能还不知道的Larvel实用技巧，学习了～</p>

      
      <!-- reward -->
      
    </div>
    

      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        Arron Qin
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="akaQin&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about/me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>